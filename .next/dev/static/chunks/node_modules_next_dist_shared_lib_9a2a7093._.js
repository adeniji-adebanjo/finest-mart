(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HeadManagerContext", {
    enumerable: true,
    get: function get() {
        return HeadManagerContext;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var HeadManagerContext = _react.default.createContext({});
if ("TURBOPACK compile-time truthy", 1) {
    HeadManagerContext.displayName = 'HeadManagerContext';
} //# sourceMappingURL=head-manager-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/mitt.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
MIT License

Copyright (c) Jason Miller (https://jasonformat.com/)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ // This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get() {
        return mitt;
    }
});
function mitt() {
    var all = Object.create(null);
    return {
        on: function on(type, handler) {
            ;
            (all[type] || (all[type] = [])).push(handler);
        },
        off: function off(type, handler) {
            if (all[type]) {
                all[type].splice(all[type].indexOf(handler) >>> 0, 1);
            }
        },
        emit: function emit(type) {
            for(var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                evts[_key - 1] = arguments[_key];
            }
            // eslint-disable-next-line array-callback-return
            ;
            (all[type] || []).slice().map(function(handler) {
                handler.apply(void 0, _to_consumable_array._(evts));
            });
        }
    };
} //# sourceMappingURL=mitt.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterContext", {
    enumerable: true,
    get: function get() {
        return RouterContext;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var RouterContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    RouterContext.displayName = 'RouterContext';
} //# sourceMappingURL=router-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function get() {
        return warnOnce;
    }
});
var warnOnce = function(_) {};
if ("TURBOPACK compile-time truthy", 1) {
    var warnings = new Set();
    warnOnce = function(msg) {
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "disableSmoothScrollDuringRouteTransition", {
    enumerable: true,
    get: function get() {
        return disableSmoothScrollDuringRouteTransition;
    }
});
var _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [client] (ecmascript)");
function disableSmoothScrollDuringRouteTransition(fn) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    var htmlElement = document.documentElement;
    var hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';
    if (!hasDataAttribute) {
        // Warn if smooth scrolling is detected but no data attribute is present
        if (("TURBOPACK compile-time value", "development") === 'development' && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {
            (0, _warnonce.warnOnce)('Detected `scroll-behavior: smooth` on the `<html>` element. To disable smooth scrolling during route transitions, ' + 'add `data-scroll-behavior="smooth"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');
        }
        // No smooth scrolling configured, run directly without style manipulation
        fn();
        return;
    }
    // Proceed with temporarily disabling smooth scrolling
    var existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = 'auto';
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=disable-smooth-scroll.js.map
}),
"[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * For a given page path, this function ensures that there is a leading slash.
 * If there is not a leading slash, one is added, otherwise it is noop.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureLeadingSlash", {
    enumerable: true,
    get: function get() {
        return ensureLeadingSlash;
    }
});
function ensureLeadingSlash(path) {
    return path.startsWith('/') ? path : "/".concat(path);
} //# sourceMappingURL=ensure-leading-slash.js.map
}),
"[project]/node_modules/next/dist/shared/lib/segment.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DEFAULT_SEGMENT_KEY: null,
    NOT_FOUND_SEGMENT_KEY: null,
    PAGE_SEGMENT_KEY: null,
    addSearchParamsIfPageSegment: null,
    computeSelectedLayoutSegment: null,
    getSegmentValue: null,
    getSelectedLayoutSegmentPath: null,
    isGroupSegment: null,
    isParallelRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_SEGMENT_KEY: function DEFAULT_SEGMENT_KEY1() {
        return DEFAULT_SEGMENT_KEY;
    },
    NOT_FOUND_SEGMENT_KEY: function NOT_FOUND_SEGMENT_KEY1() {
        return NOT_FOUND_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function PAGE_SEGMENT_KEY1() {
        return PAGE_SEGMENT_KEY;
    },
    addSearchParamsIfPageSegment: function addSearchParamsIfPageSegment1() {
        return addSearchParamsIfPageSegment;
    },
    computeSelectedLayoutSegment: function computeSelectedLayoutSegment1() {
        return computeSelectedLayoutSegment;
    },
    getSegmentValue: function getSegmentValue1() {
        return getSegmentValue;
    },
    getSelectedLayoutSegmentPath: function getSelectedLayoutSegmentPath1() {
        return getSelectedLayoutSegmentPath;
    },
    isGroupSegment: function isGroupSegment1() {
        return isGroupSegment;
    },
    isParallelRouteSegment: function isParallelRouteSegment1() {
        return isParallelRouteSegment;
    }
});
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
}
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    var isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        var stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
function computeSelectedLayoutSegment(segments, parallelRouteKey) {
    if (!segments || segments.length === 0) {
        return null;
    }
    // For 'children', use first segment; for other parallel routes, use last segment
    var rawSegment = parallelRouteKey === 'children' ? segments[0] : segments[segments.length - 1];
    // If the default slot is showing, return null since it's not technically "selected" (it's a fallback)
    // Returning an internal value like `__DEFAULT__` would be confusing
    return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment;
}
function getSelectedLayoutSegmentPath(tree, parallelRouteKey) {
    var first = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, segmentPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    var node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        var parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node = (_parallelRoutes_children = parallelRoutes.children) !== null && _parallelRoutes_children !== void 0 ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    var segment = node[0];
    var segmentValue = getSegmentValue(segment);
    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {
        return segmentPath;
    }
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
var PAGE_SEGMENT_KEY = '__PAGE__';
var DEFAULT_SEGMENT_KEY = '__DEFAULT__';
var NOT_FOUND_SEGMENT_KEY = '/_not-found'; //# sourceMappingURL=segment.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    normalizeAppPath: null,
    normalizeRscURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeAppPath: function normalizeAppPath1() {
        return normalizeAppPath;
    },
    normalizeRscURL: function normalizeRscURL1() {
        return normalizeRscURL;
    }
});
var _ensureleadingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [client] (ecmascript)");
var _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [client] (ecmascript)");
function normalizeAppPath(route) {
    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce(function(pathname, segment, index, segments) {
        // Empty segments are ignored.
        if (!segment) {
            return pathname;
        }
        // Groups are ignored.
        if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
        }
        // Parallel segments are ignored.
        if (segment[0] === '@') {
            return pathname;
        }
        // The last segment (if it's a leaf) should be ignored.
        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {
            return pathname;
        }
        return "".concat(pathname, "/").concat(segment);
    }, ''));
}
function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, '$1');
} //# sourceMappingURL=app-paths.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    INTERCEPTION_ROUTE_MARKERS: null,
    extractInterceptionRouteInformation: null,
    isInterceptionRouteAppPath: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERCEPTION_ROUTE_MARKERS: function INTERCEPTION_ROUTE_MARKERS1() {
        return INTERCEPTION_ROUTE_MARKERS;
    },
    extractInterceptionRouteInformation: function extractInterceptionRouteInformation1() {
        return extractInterceptionRouteInformation;
    },
    isInterceptionRouteAppPath: function isInterceptionRouteAppPath1() {
        return isInterceptionRouteAppPath;
    }
});
var _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [client] (ecmascript)");
var INTERCEPTION_ROUTE_MARKERS = [
    '(..)(..)',
    '(.)',
    '(..)',
    '(...)'
];
function isInterceptionRouteAppPath(path) {
    // TODO-APP: add more serious validation
    return path.split('/').find(function(segment) {
        return INTERCEPTION_ROUTE_MARKERS.find(function(m) {
            return segment.startsWith(m);
        });
    }) !== undefined;
}
function extractInterceptionRouteInformation(path) {
    var interceptingRoute;
    var marker;
    var interceptedRoute;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var segment = _step.value;
            marker = INTERCEPTION_ROUTE_MARKERS.find(function(m) {
                return segment.startsWith(m);
            });
            if (marker) {
                ;
                var ref;
                ref = _sliced_to_array._(path.split(marker, 2), 2), interceptingRoute = ref[0], interceptedRoute = ref[1], ref;
                return "break";
            }
        };
        for(var _iterator = path.split('/')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _ret = _loop();
            if (_ret === "break") break;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error("Invalid interception route: ".concat(path, ". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>")), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
        });
    }
    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed
    ;
    switch(marker){
        case '(.)':
            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
            if (interceptingRoute === '/') {
                interceptedRoute = "/".concat(interceptedRoute);
            } else {
                interceptedRoute = interceptingRoute + '/' + interceptedRoute;
            }
            break;
        case '(..)':
            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
            if (interceptingRoute === '/') {
                throw Object.defineProperty(new Error("Invalid interception route: ".concat(path, ". Cannot use (..) marker at the root level, use (.) instead.")), "__NEXT_ERROR_CODE", {
                    value: "E207",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');
            break;
        case '(...)':
            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
            interceptedRoute = '/' + interceptedRoute;
            break;
        case '(..)(..)':
            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
            var splitInterceptingRoute = interceptingRoute.split('/');
            if (splitInterceptingRoute.length <= 2) {
                throw Object.defineProperty(new Error("Invalid interception route: ".concat(path, ". Cannot use (..)(..) marker at the root level or one level up.")), "__NEXT_ERROR_CODE", {
                    value: "E486",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');
            break;
        default:
            throw Object.defineProperty(new Error('Invariant: unexpected marker'), "__NEXT_ERROR_CODE", {
                value: "E112",
                enumerable: false,
                configurable: true
            });
    }
    return {
        interceptingRoute: interceptingRoute,
        interceptedRoute: interceptedRoute
    };
} //# sourceMappingURL=interception-routes.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isDynamicRoute", {
    enumerable: true,
    get: function get() {
        return isDynamicRoute;
    }
});
var _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [client] (ecmascript)");
// Identify /.*[param].*/ in route string
var TEST_ROUTE = /\/[^/]*\[[^/]+\][^/]*(?=\/|$)/;
// Identify /[param]/ in route string
var TEST_STRICT_ROUTE = /\/\[[^/]+\](?=\/|$)/;
function isDynamicRoute(route) {
    var strict = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
    }
    if (strict) {
        return TEST_STRICT_ROUTE.test(route);
    }
    return TEST_ROUTE.test(route);
} //# sourceMappingURL=is-dynamic.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function assign1() {
        return assign;
    },
    searchParamsToUrlQuery: function searchParamsToUrlQuery1() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function urlQueryToSearchParams1() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    var query = {};
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = searchParams.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], value = _step_value[1];
            var existing = query[key];
            if (typeof existing === 'undefined') {
                query[key] = value;
            } else if (Array.isArray(existing)) {
                existing.push(value);
            } else {
                query[key] = [
                    existing,
                    value
                ];
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    var searchParams = new URLSearchParams();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(query)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], value = _step_value[1];
            if (Array.isArray(value)) {
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = value[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var item = _step1.value;
                        searchParams.append(key, stringifyUrlQueryParam(item));
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            } else {
                searchParams.set(key, stringifyUrlQueryParam(value));
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return searchParams;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = searchParamsList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var searchParams = _step.value;
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = searchParams.keys()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var key = _step1.value;
                    target.delete(key);
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
            try {
                for(var _iterator2 = searchParams.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var _step_value = _sliced_to_array._(_step2.value, 2), key1 = _step_value[0], value = _step_value[1];
                    target.append(key1, value);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                        _iterator2.return();
                    }
                } finally{
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
var _async_to_generator = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_async_to_generator.cjs [client] (ecmascript)");
var _call_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_call_super.cjs [client] (ecmascript)");
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _inherits = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_inherits.cjs [client] (ecmascript)");
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
var _wrap_native_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_wrap_native_super.cjs [client] (ecmascript)");
var _ts_generator = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_ts_generator.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function DecodeError1() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function MiddlewareNotFoundError1() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function MissingStaticPage1() {
        return MissingStaticPage;
    },
    NormalizeError: function NormalizeError1() {
        return NormalizeError;
    },
    PageNotFoundError: function PageNotFoundError1() {
        return PageNotFoundError;
    },
    SP: function SP1() {
        return SP;
    },
    ST: function ST1() {
        return ST;
    },
    WEB_VITALS: function WEB_VITALS1() {
        return WEB_VITALS;
    },
    execOnce: function execOnce1() {
        return execOnce;
    },
    getDisplayName: function getDisplayName1() {
        return getDisplayName;
    },
    getLocationOrigin: function getLocationOrigin1() {
        return getLocationOrigin;
    },
    getURL: function getURL1() {
        return getURL;
    },
    isAbsoluteUrl: function isAbsoluteUrl1() {
        return isAbsoluteUrl;
    },
    isResSent: function isResSent1() {
        return isResSent;
    },
    loadGetInitialProps: function loadGetInitialProps1() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function normalizeRepeatedSlashes1() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function stringifyError1() {
        return stringifyError;
    }
});
var WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    var used = false;
    var result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn.apply(void 0, _to_consumable_array._(args));
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
var isAbsoluteUrl = function(url) {
    return ABSOLUTE_URL_REGEX.test(url);
};
function getLocationOrigin() {
    var _window_location = window.location, protocol = _window_location.protocol, hostname = _window_location.hostname, port = _window_location.port;
    return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}
function getURL() {
    var href = window.location.href;
    var origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    var urlParts = url.split('?');
    var urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? "?".concat(urlParts.slice(1).join('?')) : '');
}
function loadGetInitialProps(App, ctx) {
    return _async_to_generator._(function() {
        var _App_prototype, message, res, _tmp, props, message1;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    if ("TURBOPACK compile-time truthy", 1) {
                        ;
                        if ((_App_prototype = App.prototype) === null || _App_prototype === void 0 ? void 0 : _App_prototype.getInitialProps) {
                            message = '"'.concat(getDisplayName(App), '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.');
                            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                                value: "E394",
                                enumerable: false,
                                configurable: true
                            });
                        }
                    }
                    // when called from _app `ctx` is nested in `ctx`
                    res = ctx.res || ctx.ctx && ctx.ctx.res;
                    if (!!App.getInitialProps) return [
                        3,
                        3
                    ];
                    if (!(ctx.ctx && ctx.Component)) return [
                        3,
                        2
                    ];
                    _tmp = {};
                    return [
                        4,
                        loadGetInitialProps(ctx.Component, ctx.ctx)
                    ];
                case 1:
                    // @ts-ignore pageProps default
                    return [
                        2,
                        (_tmp.pageProps = _state.sent(), _tmp)
                    ];
                case 2:
                    return [
                        2,
                        {}
                    ];
                case 3:
                    return [
                        4,
                        App.getInitialProps(ctx)
                    ];
                case 4:
                    props = _state.sent();
                    if (res && isResSent(res)) {
                        return [
                            2,
                            props
                        ];
                    }
                    if (!props) {
                        message1 = '"'.concat(getDisplayName(App), '.getInitialProps()" should resolve to an object. But found "').concat(props, '" instead.');
                        throw Object.defineProperty(new Error(message1), "__NEXT_ERROR_CODE", {
                            value: "E394",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    if ("TURBOPACK compile-time truthy", 1) {
                        if (Object.keys(props).length === 0 && !ctx.ctx) {
                            console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps"));
                        }
                    }
                    return [
                        2,
                        props
                    ];
            }
        });
    })();
}
var SP = typeof performance !== 'undefined';
var ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every(function(method) {
    return typeof performance[method] === 'function';
});
var DecodeError = /*#__PURE__*/ function(Error1) {
    _inherits._(DecodeError, Error1);
    function DecodeError() {
        _class_call_check._(this, DecodeError);
        return _call_super._(this, DecodeError, arguments);
    }
    return DecodeError;
}(_wrap_native_super._(Error));
var NormalizeError = /*#__PURE__*/ function(Error1) {
    _inherits._(NormalizeError, Error1);
    function NormalizeError() {
        _class_call_check._(this, NormalizeError);
        return _call_super._(this, NormalizeError, arguments);
    }
    return NormalizeError;
}(_wrap_native_super._(Error));
var PageNotFoundError = /*#__PURE__*/ function(Error1) {
    _inherits._(PageNotFoundError, Error1);
    function PageNotFoundError(page) {
        _class_call_check._(this, PageNotFoundError);
        var _this;
        _this = _call_super._(this, PageNotFoundError);
        _this.code = 'ENOENT';
        _this.name = 'PageNotFoundError';
        _this.message = "Cannot find module for page: ".concat(page);
        return _this;
    }
    return PageNotFoundError;
}(_wrap_native_super._(Error));
var MissingStaticPage = /*#__PURE__*/ function(Error1) {
    _inherits._(MissingStaticPage, Error1);
    function MissingStaticPage(page, message) {
        _class_call_check._(this, MissingStaticPage);
        var _this;
        _this = _call_super._(this, MissingStaticPage);
        _this.message = "Failed to load static file for page: ".concat(page, " ").concat(message);
        return _this;
    }
    return MissingStaticPage;
}(_wrap_native_super._(Error));
var MiddlewareNotFoundError = /*#__PURE__*/ function(Error1) {
    _inherits._(MiddlewareNotFoundError, Error1);
    function MiddlewareNotFoundError() {
        _class_call_check._(this, MiddlewareNotFoundError);
        var _this;
        _this = _call_super._(this, MiddlewareNotFoundError);
        _this.code = 'ENOENT';
        _this.message = "Cannot find the middleware module";
        return _this;
    }
    return MiddlewareNotFoundError;
}(_wrap_native_super._(Error));
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parsePath", {
    enumerable: true,
    get: function get() {
        return parsePath;
    }
});
function parsePath(path) {
    var hashIndex = path.indexOf('#');
    var queryIndex = path.indexOf('?');
    var hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathPrefix", {
    enumerable: true,
    get: function get() {
        return addPathPrefix;
    }
});
var _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [client] (ecmascript)");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    var _ref = (0, _parsepath.parsePath)(path), pathname = _ref.pathname, query = _ref.query, hash = _ref.hash;
    return "".concat(prefix).concat(pathname).concat(query).concat(hash);
} //# sourceMappingURL=add-path-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeTrailingSlash", {
    enumerable: true,
    get: function get() {
        return removeTrailingSlash;
    }
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/route-match-utils.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Client-safe utilities for route matching that don't import server-side
 * utilities to avoid bundling issues with Turbopack
 */ var _object_spread = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread.cjs [client] (ecmascript)");
var _object_spread_props = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread_props.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    safeCompile: null,
    safePathToRegexp: null,
    safeRegexpToFunction: null,
    safeRouteMatcher: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    safeCompile: function safeCompile1() {
        return safeCompile;
    },
    safePathToRegexp: function safePathToRegexp1() {
        return safePathToRegexp;
    },
    safeRegexpToFunction: function safeRegexpToFunction1() {
        return safeRegexpToFunction;
    },
    safeRouteMatcher: function safeRouteMatcher1() {
        return safeRouteMatcher;
    }
});
var _pathtoregexp = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-to-regexp/index.js [client] (ecmascript)");
var _routepatternnormalizer = __turbopack_context__.r("[project]/node_modules/next/dist/lib/route-pattern-normalizer.js [client] (ecmascript)");
function safePathToRegexp(route, keys, options) {
    if (typeof route !== 'string') {
        return (0, _pathtoregexp.pathToRegexp)(route, keys, options);
    }
    // Check if normalization is needed and cache the result
    var needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
    var routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
    try {
        return (0, _pathtoregexp.pathToRegexp)(routeToUse, keys, options);
    } catch (error) {
        // Only try normalization if we haven't already normalized
        if (!needsNormalization) {
            try {
                var normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
                return (0, _pathtoregexp.pathToRegexp)(normalizedRoute, keys, options);
            } catch (retryError) {
                // If that doesn't work, fall back to original error
                throw error;
            }
        }
        throw error;
    }
}
function safeCompile(route, options) {
    // Check if normalization is needed and cache the result
    var needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
    var routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
    try {
        var compiler = (0, _pathtoregexp.compile)(routeToUse, options);
        // If we normalized the route, wrap the compiler to strip separators from output
        // The normalization inserts _NEXTSEP_ as a literal string in the pattern to satisfy
        // path-to-regexp validation, but we don't want it in the final compiled URL
        if (needsNormalization) {
            return function(params) {
                return (0, _routepatternnormalizer.stripNormalizedSeparators)(compiler(params));
            };
        }
        return compiler;
    } catch (error) {
        // Only try normalization if we haven't already normalized
        if (!needsNormalization) {
            try {
                var normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
                var compiler1 = (0, _pathtoregexp.compile)(normalizedRoute, options);
                // Wrap the compiler to strip separators from output
                return function(params) {
                    return (0, _routepatternnormalizer.stripNormalizedSeparators)(compiler1(params));
                };
            } catch (retryError) {
                // If that doesn't work, fall back to original error
                throw error;
            }
        }
        throw error;
    }
}
function safeRegexpToFunction(regexp, keys) {
    var originalMatcher = (0, _pathtoregexp.regexpToFunction)(regexp, keys || []);
    return function(pathname) {
        var result = originalMatcher(pathname);
        if (!result) return false;
        // Clean parameters before returning
        return _object_spread_props._(_object_spread._({}, result), {
            params: (0, _routepatternnormalizer.stripParameterSeparators)(result.params)
        });
    };
}
function safeRouteMatcher(matcherFn) {
    return function(pathname) {
        var result = matcherFn(pathname);
        if (!result) return false;
        // Clean parameters before returning
        return (0, _routepatternnormalizer.stripParameterSeparators)(result);
    };
} //# sourceMappingURL=route-match-utils.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/route-matcher.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getRouteMatcher", {
    enumerable: true,
    get: function get() {
        return getRouteMatcher;
    }
});
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [client] (ecmascript)");
var _routematchutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-match-utils.js [client] (ecmascript)");
function getRouteMatcher(param) {
    var re = param.re, groups = param.groups;
    var rawMatcher = function(pathname) {
        var routeMatch = re.exec(pathname);
        if (!routeMatch) return false;
        var decode = function(param) {
            try {
                return decodeURIComponent(param);
            } catch (e) {
                throw Object.defineProperty(new _utils.DecodeError('failed to decode param'), "__NEXT_ERROR_CODE", {
                    value: "E528",
                    enumerable: false,
                    configurable: true
                });
            }
        };
        var params = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(groups)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], group = _step_value[1];
                var match = routeMatch[group.pos];
                if (match !== undefined) {
                    if (group.repeat) {
                        params[key] = match.split('/').map(function(entry) {
                            return decode(entry);
                        });
                    } else {
                        params[key] = decode(match);
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return params;
    };
    // Wrap with safe matcher to handle parameter cleaning
    return (0, _routematchutils.safeRouteMatcher)(rawMatcher);
} //# sourceMappingURL=route-matcher.js.map
}),
"[project]/node_modules/next/dist/shared/lib/escape-regexp.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// regexp is based on https://github.com/sindresorhus/escape-string-regexp
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "escapeStringRegexp", {
    enumerable: true,
    get: function get() {
        return escapeStringRegexp;
    }
});
var reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
var reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
function escapeStringRegexp(str) {
    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23
    if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, '\\$&');
    }
    return str;
} //# sourceMappingURL=escape-regexp.js.map
}),
"[project]/node_modules/next/dist/shared/lib/invariant-error.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _call_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_call_super.cjs [client] (ecmascript)");
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _inherits = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_inherits.cjs [client] (ecmascript)");
var _wrap_native_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_wrap_native_super.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "InvariantError", {
    enumerable: true,
    get: function get() {
        return InvariantError;
    }
});
var InvariantError = /*#__PURE__*/ function(Error1) {
    _inherits._(InvariantError, Error1);
    function InvariantError(message, options) {
        _class_call_check._(this, InvariantError);
        var _this;
        _this = _call_super._(this, InvariantError, [
            "Invariant: ".concat(message.endsWith('.') ? message : message + '.', " This is a bug in Next.js."),
            options
        ]);
        _this.name = 'InvariantError';
        return _this;
    }
    return InvariantError;
} //# sourceMappingURL=invariant-error.js.map
(_wrap_native_super._(Error));
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-loader-tree.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parseLoaderTree", {
    enumerable: true,
    get: function get() {
        return parseLoaderTree;
    }
});
var _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [client] (ecmascript)");
function parseLoaderTree(tree) {
    var _tree = _sliced_to_array._(tree, 3), segment = _tree[0], parallelRoutes = _tree[1], modules = _tree[2];
    var layout = modules.layout, template = modules.template;
    var page = modules.page;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === _segment.DEFAULT_SEGMENT_KEY ? modules.defaultPage : page;
    var conventionPath = (layout === null || layout === void 0 ? void 0 : layout[1]) || (template === null || template === void 0 ? void 0 : template[1]) || (page === null || page === void 0 ? void 0 : page[1]);
    return {
        page: page,
        segment: segment,
        modules: modules,
        /* it can be either layout / template / page */ conventionPath: conventionPath,
        parallelRoutes: parallelRoutes
    };
} //# sourceMappingURL=parse-loader-tree.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/get-segment-param.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getParamProperties: null,
    getSegmentParam: null,
    isCatchAll: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getParamProperties: function getParamProperties1() {
        return getParamProperties;
    },
    getSegmentParam: function getSegmentParam1() {
        return getSegmentParam;
    },
    isCatchAll: function isCatchAll1() {
        return isCatchAll;
    }
});
var _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [client] (ecmascript)");
function getSegmentParam(segment) {
    var interceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(function(marker) {
        return segment.startsWith(marker);
    });
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith('[[...') && segment.endsWith(']]')) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            paramType: 'optional-catchall',
            paramName: segment.slice(5, -2)
        };
    }
    if (segment.startsWith('[...') && segment.endsWith(']')) {
        return {
            paramType: interceptionMarker ? "catchall-intercepted-".concat(interceptionMarker) : 'catchall',
            paramName: segment.slice(4, -1)
        };
    }
    if (segment.startsWith('[') && segment.endsWith(']')) {
        return {
            paramType: interceptionMarker ? "dynamic-intercepted-".concat(interceptionMarker) : 'dynamic',
            paramName: segment.slice(1, -1)
        };
    }
    return null;
}
function isCatchAll(type) {
    return type === 'catchall' || type === 'catchall-intercepted-(..)(..)' || type === 'catchall-intercepted-(.)' || type === 'catchall-intercepted-(..)' || type === 'catchall-intercepted-(...)' || type === 'optional-catchall';
}
function getParamProperties(paramType) {
    var repeat = false;
    var optional = false;
    switch(paramType){
        case 'catchall':
        case 'catchall-intercepted-(..)(..)':
        case 'catchall-intercepted-(.)':
        case 'catchall-intercepted-(..)':
        case 'catchall-intercepted-(...)':
            repeat = true;
            break;
        case 'optional-catchall':
            repeat = true;
            optional = true;
            break;
        case 'dynamic':
        case 'dynamic-intercepted-(..)(..)':
        case 'dynamic-intercepted-(.)':
        case 'dynamic-intercepted-(..)':
        case 'dynamic-intercepted-(...)':
            break;
        default:
            paramType;
    }
    return {
        repeat: repeat,
        optional: optional
    };
} //# sourceMappingURL=get-segment-param.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/routes/app.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isInterceptionAppRoute: null,
    isNormalizedAppRoute: null,
    parseAppRoute: null,
    parseAppRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isInterceptionAppRoute: function isInterceptionAppRoute1() {
        return isInterceptionAppRoute;
    },
    isNormalizedAppRoute: function isNormalizedAppRoute1() {
        return isNormalizedAppRoute;
    },
    parseAppRoute: function parseAppRoute1() {
        return parseAppRoute;
    },
    parseAppRouteSegment: function parseAppRouteSegment1() {
        return parseAppRouteSegment;
    }
});
var _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [client] (ecmascript)");
var _getsegmentparam = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/get-segment-param.js [client] (ecmascript)");
var _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [client] (ecmascript)");
function parseAppRouteSegment(segment) {
    if (segment === '') {
        return null;
    }
    // Check if the segment starts with an interception marker
    var interceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(function(m) {
        return segment.startsWith(m);
    });
    var param = (0, _getsegmentparam.getSegmentParam)(segment);
    if (param) {
        return {
            type: 'dynamic',
            name: segment,
            param: param,
            interceptionMarker: interceptionMarker
        };
    } else if (segment.startsWith('(') && segment.endsWith(')')) {
        return {
            type: 'route-group',
            name: segment,
            interceptionMarker: interceptionMarker
        };
    } else if (segment.startsWith('@')) {
        return {
            type: 'parallel-route',
            name: segment,
            interceptionMarker: interceptionMarker
        };
    } else {
        return {
            type: 'static',
            name: segment,
            interceptionMarker: interceptionMarker
        };
    }
}
function isNormalizedAppRoute(route) {
    return route.normalized;
}
function isInterceptionAppRoute(route) {
    return route.interceptionMarker !== undefined && route.interceptingRoute !== undefined && route.interceptedRoute !== undefined;
}
function parseAppRoute(pathname, normalized) {
    var pathnameSegments = pathname.split('/').filter(Boolean);
    // Build segments array with static and dynamic segments
    var segments = [];
    // Parse if this is an interception route.
    var interceptionMarker;
    var interceptingRoute;
    var interceptedRoute;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = pathnameSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var segment = _step.value;
            // Parse the segment into an AppSegment.
            var appSegment = parseAppRouteSegment(segment);
            if (!appSegment) {
                continue;
            }
            if (normalized && (appSegment.type === 'route-group' || appSegment.type === 'parallel-route')) {
                throw Object.defineProperty(new _invarianterror.InvariantError("".concat(pathname, " is being parsed as a normalized route, but it has a route group or parallel route segment.")), "__NEXT_ERROR_CODE", {
                    value: "E923",
                    enumerable: false,
                    configurable: true
                });
            }
            segments.push(appSegment);
            if (appSegment.interceptionMarker) {
                var parts = pathname.split(appSegment.interceptionMarker);
                if (parts.length !== 2) {
                    throw Object.defineProperty(new Error("Invalid interception route: ".concat(pathname)), "__NEXT_ERROR_CODE", {
                        value: "E924",
                        enumerable: false,
                        configurable: true
                    });
                }
                interceptingRoute = normalized ? parseAppRoute(parts[0], true) : parseAppRoute(parts[0], false);
                interceptedRoute = normalized ? parseAppRoute(parts[1], true) : parseAppRoute(parts[1], false);
                interceptionMarker = appSegment.interceptionMarker;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    var dynamicSegments = segments.filter(function(segment) {
        return segment.type === 'dynamic';
    });
    return {
        normalized: normalized,
        pathname: pathname,
        segments: segments,
        dynamicSegments: dynamicSegments,
        interceptionMarker: interceptionMarker,
        interceptingRoute: interceptingRoute,
        interceptedRoute: interceptedRoute
    };
} //# sourceMappingURL=app.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interception-prefix-from-param-type.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "interceptionPrefixFromParamType", {
    enumerable: true,
    get: function get() {
        return interceptionPrefixFromParamType;
    }
});
function interceptionPrefixFromParamType(paramType) {
    switch(paramType){
        case 'catchall-intercepted-(..)(..)':
        case 'dynamic-intercepted-(..)(..)':
            return '(..)(..)';
        case 'catchall-intercepted-(.)':
        case 'dynamic-intercepted-(.)':
            return '(.)';
        case 'catchall-intercepted-(..)':
        case 'dynamic-intercepted-(..)':
            return '(..)';
        case 'catchall-intercepted-(...)':
        case 'dynamic-intercepted-(...)':
            return '(...)';
        case 'catchall':
        case 'dynamic':
        case 'optional-catchall':
        default:
            return null;
    }
} //# sourceMappingURL=interception-prefix-from-param-type.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/resolve-param-value.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "resolveParamValue", {
    enumerable: true,
    get: function get() {
        return resolveParamValue;
    }
});
var _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [client] (ecmascript)");
var _interceptionprefixfromparamtype = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-prefix-from-param-type.js [client] (ecmascript)");
/**
 * Extracts the param value from a path segment, handling interception markers
 * based on the expected param type.
 *
 * @param pathSegment - The path segment to extract the value from
 * @param params - The current params object for resolving dynamic param references
 * @param paramType - The expected param type which may include interception marker info
 * @returns The extracted param value
 */ function getParamValueFromSegment(pathSegment, params, paramType) {
    // If the segment is dynamic, resolve it from the params object
    if (pathSegment.type === 'dynamic') {
        return params[pathSegment.param.paramName];
    }
    // If the paramType indicates this is an intercepted param, strip the marker
    // that matches the interception marker in the param type
    var interceptionPrefix = (0, _interceptionprefixfromparamtype.interceptionPrefixFromParamType)(paramType);
    if (interceptionPrefix === pathSegment.interceptionMarker) {
        return pathSegment.name.replace(pathSegment.interceptionMarker, '');
    }
    // For static segments, use the name
    return pathSegment.name;
}
function resolveParamValue(paramName, paramType, depth, route, params) {
    switch(paramType){
        case 'catchall':
        case 'optional-catchall':
        case 'catchall-intercepted-(..)(..)':
        case 'catchall-intercepted-(.)':
        case 'catchall-intercepted-(..)':
        case 'catchall-intercepted-(...)':
            // For catchall routes, derive from pathname using depth to determine
            // which segments to use
            var processedSegments = [];
            // Process segments to handle any embedded dynamic params
            for(var index = depth; index < route.segments.length; index++){
                var pathSegment = route.segments[index];
                if (pathSegment.type === 'static') {
                    var value = pathSegment.name;
                    // For intercepted catch-all params, strip the marker from the first segment
                    var interceptionPrefix = (0, _interceptionprefixfromparamtype.interceptionPrefixFromParamType)(paramType);
                    if (interceptionPrefix && index === depth && interceptionPrefix === pathSegment.interceptionMarker) {
                        // Strip the interception marker from the value
                        value = value.replace(pathSegment.interceptionMarker, '');
                    }
                    processedSegments.push(value);
                } else {
                    // If the segment is a param placeholder, check if we have its value
                    if (!params.hasOwnProperty(pathSegment.param.paramName)) {
                        // If the segment is an optional catchall, we can break out of the
                        // loop because it's optional!
                        if (pathSegment.param.paramType === 'optional-catchall') {
                            break;
                        }
                        // Unknown param placeholder in pathname - can't derive full value
                        return undefined;
                    }
                    // If the segment matches a param, use the param value
                    // We don't encode values here as that's handled during retrieval.
                    var paramValue = params[pathSegment.param.paramName];
                    if (Array.isArray(paramValue)) {
                        var _processedSegments;
                        (_processedSegments = processedSegments).push.apply(_processedSegments, _to_consumable_array._(paramValue));
                    } else {
                        processedSegments.push(paramValue);
                    }
                }
            }
            if (processedSegments.length > 0) {
                return processedSegments;
            } else if (paramType === 'optional-catchall') {
                return undefined;
            } else {
                // We shouldn't be able to match a catchall segment without any path
                // segments if it's not an optional catchall
                throw Object.defineProperty(new _invarianterror.InvariantError('Unexpected empty path segments match for a route "'.concat(route.pathname, '" with param "').concat(paramName, '" of type "').concat(paramType, '"')), "__NEXT_ERROR_CODE", {
                    value: "E931",
                    enumerable: false,
                    configurable: true
                });
            }
        case 'dynamic':
        case 'dynamic-intercepted-(..)(..)':
        case 'dynamic-intercepted-(.)':
        case 'dynamic-intercepted-(..)':
        case 'dynamic-intercepted-(...)':
            // For regular dynamic parameters, take the segment at this depth
            if (depth < route.segments.length) {
                var pathSegment1 = route.segments[depth];
                // Check if the segment at this depth is a placeholder for an unknown param
                if (pathSegment1.type === 'dynamic' && !params.hasOwnProperty(pathSegment1.param.paramName)) {
                    // The segment is a placeholder like [category] and we don't have the value
                    return undefined;
                }
                // If the segment matches a param, use the param value from params object
                // Otherwise it's a static segment, just use it directly
                // We don't encode values here as that's handled during retrieval
                return getParamValueFromSegment(pathSegment1, params, paramType);
            }
            return undefined;
        default:
            paramType;
    }
} //# sourceMappingURL=resolve-param-value.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PARAMETER_PATTERN: null,
    getDynamicParam: null,
    interpolateParallelRouteParams: null,
    parseMatchedParameter: null,
    parseParameter: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PARAMETER_PATTERN: function PARAMETER_PATTERN1() {
        return PARAMETER_PATTERN;
    },
    getDynamicParam: function getDynamicParam1() {
        return getDynamicParam;
    },
    interpolateParallelRouteParams: function interpolateParallelRouteParams1() {
        return interpolateParallelRouteParams;
    },
    parseMatchedParameter: function parseMatchedParameter1() {
        return parseMatchedParameter;
    },
    parseParameter: function parseParameter1() {
        return parseParameter;
    }
});
var _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [client] (ecmascript)");
var _parseloadertree = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-loader-tree.js [client] (ecmascript)");
var _app = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/routes/app.js [client] (ecmascript)");
var _resolveparamvalue = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/resolve-param-value.js [client] (ecmascript)");
/**
 * Gets the value of a param from the params object. This correctly handles the
 * case where the param is a fallback route param and encodes the resulting
 * value.
 *
 * @param interpolatedParams - The params object.
 * @param segmentKey - The key of the segment.
 * @param fallbackRouteParams - The fallback route params.
 * @returns The value of the param.
 */ function getParamValue(interpolatedParams, segmentKey, fallbackRouteParams) {
    var value = interpolatedParams[segmentKey];
    if (fallbackRouteParams === null || fallbackRouteParams === void 0 ? void 0 : fallbackRouteParams.has(segmentKey)) {
        // We know that the fallback route params has the segment key because we
        // checked that above.
        var _fallbackRouteParams_get = _sliced_to_array._(fallbackRouteParams.get(segmentKey), 1), searchValue = _fallbackRouteParams_get[0];
        value = searchValue;
    } else if (Array.isArray(value)) {
        value = value.map(function(i) {
            return encodeURIComponent(i);
        });
    } else if (typeof value === 'string') {
        value = encodeURIComponent(value);
    }
    return value;
}
function interpolateParallelRouteParams(loaderTree, params, pagePath, fallbackRouteParams) {
    var interpolated = structuredClone(params);
    // Stack-based traversal with depth tracking
    var stack = [
        {
            tree: loaderTree,
            depth: 0
        }
    ];
    // Parse the route from the provided page path.
    var route = (0, _app.parseAppRoute)(pagePath, true);
    while(stack.length > 0){
        var _stack_pop = stack.pop(), tree = _stack_pop.tree, depth = _stack_pop.depth;
        var _ref = (0, _parseloadertree.parseLoaderTree)(tree), segment = _ref.segment, parallelRoutes = _ref.parallelRoutes;
        var appSegment = (0, _app.parseAppRouteSegment)(segment);
        if ((appSegment === null || appSegment === void 0 ? void 0 : appSegment.type) === 'dynamic' && !interpolated.hasOwnProperty(appSegment.param.paramName) && // If the param is in the fallback route params, we don't need to
        // interpolate it because it's already marked as being unknown.
        !(fallbackRouteParams === null || fallbackRouteParams === void 0 ? void 0 : fallbackRouteParams.has(appSegment.param.paramName))) {
            var _appSegment_param = appSegment.param, paramName = _appSegment_param.paramName, paramType = _appSegment_param.paramType;
            var paramValue = (0, _resolveparamvalue.resolveParamValue)(paramName, paramType, depth, route, interpolated);
            if (paramValue !== undefined) {
                interpolated[paramName] = paramValue;
            } else if (paramType !== 'optional-catchall') {
                throw Object.defineProperty(new _invarianterror.InvariantError("Could not resolve param value for segment: ".concat(paramName)), "__NEXT_ERROR_CODE", {
                    value: "E932",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        // Calculate next depth - increment if this is not a route group and not empty
        var nextDepth = depth;
        if (appSegment && appSegment.type !== 'route-group' && appSegment.type !== 'parallel-route') {
            nextDepth++;
        }
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            // Add all parallel routes to the stack for processing
            for(var _iterator = Object.values(parallelRoutes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var parallelRoute = _step.value;
                stack.push({
                    tree: parallelRoute,
                    depth: nextDepth
                });
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return interpolated;
}
function getDynamicParam(interpolatedParams, segmentKey, dynamicParamType, fallbackRouteParams) {
    var value = getParamValue(interpolatedParams, segmentKey, fallbackRouteParams);
    // handle the case where an optional catchall does not have a value,
    // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`
    if (!value || value.length === 0) {
        if (dynamicParamType === 'oc') {
            return {
                param: segmentKey,
                value: null,
                type: dynamicParamType,
                treeSegment: [
                    segmentKey,
                    '',
                    dynamicParamType
                ]
            };
        }
        throw Object.defineProperty(new _invarianterror.InvariantError('Missing value for segment key: "'.concat(segmentKey, '" with dynamic param type: ').concat(dynamicParamType)), "__NEXT_ERROR_CODE", {
            value: "E864",
            enumerable: false,
            configurable: true
        });
    }
    return {
        param: segmentKey,
        // The value that is passed to user code.
        value: value,
        // The value that is rendered in the router tree.
        treeSegment: [
            segmentKey,
            Array.isArray(value) ? value.join('/') : value,
            dynamicParamType
        ],
        type: dynamicParamType
    };
}
var PARAMETER_PATTERN = /^([^[]*)\[((?:\[[^\]]*\])|[^\]]+)\](.*)$/;
function parseParameter(param) {
    var match = param.match(PARAMETER_PATTERN);
    if (!match) {
        return parseMatchedParameter(param);
    }
    return parseMatchedParameter(match[2]);
}
function parseMatchedParameter(param) {
    var optional = param.startsWith('[') && param.endsWith(']');
    if (optional) {
        param = param.slice(1, -1);
    }
    var repeat = param.startsWith('...');
    if (repeat) {
        param = param.slice(3);
    }
    return {
        key: param,
        repeat: repeat,
        optional: optional
    };
} //# sourceMappingURL=get-dynamic-param.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/route-regex.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _object_spread = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread.cjs [client] (ecmascript)");
var _object_spread_props = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread_props.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getNamedMiddlewareRegex: null,
    getNamedRouteRegex: null,
    getRouteRegex: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getNamedMiddlewareRegex: function getNamedMiddlewareRegex1() {
        return getNamedMiddlewareRegex;
    },
    getNamedRouteRegex: function getNamedRouteRegex1() {
        return getNamedRouteRegex;
    },
    getRouteRegex: function getRouteRegex1() {
        return getRouteRegex;
    }
});
var _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [client] (ecmascript)");
var _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [client] (ecmascript)");
var _escaperegexp = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/escape-regexp.js [client] (ecmascript)");
var _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [client] (ecmascript)");
var _getdynamicparam = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js [client] (ecmascript)");
function getParametrizedRoute(route, includeSuffix, includePrefix) {
    var groups = {};
    var groupIndex = 1;
    var segments = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var segment = _step.value;
            var markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(function(m) {
                return segment.startsWith(m);
            });
            var paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN) // Check for parameters
            ;
            if (markerMatch && paramMatches && paramMatches[2]) {
                var _ref = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]), key = _ref.key, optional = _ref.optional, repeat = _ref.repeat;
                groups[key] = {
                    pos: groupIndex++,
                    repeat: repeat,
                    optional: optional
                };
                segments.push("/".concat((0, _escaperegexp.escapeStringRegexp)(markerMatch), "([^/]+?)"));
            } else if (paramMatches && paramMatches[2]) {
                var _ref1 = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]), key1 = _ref1.key, repeat1 = _ref1.repeat, optional1 = _ref1.optional;
                groups[key1] = {
                    pos: groupIndex++,
                    repeat: repeat1,
                    optional: optional1
                };
                if (includePrefix && paramMatches[1]) {
                    segments.push("/".concat((0, _escaperegexp.escapeStringRegexp)(paramMatches[1])));
                }
                var s = repeat1 ? optional1 ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
                // Remove the leading slash if includePrefix already added it.
                if (includePrefix && paramMatches[1]) {
                    s = s.substring(1);
                }
                segments.push(s);
            } else {
                segments.push("/".concat((0, _escaperegexp.escapeStringRegexp)(segment)));
            }
            // If there's a suffix, add it to the segments if it's enabled.
            if (includeSuffix && paramMatches && paramMatches[3]) {
                segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
            }
        };
        for(var _iterator = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return {
        parameterizedRoute: segments.join(''),
        groups: groups
    };
}
function getRouteRegex(normalizedRoute) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_includeSuffix = _ref.includeSuffix, includeSuffix = _ref_includeSuffix === void 0 ? false : _ref_includeSuffix, _ref_includePrefix = _ref.includePrefix, includePrefix = _ref_includePrefix === void 0 ? false : _ref_includePrefix, _ref_excludeOptionalTrailingSlash = _ref.excludeOptionalTrailingSlash, excludeOptionalTrailingSlash = _ref_excludeOptionalTrailingSlash === void 0 ? false : _ref_excludeOptionalTrailingSlash;
    var _getParametrizedRoute = getParametrizedRoute(normalizedRoute, includeSuffix, includePrefix), parameterizedRoute = _getParametrizedRoute.parameterizedRoute, groups = _getParametrizedRoute.groups;
    var re = parameterizedRoute;
    if (!excludeOptionalTrailingSlash) {
        re += '(?:/)?';
    }
    return {
        re: new RegExp("^".concat(re, "$")),
        groups: groups
    };
}
/**
 * Builds a function to generate a minimal routeKey using only a-z and minimal
 * number of characters.
 */ function buildGetSafeRouteKey() {
    var i = 0;
    return function() {
        var routeKey = '';
        var j = ++i;
        while(j > 0){
            routeKey += String.fromCharCode(97 + (j - 1) % 26);
            j = Math.floor((j - 1) / 26);
        }
        return routeKey;
    };
}
function getSafeKeyFromSegment(param) {
    var interceptionMarker = param.interceptionMarker, getSafeRouteKey = param.getSafeRouteKey, segment = param.segment, routeKeys = param.routeKeys, keyPrefix = param.keyPrefix, backreferenceDuplicateKeys = param.backreferenceDuplicateKeys;
    var _ref = (0, _getdynamicparam.parseMatchedParameter)(segment), key = _ref.key, optional = _ref.optional, repeat = _ref.repeat;
    // replace any non-word characters since they can break
    // the named regex
    var cleanedKey = key.replace(/\W/g, '');
    if (keyPrefix) {
        cleanedKey = "".concat(keyPrefix).concat(cleanedKey);
    }
    var invalidKey = false;
    // check if the key is still invalid and fallback to using a known
    // safe key
    if (cleanedKey.length === 0 || cleanedKey.length > 30) {
        invalidKey = true;
    }
    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
        invalidKey = true;
    }
    if (invalidKey) {
        cleanedKey = getSafeRouteKey();
    }
    var duplicateKey = cleanedKey in routeKeys;
    if (keyPrefix) {
        routeKeys[cleanedKey] = "".concat(keyPrefix).concat(key);
    } else {
        routeKeys[cleanedKey] = key;
    }
    // if the segment has an interception marker, make sure that's part of the regex pattern
    // this is to ensure that the route with the interception marker doesn't incorrectly match
    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])
    var interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : '';
    var pattern;
    if (duplicateKey && backreferenceDuplicateKeys) {
        // Use a backreference to the key to ensure that the key is the same value
        // in each of the placeholders.
        pattern = "\\k<".concat(cleanedKey, ">");
    } else if (repeat) {
        pattern = "(?<".concat(cleanedKey, ">.+?)");
    } else {
        pattern = "(?<".concat(cleanedKey, ">[^/]+?)");
    }
    return {
        key: key,
        pattern: optional ? "(?:/".concat(interceptionPrefix).concat(pattern, ")?") : "/".concat(interceptionPrefix).concat(pattern),
        cleanedKey: cleanedKey,
        optional: optional,
        repeat: repeat
    };
}
function getNamedParametrizedRoute(route, prefixRouteKeys, includeSuffix, includePrefix, backreferenceDuplicateKeys) {
    var reference = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        names: {},
        intercepted: {}
    };
    var getSafeRouteKey = buildGetSafeRouteKey();
    var routeKeys = {};
    var segments = [];
    var inverseParts = [];
    // Ensure we don't mutate the original reference object.
    reference = structuredClone(reference);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var segment = _step.value;
            var hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(function(m) {
                return segment.startsWith(m);
            });
            var paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN) // Check for parameters
            ;
            var interceptionMarker = hasInterceptionMarker ? paramMatches === null || paramMatches === void 0 ? void 0 : paramMatches[1] : undefined;
            var keyPrefix = void 0;
            if (interceptionMarker && (paramMatches === null || paramMatches === void 0 ? void 0 : paramMatches[2])) {
                keyPrefix = prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined;
                reference.intercepted[paramMatches[2]] = interceptionMarker;
            } else if ((paramMatches === null || paramMatches === void 0 ? void 0 : paramMatches[2]) && reference.intercepted[paramMatches[2]]) {
                keyPrefix = prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined;
            } else {
                keyPrefix = prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined;
            }
            if (interceptionMarker && paramMatches && paramMatches[2]) {
                var _reference_names, _key;
                // If there's an interception marker, add it to the segments.
                var _getSafeKeyFromSegment = getSafeKeyFromSegment({
                    getSafeRouteKey: getSafeRouteKey,
                    interceptionMarker: interceptionMarker,
                    segment: paramMatches[2],
                    routeKeys: routeKeys,
                    keyPrefix: keyPrefix,
                    backreferenceDuplicateKeys: backreferenceDuplicateKeys
                }), key = _getSafeKeyFromSegment.key, pattern = _getSafeKeyFromSegment.pattern, cleanedKey = _getSafeKeyFromSegment.cleanedKey, repeat = _getSafeKeyFromSegment.repeat, optional = _getSafeKeyFromSegment.optional;
                segments.push(pattern);
                var _reference_names_key;
                inverseParts.push("/".concat(paramMatches[1], ":").concat((_reference_names_key = reference.names[key]) !== null && _reference_names_key !== void 0 ? _reference_names_key : cleanedKey).concat(repeat ? optional ? '*' : '+' : ''));
                var _;
                (_ = (_reference_names = reference.names)[_key = key]) !== null && _ !== void 0 ? _ : _reference_names[_key] = cleanedKey;
            } else if (paramMatches && paramMatches[2]) {
                var _reference_names1, _key1;
                // If there's a prefix, add it to the segments if it's enabled.
                if (includePrefix && paramMatches[1]) {
                    segments.push("/".concat((0, _escaperegexp.escapeStringRegexp)(paramMatches[1])));
                    inverseParts.push("/".concat(paramMatches[1]));
                }
                var _getSafeKeyFromSegment1 = getSafeKeyFromSegment({
                    getSafeRouteKey: getSafeRouteKey,
                    segment: paramMatches[2],
                    routeKeys: routeKeys,
                    keyPrefix: keyPrefix,
                    backreferenceDuplicateKeys: backreferenceDuplicateKeys
                }), key1 = _getSafeKeyFromSegment1.key, pattern1 = _getSafeKeyFromSegment1.pattern, cleanedKey1 = _getSafeKeyFromSegment1.cleanedKey, repeat1 = _getSafeKeyFromSegment1.repeat, optional1 = _getSafeKeyFromSegment1.optional;
                // Remove the leading slash if includePrefix already added it.
                var s = pattern1;
                if (includePrefix && paramMatches[1]) {
                    s = s.substring(1);
                }
                segments.push(s);
                var _reference_names_key1;
                inverseParts.push("/:".concat((_reference_names_key1 = reference.names[key1]) !== null && _reference_names_key1 !== void 0 ? _reference_names_key1 : cleanedKey1).concat(repeat1 ? optional1 ? '*' : '+' : ''));
                var _1;
                (_1 = (_reference_names1 = reference.names)[_key1 = key1]) !== null && _1 !== void 0 ? _1 : _reference_names1[_key1] = cleanedKey1;
            } else {
                segments.push("/".concat((0, _escaperegexp.escapeStringRegexp)(segment)));
                inverseParts.push("/".concat(segment));
            }
            // If there's a suffix, add it to the segments if it's enabled.
            if (includeSuffix && paramMatches && paramMatches[3]) {
                segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
                inverseParts.push(paramMatches[3]);
            }
        };
        for(var _iterator = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return {
        namedParameterizedRoute: segments.join(''),
        routeKeys: routeKeys,
        pathToRegexpPattern: inverseParts.join(''),
        reference: reference
    };
}
function getNamedRouteRegex(normalizedRoute, options) {
    var _options_includeSuffix, _options_includePrefix, _options_backreferenceDuplicateKeys;
    var result = getNamedParametrizedRoute(normalizedRoute, options.prefixRouteKeys, (_options_includeSuffix = options.includeSuffix) !== null && _options_includeSuffix !== void 0 ? _options_includeSuffix : false, (_options_includePrefix = options.includePrefix) !== null && _options_includePrefix !== void 0 ? _options_includePrefix : false, (_options_backreferenceDuplicateKeys = options.backreferenceDuplicateKeys) !== null && _options_backreferenceDuplicateKeys !== void 0 ? _options_backreferenceDuplicateKeys : false, options.reference);
    var namedRegex = result.namedParameterizedRoute;
    if (!options.excludeOptionalTrailingSlash) {
        namedRegex += '(?:/)?';
    }
    return _object_spread_props._(_object_spread._({}, getRouteRegex(normalizedRoute, options)), {
        namedRegex: "^".concat(namedRegex, "$"),
        routeKeys: result.routeKeys,
        pathToRegexpPattern: result.pathToRegexpPattern,
        reference: result.reference
    });
}
function getNamedMiddlewareRegex(normalizedRoute, options) {
    var parameterizedRoute = getParametrizedRoute(normalizedRoute, false, false).parameterizedRoute;
    var _options_catchAll = options.catchAll, catchAll = _options_catchAll === void 0 ? true : _options_catchAll;
    if (parameterizedRoute === '/') {
        var catchAllRegex = catchAll ? '.*' : '';
        return {
            namedRegex: "^/".concat(catchAllRegex, "$")
        };
    }
    var namedParameterizedRoute = getNamedParametrizedRoute(normalizedRoute, false, false, false, false, undefined).namedParameterizedRoute;
    var catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';
    return {
        namedRegex: "^".concat(namedParameterizedRoute).concat(catchAllGroupedRegex, "$")
    };
} //# sourceMappingURL=route-regex.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "interpolateAs", {
    enumerable: true,
    get: function get() {
        return interpolateAs;
    }
});
var _routematcher = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-matcher.js [client] (ecmascript)");
var _routeregex = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-regex.js [client] (ecmascript)");
function interpolateAs(route, asPathname, query) {
    var interpolatedRoute = '';
    var dynamicRegex = (0, _routeregex.getRouteRegex)(route);
    var dynamicGroups = dynamicRegex.groups;
    var dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
    // TODO: should this take priority; also need to change in the router.
    query;
    interpolatedRoute = route;
    var params = Object.keys(dynamicGroups);
    if (!params.every(function(param) {
        var value = dynamicMatches[param] || '';
        var _dynamicGroups_param = dynamicGroups[param], repeat = _dynamicGroups_param.repeat, optional = _dynamicGroups_param.optional;
        // support single-level catch-all
        // TODO: more robust handling for user-error (passing `/`)
        var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");
        if (optional) {
            replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
        }
        if (repeat && !Array.isArray(value)) value = [
            value
        ];
        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted
        // into the URL and we expect URL encoded segments
        // when parsing dynamic route params
        function(segment) {
            return encodeURIComponent(segment);
        }).join('/') : encodeURIComponent(value)) || '/');
    })) {
        interpolatedRoute = '' // did not satisfy all requirements
        ;
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
    }
    return {
        params: params,
        result: interpolatedRoute
    };
} //# sourceMappingURL=interpolate-as.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get() {
        return getAssetPathFromRoute;
    }
});
function getAssetPathFromRoute(route) {
    var ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '';
    var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : route;
    return path + ext;
} //# sourceMappingURL=get-asset-path-from-route.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parseRelativeUrl", {
    enumerable: true,
    get: function get() {
        return parseRelativeUrl;
    }
});
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [client] (ecmascript)");
var _querystring = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [client] (ecmascript)");
function parseRelativeUrl(url, base) {
    var parseQuery = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var globalBase = new URL(typeof window === 'undefined' ? 'http://n' : (0, _utils.getLocationOrigin)());
    var resolvedBase = base ? new URL(base, globalBase) : url.startsWith('.') ? new URL(typeof window === 'undefined' ? 'http://n' : window.location.href) : globalBase;
    var _ref = new URL(url, resolvedBase), pathname = _ref.pathname, searchParams = _ref.searchParams, search = _ref.search, hash = _ref.hash, href = _ref.href, origin = _ref.origin;
    if (origin !== globalBase.origin) {
        throw Object.defineProperty(new Error("invariant: invalid relative URL, router received ".concat(url)), "__NEXT_ERROR_CODE", {
            value: "E159",
            enumerable: false,
            configurable: true
        });
    }
    return {
        pathname: pathname,
        query: parseQuery ? (0, _querystring.searchParamsToUrlQuery)(searchParams) : undefined,
        search: search,
        hash: hash,
        href: href.slice(origin.length),
        // We don't know for relative URLs at this point since we set a custom, internal
        // base that isn't surfaced to users.
        slashes: undefined
    };
} //# sourceMappingURL=parse-relative-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/deployment-id.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
// This could also be a variable instead of a function, but some unit tests want to change the ID at
// runtime. Even though that would never happen in a real deployment.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getDeploymentId: null,
    getDeploymentIdQueryOrEmptyString: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getDeploymentId: function getDeploymentId1() {
        return getDeploymentId;
    },
    getDeploymentIdQueryOrEmptyString: function getDeploymentIdQueryOrEmptyString1() {
        return getDeploymentIdQueryOrEmptyString;
    }
});
function getDeploymentId() {
    return "TURBOPACK compile-time value", false;
}
function getDeploymentIdQueryOrEmptyString() {
    var deploymentId = getDeploymentId();
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return '';
} //# sourceMappingURL=deployment-id.js.map
}),
"[project]/node_modules/next/dist/shared/lib/encode-uri-path.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "encodeURIPath", {
    enumerable: true,
    get: function get() {
        return encodeURIPath;
    }
});
function encodeURIPath(file) {
    return file.split('/').map(function(p) {
        return encodeURIComponent(p);
    }).join('/');
} //# sourceMappingURL=encode-uri-path.js.map
}),
"[project]/node_modules/next/dist/shared/lib/modern-browserslist-target.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: This file is JS because it's used by the taskfile-swc.js file, which is JS.
// Keep file changes in sync with the corresponding `.d.ts` files.
/**
 * These are the minimum browser versions that we consider "modern" and thus compile for by default.
 * This list was generated using `pnpm browserslist "baseline widely available"` on 2025-10-01.
 */ var MODERN_BROWSERSLIST_TARGET = [
    'chrome 111',
    'edge 111',
    'firefox 111',
    'safari 16.4'
];
module.exports = MODERN_BROWSERSLIST_TARGET; //# sourceMappingURL=modern-browserslist-target.js.map
}),
"[project]/node_modules/next/dist/shared/lib/entry-constants.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UNDERSCORE_GLOBAL_ERROR_ROUTE: null,
    UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: null,
    UNDERSCORE_NOT_FOUND_ROUTE: null,
    UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UNDERSCORE_GLOBAL_ERROR_ROUTE: function UNDERSCORE_GLOBAL_ERROR_ROUTE1() {
        return UNDERSCORE_GLOBAL_ERROR_ROUTE;
    },
    UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: function UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY1() {
        return UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY;
    },
    UNDERSCORE_NOT_FOUND_ROUTE: function UNDERSCORE_NOT_FOUND_ROUTE1() {
        return UNDERSCORE_NOT_FOUND_ROUTE;
    },
    UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function UNDERSCORE_NOT_FOUND_ROUTE_ENTRY1() {
        return UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;
    }
});
var UNDERSCORE_NOT_FOUND_ROUTE = '/_not-found';
var UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = "".concat(UNDERSCORE_NOT_FOUND_ROUTE, "/page");
var UNDERSCORE_GLOBAL_ERROR_ROUTE = '/_global-error';
var UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY = "".concat(UNDERSCORE_GLOBAL_ERROR_ROUTE, "/page"); //# sourceMappingURL=entry-constants.js.map
}),
"[project]/node_modules/next/dist/shared/lib/constants.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
var _define_property = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_define_property.cjs [client] (ecmascript)");
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [client] (ecmascript)");
var _process_features, _process;
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    APP_CLIENT_INTERNALS: null,
    APP_PATHS_MANIFEST: null,
    APP_PATH_ROUTES_MANIFEST: null,
    AdapterOutputType: null,
    BARREL_OPTIMIZATION_PREFIX: null,
    BLOCKED_PAGES: null,
    BUILD_ID_FILE: null,
    BUILD_MANIFEST: null,
    CLIENT_PUBLIC_FILES_PATH: null,
    CLIENT_REFERENCE_MANIFEST: null,
    CLIENT_STATIC_FILES_PATH: null,
    CLIENT_STATIC_FILES_RUNTIME_MAIN: null,
    CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: null,
    CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: null,
    CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: null,
    CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: null,
    CLIENT_STATIC_FILES_RUNTIME_WEBPACK: null,
    COMPILER_INDEXES: null,
    COMPILER_NAMES: null,
    CONFIG_FILES: null,
    DEFAULT_RUNTIME_WEBPACK: null,
    DEFAULT_SANS_SERIF_FONT: null,
    DEFAULT_SERIF_FONT: null,
    DEV_CLIENT_MIDDLEWARE_MANIFEST: null,
    DEV_CLIENT_PAGES_MANIFEST: null,
    DYNAMIC_CSS_MANIFEST: null,
    EDGE_RUNTIME_WEBPACK: null,
    EDGE_UNSUPPORTED_NODE_APIS: null,
    EXPORT_DETAIL: null,
    EXPORT_MARKER: null,
    FUNCTIONS_CONFIG_MANIFEST: null,
    IMAGES_MANIFEST: null,
    INTERCEPTION_ROUTE_REWRITE_MANIFEST: null,
    MIDDLEWARE_BUILD_MANIFEST: null,
    MIDDLEWARE_MANIFEST: null,
    MIDDLEWARE_REACT_LOADABLE_MANIFEST: null,
    MODERN_BROWSERSLIST_TARGET: null,
    NEXT_BUILTIN_DOCUMENT: null,
    NEXT_FONT_MANIFEST: null,
    PAGES_MANIFEST: null,
    PHASE_ANALYZE: null,
    PHASE_DEVELOPMENT_SERVER: null,
    PHASE_EXPORT: null,
    PHASE_INFO: null,
    PHASE_PRODUCTION_BUILD: null,
    PHASE_PRODUCTION_SERVER: null,
    PHASE_TEST: null,
    PRERENDER_MANIFEST: null,
    REACT_LOADABLE_MANIFEST: null,
    ROUTES_MANIFEST: null,
    RSC_MODULE_TYPES: null,
    SERVER_DIRECTORY: null,
    SERVER_FILES_MANIFEST: null,
    SERVER_PROPS_ID: null,
    SERVER_REFERENCE_MANIFEST: null,
    STATIC_PROPS_ID: null,
    STATIC_STATUS_PAGES: null,
    STRING_LITERAL_DROP_BUNDLE: null,
    SUBRESOURCE_INTEGRITY_MANIFEST: null,
    SYSTEM_ENTRYPOINTS: null,
    TRACE_OUTPUT_VERSION: null,
    TURBOPACK_CLIENT_BUILD_MANIFEST: null,
    TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST: null,
    TURBO_TRACE_DEFAULT_MEMORY_LIMIT: null,
    UNDERSCORE_GLOBAL_ERROR_ROUTE: null,
    UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: null,
    UNDERSCORE_NOT_FOUND_ROUTE: null,
    UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: null,
    WEBPACK_STATS: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    APP_CLIENT_INTERNALS: function APP_CLIENT_INTERNALS1() {
        return APP_CLIENT_INTERNALS;
    },
    APP_PATHS_MANIFEST: function APP_PATHS_MANIFEST1() {
        return APP_PATHS_MANIFEST;
    },
    APP_PATH_ROUTES_MANIFEST: function APP_PATH_ROUTES_MANIFEST1() {
        return APP_PATH_ROUTES_MANIFEST;
    },
    AdapterOutputType: function AdapterOutputType1() {
        return AdapterOutputType;
    },
    BARREL_OPTIMIZATION_PREFIX: function BARREL_OPTIMIZATION_PREFIX1() {
        return BARREL_OPTIMIZATION_PREFIX;
    },
    BLOCKED_PAGES: function BLOCKED_PAGES1() {
        return BLOCKED_PAGES;
    },
    BUILD_ID_FILE: function BUILD_ID_FILE1() {
        return BUILD_ID_FILE;
    },
    BUILD_MANIFEST: function BUILD_MANIFEST1() {
        return BUILD_MANIFEST;
    },
    CLIENT_PUBLIC_FILES_PATH: function CLIENT_PUBLIC_FILES_PATH1() {
        return CLIENT_PUBLIC_FILES_PATH;
    },
    CLIENT_REFERENCE_MANIFEST: function CLIENT_REFERENCE_MANIFEST1() {
        return CLIENT_REFERENCE_MANIFEST;
    },
    CLIENT_STATIC_FILES_PATH: function CLIENT_STATIC_FILES_PATH1() {
        return CLIENT_STATIC_FILES_PATH;
    },
    CLIENT_STATIC_FILES_RUNTIME_MAIN: function CLIENT_STATIC_FILES_RUNTIME_MAIN1() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN;
    },
    CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: function CLIENT_STATIC_FILES_RUNTIME_MAIN_APP1() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN_APP;
    },
    CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: function CLIENT_STATIC_FILES_RUNTIME_POLYFILLS1() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS;
    },
    CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: function CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL1() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL;
    },
    CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: function CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH1() {
        return CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH;
    },
    CLIENT_STATIC_FILES_RUNTIME_WEBPACK: function CLIENT_STATIC_FILES_RUNTIME_WEBPACK1() {
        return CLIENT_STATIC_FILES_RUNTIME_WEBPACK;
    },
    COMPILER_INDEXES: function COMPILER_INDEXES1() {
        return COMPILER_INDEXES;
    },
    COMPILER_NAMES: function COMPILER_NAMES1() {
        return COMPILER_NAMES;
    },
    CONFIG_FILES: function CONFIG_FILES1() {
        return CONFIG_FILES;
    },
    DEFAULT_RUNTIME_WEBPACK: function DEFAULT_RUNTIME_WEBPACK1() {
        return DEFAULT_RUNTIME_WEBPACK;
    },
    DEFAULT_SANS_SERIF_FONT: function DEFAULT_SANS_SERIF_FONT1() {
        return DEFAULT_SANS_SERIF_FONT;
    },
    DEFAULT_SERIF_FONT: function DEFAULT_SERIF_FONT1() {
        return DEFAULT_SERIF_FONT;
    },
    DEV_CLIENT_MIDDLEWARE_MANIFEST: function DEV_CLIENT_MIDDLEWARE_MANIFEST1() {
        return DEV_CLIENT_MIDDLEWARE_MANIFEST;
    },
    DEV_CLIENT_PAGES_MANIFEST: function DEV_CLIENT_PAGES_MANIFEST1() {
        return DEV_CLIENT_PAGES_MANIFEST;
    },
    DYNAMIC_CSS_MANIFEST: function DYNAMIC_CSS_MANIFEST1() {
        return DYNAMIC_CSS_MANIFEST;
    },
    EDGE_RUNTIME_WEBPACK: function EDGE_RUNTIME_WEBPACK1() {
        return EDGE_RUNTIME_WEBPACK;
    },
    EDGE_UNSUPPORTED_NODE_APIS: function EDGE_UNSUPPORTED_NODE_APIS1() {
        return EDGE_UNSUPPORTED_NODE_APIS;
    },
    EXPORT_DETAIL: function EXPORT_DETAIL1() {
        return EXPORT_DETAIL;
    },
    EXPORT_MARKER: function EXPORT_MARKER1() {
        return EXPORT_MARKER;
    },
    FUNCTIONS_CONFIG_MANIFEST: function FUNCTIONS_CONFIG_MANIFEST1() {
        return FUNCTIONS_CONFIG_MANIFEST;
    },
    IMAGES_MANIFEST: function IMAGES_MANIFEST1() {
        return IMAGES_MANIFEST;
    },
    INTERCEPTION_ROUTE_REWRITE_MANIFEST: function INTERCEPTION_ROUTE_REWRITE_MANIFEST1() {
        return INTERCEPTION_ROUTE_REWRITE_MANIFEST;
    },
    MIDDLEWARE_BUILD_MANIFEST: function MIDDLEWARE_BUILD_MANIFEST1() {
        return MIDDLEWARE_BUILD_MANIFEST;
    },
    MIDDLEWARE_MANIFEST: function MIDDLEWARE_MANIFEST1() {
        return MIDDLEWARE_MANIFEST;
    },
    MIDDLEWARE_REACT_LOADABLE_MANIFEST: function MIDDLEWARE_REACT_LOADABLE_MANIFEST1() {
        return MIDDLEWARE_REACT_LOADABLE_MANIFEST;
    },
    MODERN_BROWSERSLIST_TARGET: function MODERN_BROWSERSLIST_TARGET() {
        return _modernbrowserslisttarget.default;
    },
    NEXT_BUILTIN_DOCUMENT: function NEXT_BUILTIN_DOCUMENT1() {
        return NEXT_BUILTIN_DOCUMENT;
    },
    NEXT_FONT_MANIFEST: function NEXT_FONT_MANIFEST1() {
        return NEXT_FONT_MANIFEST;
    },
    PAGES_MANIFEST: function PAGES_MANIFEST1() {
        return PAGES_MANIFEST;
    },
    PHASE_ANALYZE: function PHASE_ANALYZE1() {
        return PHASE_ANALYZE;
    },
    PHASE_DEVELOPMENT_SERVER: function PHASE_DEVELOPMENT_SERVER1() {
        return PHASE_DEVELOPMENT_SERVER;
    },
    PHASE_EXPORT: function PHASE_EXPORT1() {
        return PHASE_EXPORT;
    },
    PHASE_INFO: function PHASE_INFO1() {
        return PHASE_INFO;
    },
    PHASE_PRODUCTION_BUILD: function PHASE_PRODUCTION_BUILD1() {
        return PHASE_PRODUCTION_BUILD;
    },
    PHASE_PRODUCTION_SERVER: function PHASE_PRODUCTION_SERVER1() {
        return PHASE_PRODUCTION_SERVER;
    },
    PHASE_TEST: function PHASE_TEST1() {
        return PHASE_TEST;
    },
    PRERENDER_MANIFEST: function PRERENDER_MANIFEST1() {
        return PRERENDER_MANIFEST;
    },
    REACT_LOADABLE_MANIFEST: function REACT_LOADABLE_MANIFEST1() {
        return REACT_LOADABLE_MANIFEST;
    },
    ROUTES_MANIFEST: function ROUTES_MANIFEST1() {
        return ROUTES_MANIFEST;
    },
    RSC_MODULE_TYPES: function RSC_MODULE_TYPES1() {
        return RSC_MODULE_TYPES;
    },
    SERVER_DIRECTORY: function SERVER_DIRECTORY1() {
        return SERVER_DIRECTORY;
    },
    SERVER_FILES_MANIFEST: function SERVER_FILES_MANIFEST1() {
        return SERVER_FILES_MANIFEST;
    },
    SERVER_PROPS_ID: function SERVER_PROPS_ID1() {
        return SERVER_PROPS_ID;
    },
    SERVER_REFERENCE_MANIFEST: function SERVER_REFERENCE_MANIFEST1() {
        return SERVER_REFERENCE_MANIFEST;
    },
    STATIC_PROPS_ID: function STATIC_PROPS_ID1() {
        return STATIC_PROPS_ID;
    },
    STATIC_STATUS_PAGES: function STATIC_STATUS_PAGES1() {
        return STATIC_STATUS_PAGES;
    },
    STRING_LITERAL_DROP_BUNDLE: function STRING_LITERAL_DROP_BUNDLE1() {
        return STRING_LITERAL_DROP_BUNDLE;
    },
    SUBRESOURCE_INTEGRITY_MANIFEST: function SUBRESOURCE_INTEGRITY_MANIFEST1() {
        return SUBRESOURCE_INTEGRITY_MANIFEST;
    },
    SYSTEM_ENTRYPOINTS: function SYSTEM_ENTRYPOINTS1() {
        return SYSTEM_ENTRYPOINTS;
    },
    TRACE_OUTPUT_VERSION: function TRACE_OUTPUT_VERSION1() {
        return TRACE_OUTPUT_VERSION;
    },
    TURBOPACK_CLIENT_BUILD_MANIFEST: function TURBOPACK_CLIENT_BUILD_MANIFEST1() {
        return TURBOPACK_CLIENT_BUILD_MANIFEST;
    },
    TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST: function TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST1() {
        return TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST;
    },
    TURBO_TRACE_DEFAULT_MEMORY_LIMIT: function TURBO_TRACE_DEFAULT_MEMORY_LIMIT1() {
        return TURBO_TRACE_DEFAULT_MEMORY_LIMIT;
    },
    UNDERSCORE_GLOBAL_ERROR_ROUTE: function UNDERSCORE_GLOBAL_ERROR_ROUTE() {
        return _entryconstants.UNDERSCORE_GLOBAL_ERROR_ROUTE;
    },
    UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: function UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY() {
        return _entryconstants.UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY;
    },
    UNDERSCORE_NOT_FOUND_ROUTE: function UNDERSCORE_NOT_FOUND_ROUTE() {
        return _entryconstants.UNDERSCORE_NOT_FOUND_ROUTE;
    },
    UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function UNDERSCORE_NOT_FOUND_ROUTE_ENTRY() {
        return _entryconstants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;
    },
    WEBPACK_STATS: function WEBPACK_STATS1() {
        return WEBPACK_STATS;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _modernbrowserslisttarget = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/modern-browserslist-target.js [client] (ecmascript)"));
var _entryconstants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/entry-constants.js [client] (ecmascript)");
var COMPILER_NAMES = {
    client: 'client',
    server: 'server',
    edgeServer: 'edge-server'
};
var _obj;
var COMPILER_INDEXES = (_obj = {}, _define_property._(_obj, COMPILER_NAMES.client, 0), _define_property._(_obj, COMPILER_NAMES.server, 1), _define_property._(_obj, COMPILER_NAMES.edgeServer, 2), _obj);
var AdapterOutputType = /*#__PURE__*/ function(AdapterOutputType) {
    /**
   * `PAGES` represents all the React pages that are under `pages/`.
   */ AdapterOutputType["PAGES"] = "PAGES";
    /**
   * `PAGES_API` represents all the API routes under `pages/api/`.
   */ AdapterOutputType["PAGES_API"] = "PAGES_API";
    /**
   * `APP_PAGE` represents all the React pages that are under `app/` with the
   * filename of `page.{j,t}s{,x}`.
   */ AdapterOutputType["APP_PAGE"] = "APP_PAGE";
    /**
   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the
   * filename of `route.{j,t}s{,x}`.
   */ AdapterOutputType["APP_ROUTE"] = "APP_ROUTE";
    /**
   * `PRERENDER` represents an ISR enabled route that might
   * have a seeded cache entry or fallback generated during build
   */ AdapterOutputType["PRERENDER"] = "PRERENDER";
    /**
   * `STATIC_FILE` represents a static file (ie /_next/static)
   */ AdapterOutputType["STATIC_FILE"] = "STATIC_FILE";
    /**
   * `MIDDLEWARE` represents the middleware output if present
   */ AdapterOutputType["MIDDLEWARE"] = "MIDDLEWARE";
    return AdapterOutputType;
}({});
var PHASE_EXPORT = 'phase-export';
var PHASE_ANALYZE = 'phase-analyze';
var PHASE_PRODUCTION_BUILD = 'phase-production-build';
var PHASE_PRODUCTION_SERVER = 'phase-production-server';
var PHASE_DEVELOPMENT_SERVER = 'phase-development-server';
var PHASE_TEST = 'phase-test';
var PHASE_INFO = 'phase-info';
var PAGES_MANIFEST = 'pages-manifest.json';
var WEBPACK_STATS = 'webpack-stats.json';
var APP_PATHS_MANIFEST = 'app-paths-manifest.json';
var APP_PATH_ROUTES_MANIFEST = 'app-path-routes-manifest.json';
var BUILD_MANIFEST = 'build-manifest.json';
var FUNCTIONS_CONFIG_MANIFEST = 'functions-config-manifest.json';
var SUBRESOURCE_INTEGRITY_MANIFEST = 'subresource-integrity-manifest';
var NEXT_FONT_MANIFEST = 'next-font-manifest';
var EXPORT_MARKER = 'export-marker.json';
var EXPORT_DETAIL = 'export-detail.json';
var PRERENDER_MANIFEST = 'prerender-manifest.json';
var ROUTES_MANIFEST = 'routes-manifest.json';
var IMAGES_MANIFEST = 'images-manifest.json';
var SERVER_FILES_MANIFEST = 'required-server-files';
var DEV_CLIENT_PAGES_MANIFEST = '_devPagesManifest.json';
var MIDDLEWARE_MANIFEST = 'middleware-manifest.json';
var TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST = '_clientMiddlewareManifest.json';
var TURBOPACK_CLIENT_BUILD_MANIFEST = 'client-build-manifest.json';
var DEV_CLIENT_MIDDLEWARE_MANIFEST = '_devMiddlewareManifest.json';
var REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json';
var SERVER_DIRECTORY = 'server';
var CONFIG_FILES = [
    'next.config.js',
    'next.config.mjs',
    'next.config.ts'
].concat(// process.features can be undefined on Edge runtime
// TODO: Remove `as any` once we bump @types/node to v22.10.0+
_to_consumable_array._(((_process = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) === null || _process === void 0 ? void 0 : (_process_features = _process.features) === null || _process_features === void 0 ? void 0 : _process_features.typescript) ? [
    'next.config.mts'
] : []));
var BUILD_ID_FILE = 'BUILD_ID';
var BLOCKED_PAGES = [
    '/_document',
    '/_app',
    '/_error'
];
var CLIENT_PUBLIC_FILES_PATH = 'public';
var CLIENT_STATIC_FILES_PATH = 'static';
var STRING_LITERAL_DROP_BUNDLE = '__NEXT_DROP_CLIENT_FILE__';
var NEXT_BUILTIN_DOCUMENT = '__NEXT_BUILTIN_DOCUMENT__';
var BARREL_OPTIMIZATION_PREFIX = '__barrel_optimize__';
var CLIENT_REFERENCE_MANIFEST = 'client-reference-manifest';
var SERVER_REFERENCE_MANIFEST = 'server-reference-manifest';
var MIDDLEWARE_BUILD_MANIFEST = 'middleware-build-manifest';
var MIDDLEWARE_REACT_LOADABLE_MANIFEST = 'middleware-react-loadable-manifest';
var INTERCEPTION_ROUTE_REWRITE_MANIFEST = 'interception-route-rewrite-manifest';
var DYNAMIC_CSS_MANIFEST = 'dynamic-css-manifest';
var CLIENT_STATIC_FILES_RUNTIME_MAIN = "main";
var CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = "".concat(CLIENT_STATIC_FILES_RUNTIME_MAIN, "-app");
var APP_CLIENT_INTERNALS = 'app-pages-internals';
var CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = "react-refresh";
var CLIENT_STATIC_FILES_RUNTIME_WEBPACK = "webpack";
var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = 'polyfills';
var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(CLIENT_STATIC_FILES_RUNTIME_POLYFILLS);
var DEFAULT_RUNTIME_WEBPACK = 'webpack-runtime';
var EDGE_RUNTIME_WEBPACK = 'edge-runtime-webpack';
var STATIC_PROPS_ID = '__N_SSG';
var SERVER_PROPS_ID = '__N_SSP';
var DEFAULT_SERIF_FONT = {
    name: 'Times New Roman',
    xAvgCharWidth: 821,
    azAvgWidth: 854.3953488372093,
    unitsPerEm: 2048
};
var DEFAULT_SANS_SERIF_FONT = {
    name: 'Arial',
    xAvgCharWidth: 904,
    azAvgWidth: 934.5116279069767,
    unitsPerEm: 2048
};
var STATIC_STATUS_PAGES = [
    '/500'
];
var TRACE_OUTPUT_VERSION = 1;
var TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6000;
var RSC_MODULE_TYPES = {
    client: 'client',
    server: 'server'
};
var EDGE_UNSUPPORTED_NODE_APIS = [
    'clearImmediate',
    'setImmediate',
    'BroadcastChannel',
    'ByteLengthQueuingStrategy',
    'CompressionStream',
    'CountQueuingStrategy',
    'DecompressionStream',
    'DomException',
    'MessageChannel',
    'MessageEvent',
    'MessagePort',
    'ReadableByteStreamController',
    'ReadableStreamBYOBRequest',
    'ReadableStreamDefaultController',
    'TransformStreamDefaultController',
    'WritableStreamDefaultController'
];
var SYSTEM_ENTRYPOINTS = new Set([
    CLIENT_STATIC_FILES_RUNTIME_MAIN,
    CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,
    CLIENT_STATIC_FILES_RUNTIME_MAIN_APP
]);
if ((typeof exports.default === 'function' || _type_of._(exports.default) === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/shared/lib/bloom-filter.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
// minimal implementation MurmurHash2 hash function
"use strict";
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _create_class = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_create_class.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BloomFilter", {
    enumerable: true,
    get: function get() {
        return BloomFilter;
    }
});
function murmurhash2(str) {
    var h = 0;
    for(var i = 0; i < str.length; i++){
        var c = str.charCodeAt(i);
        h = Math.imul(h ^ c, 0x5bd1e995);
        h ^= h >>> 13;
        h = Math.imul(h, 0x5bd1e995);
    }
    return h >>> 0;
}
// default to 0.01% error rate as the filter compresses very well
var DEFAULT_ERROR_RATE = 0.0001;
var BloomFilter = /*#__PURE__*/ function() {
    function BloomFilter(numItems) {
        var errorRate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_ERROR_RATE;
        _class_call_check._(this, BloomFilter);
        this.numItems = numItems;
        this.errorRate = errorRate;
        this.numBits = Math.ceil(-(numItems * Math.log(errorRate)) / (Math.log(2) * Math.log(2)));
        this.numHashes = Math.ceil(this.numBits / numItems * Math.log(2));
        this.bitArray = new Array(this.numBits).fill(0);
    }
    _create_class._(BloomFilter, [
        {
            key: "export",
            value: function _export() {
                var data = {
                    numItems: this.numItems,
                    errorRate: this.errorRate,
                    numBits: this.numBits,
                    numHashes: this.numHashes,
                    bitArray: this.bitArray
                };
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                {
                    var filterData;
                    var gzipSize;
                /*TURBOPACK member replacement*/ }
                return data;
            }
        },
        {
            key: "import",
            value: function _import(data) {
                this.numItems = data.numItems;
                this.errorRate = data.errorRate;
                this.numBits = data.numBits;
                this.numHashes = data.numHashes;
                this.bitArray = data.bitArray;
            }
        },
        {
            key: "add",
            value: function add(item) {
                var _this = this;
                var hashValues = this.getHashValues(item);
                hashValues.forEach(function(hash) {
                    _this.bitArray[hash] = 1;
                });
            }
        },
        {
            key: "contains",
            value: function contains(item) {
                var _this = this;
                var hashValues = this.getHashValues(item);
                return hashValues.every(function(hash) {
                    return _this.bitArray[hash];
                });
            }
        },
        {
            key: "getHashValues",
            value: function getHashValues(item) {
                var hashValues = [];
                for(var i = 1; i <= this.numHashes; i++){
                    var hash = murmurhash2("".concat(item).concat(i)) % this.numBits;
                    hashValues.push(hash);
                }
                return hashValues;
            }
        }
    ], [
        {
            key: "from",
            value: function from(items) {
                var errorRate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_ERROR_RATE;
                var filter = new BloomFilter(items.length, errorRate);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var item = _step.value;
                        filter.add(item);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return filter;
            }
        }
    ]);
    return BloomFilter;
} //# sourceMappingURL=bloom-filter.js.map
();
}),
"[project]/node_modules/next/dist/shared/lib/is-plain-object.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getObjectClassLabel: null,
    isPlainObject: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getObjectClassLabel: function getObjectClassLabel1() {
        return getObjectClassLabel;
    },
    isPlainObject: function isPlainObject1() {
        return isPlainObject;
    }
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    var prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
} //# sourceMappingURL=is-plain-object.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _create_class = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_create_class.cjs [client] (ecmascript)");
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getSortedRouteObjects: null,
    getSortedRoutes: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getSortedRouteObjects: function getSortedRouteObjects1() {
        return getSortedRouteObjects;
    },
    getSortedRoutes: function getSortedRoutes1() {
        return getSortedRoutes;
    }
});
var UrlNode = /*#__PURE__*/ function() {
    function UrlNode() {
        _class_call_check._(this, UrlNode);
        this.placeholder = true;
        this.children = new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
    }
    _create_class._(UrlNode, [
        {
            key: "insert",
            value: function insert(urlPath) {
                this._insert(urlPath.split('/').filter(Boolean), [], false);
            }
        },
        {
            key: "smoosh",
            value: function smoosh() {
                return this._smoosh();
            }
        },
        {
            key: "_smoosh",
            value: function _smoosh() {
                var _this = this;
                var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '/';
                var childrenPaths = _to_consumable_array._(this.children.keys()).sort();
                if (this.slugName !== null) {
                    childrenPaths.splice(childrenPaths.indexOf('[]'), 1);
                }
                if (this.restSlugName !== null) {
                    childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);
                }
                if (this.optionalRestSlugName !== null) {
                    childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);
                }
                var routes = childrenPaths.map(function(c) {
                    return _this.children.get(c)._smoosh("".concat(prefix).concat(c, "/"));
                }).reduce(function(prev, curr) {
                    return _to_consumable_array._(prev).concat(_to_consumable_array._(curr));
                }, []);
                if (this.slugName !== null) {
                    var _routes;
                    (_routes = routes).push.apply(_routes, _to_consumable_array._(this.children.get('[]')._smoosh("".concat(prefix, "[").concat(this.slugName, "]/"))));
                }
                if (!this.placeholder) {
                    var r = prefix === '/' ? '/' : prefix.slice(0, -1);
                    if (this.optionalRestSlugName != null) {
                        throw Object.defineProperty(new Error('You cannot define a route with the same specificity as a optional catch-all route ("'.concat(r, '" and "').concat(r, "[[...").concat(this.optionalRestSlugName, ']]").')), "__NEXT_ERROR_CODE", {
                            value: "E458",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    routes.unshift(r);
                }
                if (this.restSlugName !== null) {
                    var _routes1;
                    (_routes1 = routes).push.apply(_routes1, _to_consumable_array._(this.children.get('[...]')._smoosh("".concat(prefix, "[...").concat(this.restSlugName, "]/"))));
                }
                if (this.optionalRestSlugName !== null) {
                    var _routes2;
                    (_routes2 = routes).push.apply(_routes2, _to_consumable_array._(this.children.get('[[...]]')._smoosh("".concat(prefix, "[[...").concat(this.optionalRestSlugName, "]]/"))));
                }
                return routes;
            }
        },
        {
            key: "_insert",
            value: function _insert(urlPaths, slugNames, isCatchAll) {
                if (urlPaths.length === 0) {
                    this.placeholder = false;
                    return;
                }
                if (isCatchAll) {
                    throw Object.defineProperty(new Error("Catch-all must be the last part of the URL."), "__NEXT_ERROR_CODE", {
                        value: "E392",
                        enumerable: false,
                        configurable: true
                    });
                }
                // The next segment in the urlPaths list
                var nextSegment = urlPaths[0];
                // Check if the segment matches `[something]`
                if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {
                    var handleSlug = function handleSlug(previousSlug, nextSlug) {
                        if (previousSlug !== null) {
                            // If the specific segment already has a slug but the slug is not `something`
                            // This prevents collisions like:
                            // pages/[post]/index.js
                            // pages/[id]/index.js
                            // Because currently multiple dynamic params on the same segment level are not supported
                            if (previousSlug !== nextSlug) {
                                // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.
                                throw Object.defineProperty(new Error("You cannot use different slug names for the same dynamic path ('".concat(previousSlug, "' !== '").concat(nextSlug, "').")), "__NEXT_ERROR_CODE", {
                                    value: "E337",
                                    enumerable: false,
                                    configurable: true
                                });
                            }
                        }
                        slugNames.forEach(function(slug) {
                            if (slug === nextSlug) {
                                throw Object.defineProperty(new Error('You cannot have the same slug name "'.concat(nextSlug, '" repeat within a single dynamic path')), "__NEXT_ERROR_CODE", {
                                    value: "E247",
                                    enumerable: false,
                                    configurable: true
                                });
                            }
                            if (slug.replace(/\W/g, '') === nextSegment.replace(/\W/g, '')) {
                                throw Object.defineProperty(new Error('You cannot have the slug names "'.concat(slug, '" and "').concat(nextSlug, '" differ only by non-word symbols within a single dynamic path')), "__NEXT_ERROR_CODE", {
                                    value: "E499",
                                    enumerable: false,
                                    configurable: true
                                });
                            }
                        });
                        slugNames.push(nextSlug);
                    };
                    // Strip `[` and `]`, leaving only `something`
                    var segmentName = nextSegment.slice(1, -1);
                    var isOptional = false;
                    if (segmentName.startsWith('[') && segmentName.endsWith(']')) {
                        // Strip optional `[` and `]`, leaving only `something`
                        segmentName = segmentName.slice(1, -1);
                        isOptional = true;
                    }
                    if (segmentName.startsWith('')) {
                        throw Object.defineProperty(new Error("Detected a three-dot character ('') at ('".concat(segmentName, "'). Did you mean ('...')?")), "__NEXT_ERROR_CODE", {
                            value: "E147",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    if (segmentName.startsWith('...')) {
                        // Strip `...`, leaving only `something`
                        segmentName = segmentName.substring(3);
                        isCatchAll = true;
                    }
                    if (segmentName.startsWith('[') || segmentName.endsWith(']')) {
                        throw Object.defineProperty(new Error("Segment names may not start or end with extra brackets ('".concat(segmentName, "').")), "__NEXT_ERROR_CODE", {
                            value: "E421",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    if (segmentName.startsWith('.')) {
                        throw Object.defineProperty(new Error("Segment names may not start with erroneous periods ('".concat(segmentName, "').")), "__NEXT_ERROR_CODE", {
                            value: "E288",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    if (isCatchAll) {
                        if (isOptional) {
                            if (this.restSlugName != null) {
                                throw Object.defineProperty(new Error('You cannot use both an required and optional catch-all route at the same level ("[...'.concat(this.restSlugName, ']" and "').concat(urlPaths[0], '" ).')), "__NEXT_ERROR_CODE", {
                                    value: "E299",
                                    enumerable: false,
                                    configurable: true
                                });
                            }
                            handleSlug(this.optionalRestSlugName, segmentName);
                            // slugName is kept as it can only be one particular slugName
                            this.optionalRestSlugName = segmentName;
                            // nextSegment is overwritten to [[...]] so that it can later be sorted specifically
                            nextSegment = '[[...]]';
                        } else {
                            if (this.optionalRestSlugName != null) {
                                throw Object.defineProperty(new Error('You cannot use both an optional and required catch-all route at the same level ("[[...'.concat(this.optionalRestSlugName, ']]" and "').concat(urlPaths[0], '").')), "__NEXT_ERROR_CODE", {
                                    value: "E300",
                                    enumerable: false,
                                    configurable: true
                                });
                            }
                            handleSlug(this.restSlugName, segmentName);
                            // slugName is kept as it can only be one particular slugName
                            this.restSlugName = segmentName;
                            // nextSegment is overwritten to [...] so that it can later be sorted specifically
                            nextSegment = '[...]';
                        }
                    } else {
                        if (isOptional) {
                            throw Object.defineProperty(new Error('Optional route parameters are not yet supported ("'.concat(urlPaths[0], '").')), "__NEXT_ERROR_CODE", {
                                value: "E435",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        handleSlug(this.slugName, segmentName);
                        // slugName is kept as it can only be one particular slugName
                        this.slugName = segmentName;
                        // nextSegment is overwritten to [] so that it can later be sorted specifically
                        nextSegment = '[]';
                    }
                }
                // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode
                if (!this.children.has(nextSegment)) {
                    this.children.set(nextSegment, new UrlNode());
                }
                this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
            }
        }
    ]);
    return UrlNode;
}();
function getSortedRoutes(normalizedPages) {
    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment
    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js
    // Only 1 dynamic segment per nesting level
    // So in the case that is test/integration/dynamic-routing it'll be this:
    // pages/[post]/comments.js
    // pages/blog/[post]/comment/[id].js
    // Both are fine because `pages/[post]` and `pages/blog` are on the same level
    // So in this case `UrlNode` created here has `this.slugName === 'post'`
    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities
    // Instead what has to be passed through is the upwards path's dynamic names
    var root = new UrlNode();
    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels
    normalizedPages.forEach(function(pagePath) {
        return root.insert(pagePath);
    });
    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority
    return root.smoosh();
}
function getSortedRouteObjects(objects, getter) {
    // We're assuming here that all the pathnames are unique, that way we can
    // sort the list and use the index as the key.
    var indexes = {};
    var pathnames = [];
    for(var i = 0; i < objects.length; i++){
        var pathname = getter(objects[i]);
        indexes[pathname] = i;
        pathnames[i] = pathname;
    }
    // Sort the pathnames.
    var sorted = getSortedRoutes(pathnames);
    // Map the sorted pathnames back to the original objects using the new sorted
    // index.
    return sorted.map(function(pathname) {
        return objects[indexes[pathname]];
    });
} //# sourceMappingURL=sorted-routes.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getSortedRouteObjects: null,
    getSortedRoutes: null,
    isDynamicRoute: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getSortedRouteObjects: function getSortedRouteObjects() {
        return _sortedroutes.getSortedRouteObjects;
    },
    getSortedRoutes: function getSortedRoutes() {
        return _sortedroutes.getSortedRoutes;
    },
    isDynamicRoute: function isDynamicRoute() {
        return _isdynamic.isDynamicRoute;
    }
});
var _sortedroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js [client] (ecmascript)");
var _isdynamic = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js [client] (ecmascript)"); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * For a given page path, this function ensures that there is no backslash
 * escaping slashes in the path. Example:
 *  - `foo\/bar\/baz` -> `foo/bar/baz`
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizePathSep", {
    enumerable: true,
    get: function get() {
        return normalizePathSep;
    }
});
function normalizePathSep(path) {
    return path.replace(/\\/g, '/');
} //# sourceMappingURL=normalize-path-sep.js.map
}),
"[project]/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "denormalizePagePath", {
    enumerable: true,
    get: function get() {
        return denormalizePagePath;
    }
});
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [client] (ecmascript)");
var _normalizepathsep = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js [client] (ecmascript)");
function denormalizePagePath(page) {
    var _page = (0, _normalizepathsep.normalizePathSep)(page);
    return _page.startsWith('/index/') && !(0, _utils.isDynamicRoute)(_page) ? _page.slice(6) : _page !== '/index' ? _page : '/';
} //# sourceMappingURL=denormalize-page-path.js.map
}),
"[project]/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizeLocalePath", {
    enumerable: true,
    get: function get() {
        return normalizeLocalePath;
    }
});
/**
 * A cache of lowercased locales for each list of locales. This is stored as a
 * WeakMap so if the locales are garbage collected, the cache entry will be
 * removed as well.
 */ var cache = new WeakMap();
function normalizeLocalePath(pathname, locales) {
    // If locales is undefined, return the pathname as is.
    if (!locales) return {
        pathname: pathname
    };
    // Get the cached lowercased locales or create a new cache entry.
    var lowercasedLocales = cache.get(locales);
    if (!lowercasedLocales) {
        lowercasedLocales = locales.map(function(locale) {
            return locale.toLowerCase();
        });
        cache.set(locales, lowercasedLocales);
    }
    var detectedLocale;
    // The first segment will be empty, because it has a leading `/`. If
    // there is no further segment, there is no locale (or it's the default).
    var segments = pathname.split('/', 2);
    // If there's no second segment (ie, the pathname is just `/`), there's no
    // locale.
    if (!segments[1]) return {
        pathname: pathname
    };
    // The second segment will contain the locale part if any.
    var segment = segments[1].toLowerCase();
    // See if the segment matches one of the locales. If it doesn't, there is
    // no locale (or it's the default).
    var index = lowercasedLocales.indexOf(segment);
    if (index < 0) return {
        pathname: pathname
    };
    // Return the case-sensitive locale.
    detectedLocale = locales[index];
    // Remove the `/${locale}` part of the pathname.
    pathname = pathname.slice(detectedLocale.length + 1) || '/';
    return {
        pathname: pathname,
        detectedLocale: detectedLocale
    };
} //# sourceMappingURL=normalize-locale-path.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function formatUrl1() {
        return formatUrl;
    },
    formatWithValidation: function formatWithValidation1() {
        return formatWithValidation;
    },
    urlObjectKeys: function urlObjectKeys1() {
        return urlObjectKeys;
    }
});
var _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [client] (ecmascript)");
var _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [client] (ecmascript)"));
var slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    var auth = urlObj.auth, hostname = urlObj.hostname;
    var protocol = urlObj.protocol || '';
    var pathname = urlObj.pathname || '';
    var hash = urlObj.hash || '';
    var query = urlObj.query || '';
    var host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && (typeof query === "undefined" ? "undefined" : _type_of._(query)) === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    var search = urlObj.search || query && "?".concat(query) || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}
var urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && (typeof url === "undefined" ? "undefined" : _type_of._(url)) === 'object') {
            Object.keys(url).forEach(function(key) {
                if (!urlObjectKeys.includes(key)) {
                    console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pathHasPrefix", {
    enumerable: true,
    get: function get() {
        return pathHasPrefix;
    }
});
var _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [client] (ecmascript)");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    var pathname = (0, _parsepath.parsePath)(path).pathname;
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/omit.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "omit", {
    enumerable: true,
    get: function get() {
        return omit;
    }
});
function omit(object, keys) {
    var omitted = {};
    Object.keys(object).forEach(function(key) {
        if (!keys.includes(key)) {
            omitted[key] = object[key];
        }
    });
    return omitted;
} //# sourceMappingURL=omit.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function get() {
        return isLocalURL;
    }
});
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [client] (ecmascript)");
var _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [client] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        var locationOrigin = (0, _utils.getLocationOrigin)();
        var resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removePathPrefix", {
    enumerable: true,
    get: function get() {
        return removePathPrefix;
    }
});
var _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [client] (ecmascript)");
function removePathPrefix(path, prefix) {
    // If the path doesn't start with the prefix we can return it as is. This
    // protects us from situations where the prefix is a substring of the path
    // prefix such as:
    //
    // For prefix: /blog
    //
    //   /blog -> true
    //   /blog/ -> true
    //   /blog/1 -> true
    //   /blogging -> false
    //   /blogging/ -> false
    //   /blogging/1 -> false
    if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
    }
    // Remove the prefix from the path via slicing.
    var withoutPrefix = path.slice(prefix.length);
    // If the path without the prefix starts with a `/` we can return it as is.
    if (withoutPrefix.startsWith('/')) {
        return withoutPrefix;
    }
    // If the path without the prefix doesn't start with a `/` we need to add it
    // back to the path to make sure it's a valid path.
    return "/".concat(withoutPrefix);
} //# sourceMappingURL=remove-path-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextPathnameInfo", {
    enumerable: true,
    get: function get() {
        return getNextPathnameInfo;
    }
});
var _normalizelocalepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js [client] (ecmascript)");
var _removepathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js [client] (ecmascript)");
var _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [client] (ecmascript)");
function getNextPathnameInfo(pathname, options) {
    var _options_nextConfig;
    var _ref = (_options_nextConfig = options.nextConfig) !== null && _options_nextConfig !== void 0 ? _options_nextConfig : {}, basePath = _ref.basePath, i18n = _ref.i18n, trailingSlash = _ref.trailingSlash;
    var info = {
        pathname: pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash
    };
    if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
    }
    var pathnameNoDataPrefix = info.pathname;
    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        var paths = info.pathname.replace(/^\/_next\/data\//, '').replace(/\.json$/, '').split('/');
        var buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== 'index' ? "/".concat(paths.slice(1).join('/')) : '/';
        // update pathname with normalized if enabled although
        // we use normalized to populate locale info still
        if (options.parseData === true) {
            info.pathname = pathnameNoDataPrefix;
        }
    }
    // If provided, use the locale route normalizer to detect the locale instead
    // of the function below.
    if (i18n) {
        var result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) !== null && _result_pathname !== void 0 ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);
            if (result.detectedLocale) {
                info.locale = result.detectedLocale;
            }
        }
    }
    return info;
} //# sourceMappingURL=get-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathSuffix", {
    enumerable: true,
    get: function get() {
        return addPathSuffix;
    }
});
var _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [client] (ecmascript)");
function addPathSuffix(path, suffix) {
    if (!path.startsWith('/') || !suffix) {
        return path;
    }
    var _ref = (0, _parsepath.parsePath)(path), pathname = _ref.pathname, query = _ref.query, hash = _ref.hash;
    return "".concat(pathname).concat(suffix).concat(query).concat(hash);
} //# sourceMappingURL=add-path-suffix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-locale.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addLocale", {
    enumerable: true,
    get: function get() {
        return addLocale;
    }
});
var _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [client] (ecmascript)");
var _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [client] (ecmascript)");
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    // If no locale was given or the locale is the default locale, we don't need
    // to prefix the path.
    if (!locale || locale === defaultLocale) return path;
    var lower = path.toLowerCase();
    // If the path is an API path or the path already has the locale prefix, we
    // don't need to prefix the path.
    if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, '/api')) return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/".concat(locale.toLowerCase()))) return path;
    }
    // Add the locale prefix to the path.
    return (0, _addpathprefix.addPathPrefix)(path, "/".concat(locale));
} //# sourceMappingURL=add-locale.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "formatNextPathnameInfo", {
    enumerable: true,
    get: function get() {
        return formatNextPathnameInfo;
    }
});
var _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [client] (ecmascript)");
var _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [client] (ecmascript)");
var _addpathsuffix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js [client] (ecmascript)");
var _addlocale = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-locale.js [client] (ecmascript)");
function formatNextPathnameInfo(info) {
    var pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
    if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/".concat(info.buildId)), info.pathname === '/' ? 'index.json' : '.json');
    }
    pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, _addpathsuffix.addPathSuffix)(pathname, '/') : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
} //# sourceMappingURL=format-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/compare-states.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "compareRouterStates", {
    enumerable: true,
    get: function get() {
        return compareRouterStates;
    }
});
function compareRouterStates(a, b) {
    var stateKeys = Object.keys(a);
    if (stateKeys.length !== Object.keys(b).length) return false;
    for(var i = stateKeys.length; i--;){
        var key = stateKeys[i];
        if (key === 'query') {
            var queryKeys = Object.keys(a.query);
            if (queryKeys.length !== Object.keys(b.query).length) {
                return false;
            }
            for(var j = queryKeys.length; j--;){
                var queryKey = queryKeys[j];
                if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {
                    return false;
                }
            }
        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=compare-states.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
// Note: The pattern [\w-]+-Google captures all Google crawlers with "-Google" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)
// as well as crawlers starting with "Google-" (e.g., Google-PageRenderer, Google-InspectionTool)
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HTML_LIMITED_BOT_UA_RE", {
    enumerable: true,
    get: function get() {
        return HTML_LIMITED_BOT_UA_RE;
    }
});
var HTML_LIMITED_BOT_UA_RE = /[\w-]+-Google|Google-[\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i; //# sourceMappingURL=html-bots.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTML_LIMITED_BOT_UA_RE: null,
    HTML_LIMITED_BOT_UA_RE_STRING: null,
    getBotType: null,
    isBot: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTML_LIMITED_BOT_UA_RE: function HTML_LIMITED_BOT_UA_RE() {
        return _htmlbots.HTML_LIMITED_BOT_UA_RE;
    },
    HTML_LIMITED_BOT_UA_RE_STRING: function HTML_LIMITED_BOT_UA_RE_STRING1() {
        return HTML_LIMITED_BOT_UA_RE_STRING;
    },
    getBotType: function getBotType1() {
        return getBotType;
    },
    isBot: function isBot1() {
        return isBot;
    }
});
var _htmlbots = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [client] (ecmascript)");
// Bot crawler that will spin up a headless browser and execute JS.
// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
// This regex specifically matches "Googlebot" but NOT "Mediapartners-Google", "AdsBot-Google", etc.
var HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;
var HTML_LIMITED_BOT_UA_RE_STRING = _htmlbots.HTML_LIMITED_BOT_UA_RE.source;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return _htmlbots.HTML_LIMITED_BOT_UA_RE.test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/router.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
var _async_to_generator = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_async_to_generator.cjs [client] (ecmascript)");
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _create_class = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_create_class.cjs [client] (ecmascript)");
var _object_spread = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread.cjs [client] (ecmascript)");
var _object_spread_props = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread_props.cjs [client] (ecmascript)");
var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
var _ts_generator = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_ts_generator.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createKey: null,
    default: null,
    matchesMiddleware: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createKey: function createKey1() {
        return createKey;
    },
    default: function _default() {
        return Router;
    },
    matchesMiddleware: function matchesMiddleware1() {
        return matchesMiddleware;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [client] (ecmascript)");
var _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [client] (ecmascript)");
var _routeloader = __turbopack_context__.r("[project]/node_modules/next/dist/client/route-loader.js [client] (ecmascript)");
var _script = __turbopack_context__.r("[project]/node_modules/next/dist/client/script.js [client] (ecmascript)");
var _iserror = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [client] (ecmascript)"));
var _denormalizepagepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js [client] (ecmascript)");
var _normalizelocalepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js [client] (ecmascript)");
var _mitt = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/mitt.js [client] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [client] (ecmascript)");
var _isdynamic = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js [client] (ecmascript)");
var _parserelativeurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js [client] (ecmascript)");
var _routematcher = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-matcher.js [client] (ecmascript)");
var _routeregex = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-regex.js [client] (ecmascript)");
var _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [client] (ecmascript)");
var _detectdomainlocale = __turbopack_context__.r("[project]/node_modules/next/dist/client/detect-domain-locale.js [client] (ecmascript)");
var _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [client] (ecmascript)");
var _addlocale = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-locale.js [client] (ecmascript)");
var _removelocale = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-locale.js [client] (ecmascript)");
var _removebasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-base-path.js [client] (ecmascript)");
var _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [client] (ecmascript)");
var _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [client] (ecmascript)");
var _resolvehref = __turbopack_context__.r("[project]/node_modules/next/dist/client/resolve-href.js [client] (ecmascript)");
var _isapiroute = __turbopack_context__.r("[project]/node_modules/next/dist/lib/is-api-route.js [client] (ecmascript)");
var _getnextpathnameinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js [client] (ecmascript)");
var _formatnextpathnameinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js [client] (ecmascript)");
var _comparestates = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/compare-states.js [client] (ecmascript)");
var _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [client] (ecmascript)");
var _isbot = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [client] (ecmascript)");
var _omit = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/omit.js [client] (ecmascript)");
var _interpolateas = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js [client] (ecmascript)");
var _disablesmoothscroll = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [client] (ecmascript)");
var _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [client] (ecmascript)");
var _deploymentid = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/deployment-id.js [client] (ecmascript)");
var resolveRewrites;
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
function buildCancellationError() {
    return Object.assign(Object.defineProperty(new Error('Route Cancelled'), "__NEXT_ERROR_CODE", {
        value: "E315",
        enumerable: false,
        configurable: true
    }), {
        cancelled: true
    });
}
function matchesMiddleware(options) {
    return _async_to_generator._(function() {
        var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        Promise.resolve(options.router.pageLoader.getMiddleware())
                    ];
                case 1:
                    matchers = _state.sent();
                    if (!matchers) return [
                        2,
                        false
                    ];
                    _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname;
                    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`
                    cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;
                    asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));
                    // Check only path match on client. Matching "has" should be done on server
                    // where we can access more info such as headers, HttpOnly cookie, etc.
                    return [
                        2,
                        matchers.some(function(m) {
                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);
                        })
                    ];
            }
        });
    })();
}
function stripOrigin(url) {
    var origin = (0, _utils.getLocationOrigin)();
    return url.startsWith(origin) ? url.substring(origin.length) : url;
}
function prepareUrlAs(router, url, as) {
    // If url and as provided as an object representation,
    // we'll format them into the string version here.
    var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(router, url, true), 2), resolvedHref = _ref[0], resolvedAs = _ref[1];
    var origin = (0, _utils.getLocationOrigin)();
    var hrefWasAbsolute = resolvedHref.startsWith(origin);
    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);
    resolvedHref = stripOrigin(resolvedHref);
    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);
    var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;
    return {
        url: preparedUrl,
        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)
    };
}
function resolveDynamicRoute(pathname, pages) {
    var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));
    if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return pathname;
    }
    // handle resolving href for dynamic routes
    if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function(page) {
            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {
                pathname = page;
                return true;
            }
        });
    }
    return (0, _removetrailingslash.removeTrailingSlash)(pathname);
}
function getMiddlewareData(source, response, options) {
    var nextConfig = {
        basePath: options.router.basePath,
        i18n: {
            locales: options.router.locales
        },
        trailingSlash: Boolean(("TURBOPACK compile-time value", false))
    };
    var rewriteHeader = response.headers.get('x-nextjs-rewrite');
    var rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');
    var matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);
    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {
        // leverage x-matched-path to detect next.config.js rewrites
        rewriteTarget = matchedPath;
    }
    if (rewriteTarget) {
        if (rewriteTarget.startsWith('/') || ("TURBOPACK compile-time value", false)) {
            var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);
            var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {
                nextConfig: nextConfig,
                parseData: true
            });
            var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);
            return Promise.all([
                options.router.pageLoader.getPageList(),
                (0, _routeloader.getClientBuildManifest)()
            ]).then(function(param) {
                var _param = _sliced_to_array._(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;
                var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);
                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {
                    var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {
                        nextConfig: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : nextConfig,
                        parseData: true
                    });
                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);
                    parsedRewriteTarget.pathname = as;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                {
                    var result;
                } else if (!pages.includes(fsPathname)) {
                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);
                    if (resolvedPathname !== fsPathname) {
                        fsPathname = resolvedPathname;
                    }
                }
                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;
                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {
                    var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);
                    Object.assign(parsedRewriteTarget.query, matches || {});
                }
                return {
                    type: 'rewrite',
                    parsedAs: parsedRewriteTarget,
                    resolvedHref: resolvedHref
                };
            });
        }
        var src = (0, _parsepath.parsePath)(source);
        var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {
            nextConfig: nextConfig,
            parseData: true
        })), {
            defaultLocale: options.router.defaultLocale,
            buildId: ''
        }));
        return Promise.resolve({
            type: 'redirect-external',
            destination: "".concat(pathname).concat(src.query).concat(src.hash)
        });
    }
    var redirectTarget = response.headers.get('x-nextjs-redirect');
    if (redirectTarget) {
        if (redirectTarget.startsWith('/')) {
            var src1 = (0, _parsepath.parsePath)(redirectTarget);
            var pathname1 = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src1.pathname, {
                nextConfig: nextConfig,
                parseData: true
            })), {
                defaultLocale: options.router.defaultLocale,
                buildId: ''
            }));
            return Promise.resolve({
                type: 'redirect-internal',
                newAs: "".concat(pathname1).concat(src1.query).concat(src1.hash),
                newUrl: "".concat(pathname1).concat(src1.query).concat(src1.hash)
            });
        }
        return Promise.resolve({
            type: 'redirect-external',
            destination: redirectTarget
        });
    }
    return Promise.resolve({
        type: 'next'
    });
}
function withMiddlewareEffects(options) {
    return _async_to_generator._(function() {
        var matches, data, effect;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        matchesMiddleware(options)
                    ];
                case 1:
                    matches = _state.sent();
                    if (!matches || !options.fetchData) {
                        return [
                            2,
                            null
                        ];
                    }
                    return [
                        4,
                        options.fetchData()
                    ];
                case 2:
                    data = _state.sent();
                    return [
                        4,
                        getMiddlewareData(data.dataHref, data.response, options)
                    ];
                case 3:
                    effect = _state.sent();
                    return [
                        2,
                        {
                            dataHref: data.dataHref,
                            json: data.json,
                            response: data.response,
                            text: data.text,
                            cacheKey: data.cacheKey,
                            effect: effect
                        }
                    ];
            }
        });
    })();
}
var manualScrollRestoration = ("TURBOPACK compile-time value", false) && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {
    try {
        var v = '__next';
        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;
    } catch (n) {}
}();
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');
function fetchRetry(url, attempts, options) {
    return fetch(url, {
        // Cookies are required to be present for Next.js' SSG "Preview Mode".
        // Cookies may also be required for `getServerSideProps`.
        //
        // > `fetch` wont send cookies, unless you set the credentials init
        // > option.
        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch
        //
        // > For maximum browser compatibility when it comes to sending &
        // > receiving cookies, always supply the `credentials: 'same-origin'`
        // > option instead of relying on the default.
        // https://github.com/github/fetch#caveats
        credentials: 'same-origin',
        method: options.method || 'GET',
        headers: Object.assign({}, options.headers, {
            'x-nextjs-data': '1'
        })
    }).then(function(response) {
        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;
    });
}
function tryToParseAsJSON(text) {
    try {
        return JSON.parse(text);
    } catch (error) {
        return null;
    }
}
function fetchNextData(param) {
    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;
    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;
    var deploymentId = (0, _deploymentid.getDeploymentId)();
    var getData = function(params) {
        var _params_method;
        return fetchRetry(dataHref, isServerRender ? 3 : 1, {
            headers: Object.assign({}, isPrefetch ? {
                purpose: 'prefetch'
            } : {}, isPrefetch && hasMiddleware ? {
                'x-middleware-prefetch': '1'
            } : {}, deploymentId ? {
                'x-deployment-id': deploymentId
            } : {}),
            method: (_params_method = params === null || params === void 0 ? void 0 : params.method) !== null && _params_method !== void 0 ? _params_method : 'GET'
        }).then(function(response) {
            if (response.ok && (params === null || params === void 0 ? void 0 : params.method) === 'HEAD') {
                return {
                    dataHref: dataHref,
                    response: response,
                    text: '',
                    json: {},
                    cacheKey: cacheKey
                };
            }
            return response.text().then(function(text) {
                if (!response.ok) {
                    /**
             * When the data response is a redirect because of a middleware
             * we do not consider it an error. The headers must bring the
             * mapped location.
             * TODO: Change the status code in the handler.
             */ if (hasMiddleware && [
                        301,
                        302,
                        307,
                        308
                    ].includes(response.status)) {
                        return {
                            dataHref: dataHref,
                            response: response,
                            text: text,
                            json: {},
                            cacheKey: cacheKey
                        };
                    }
                    if (response.status === 404) {
                        var _tryToParseAsJSON;
                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) === null || _tryToParseAsJSON === void 0 ? void 0 : _tryToParseAsJSON.notFound) {
                            return {
                                dataHref: dataHref,
                                json: {
                                    notFound: SSG_DATA_NOT_FOUND
                                },
                                response: response,
                                text: text,
                                cacheKey: cacheKey
                            };
                        }
                    }
                    var error = Object.defineProperty(new Error("Failed to load static props"), "__NEXT_ERROR_CODE", {
                        value: "E124",
                        enumerable: false,
                        configurable: true
                    });
                    /**
             * We should only trigger a server-side transition if this was
             * caused on a client-side transition. Otherwise, we'd get into
             * an infinite loop.
             */ if (!isServerRender) {
                        (0, _routeloader.markAssetError)(error);
                    }
                    throw error;
                }
                return {
                    dataHref: dataHref,
                    json: parseJSON ? tryToParseAsJSON(text) : null,
                    response: response,
                    text: text,
                    cacheKey: cacheKey
                };
            });
        }).then(function(data) {
            if (!persistCache || ("TURBOPACK compile-time value", "development") !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {
                delete inflightCache[cacheKey];
            }
            return data;
        }).catch(function(err) {
            if (!unstable_skipClientCache) {
                delete inflightCache[cacheKey];
            }
            if (err.message === 'Failed to fetch' || // firefox
            err.message === 'NetworkError when attempting to fetch resource.' || // safari
            err.message === 'Load failed') {
                (0, _routeloader.markAssetError)(err);
            }
            throw err;
        });
    };
    // when skipping client cache we wait to update
    // inflight cache until successful data response
    // this allows racing click event with fetching newer data
    // without blocking navigation when stale data is available
    if (unstable_skipClientCache && persistCache) {
        return getData({}).then(function(data) {
            if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {
                // only update cache if not marked as no-cache
                inflightCache[cacheKey] = Promise.resolve(data);
            }
            return data;
        });
    }
    if (inflightCache[cacheKey] !== undefined) {
        return inflightCache[cacheKey];
    }
    return inflightCache[cacheKey] = getData(isBackground ? {
        method: 'HEAD'
    } : {});
}
function createKey() {
    return Math.random().toString(36).slice(2, 10);
}
function handleHardNavigation(param) {
    var url = param.url, router = param.router;
    // ensure we don't trigger a hard navigation to the same
    // URL as this can end up with an infinite refresh
    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {
        throw Object.defineProperty(new Error("Invariant: attempted to hard navigate to the same URL ".concat(url, " ").concat(location.href)), "__NEXT_ERROR_CODE", {
            value: "E282",
            enumerable: false,
            configurable: true
        });
    }
    window.location.href = url;
}
var getCancelledHandler = function(param) {
    var route = param.route, router = param.router;
    var cancelled = false;
    var cancel = router.clc = function() {
        cancelled = true;
    };
    var handleCancelled = function() {
        if (cancelled) {
            var error = Object.defineProperty(new Error('Abort fetching component for route: "'.concat(route, '"')), "__NEXT_ERROR_CODE", {
                value: "E483",
                enumerable: false,
                configurable: true
            });
            error.cancelled = true;
            throw error;
        }
        if (cancel === router.clc) {
            router.clc = null;
        }
    };
    return handleCancelled;
};
var Router = /*#__PURE__*/ function() {
    function Router(pathname, query, as, param) {
        var _this = this;
        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;
        _class_call_check._(this, Router);
        // Server Data Cache (full data requests)
        this.sdc = {};
        // Server Background Cache (HEAD requests)
        this.sbc = {};
        this.isFirstPopStateEvent = true;
        this._key = createKey();
        this.onPopState = function(e) {
            var isFirstPopStateEvent = _this.isFirstPopStateEvent;
            _this.isFirstPopStateEvent = false;
            var state = e.state;
            if (!state) {
                // We get state as undefined for two reasons.
                //  1. With older safari (< 8) and older chrome (< 34)
                //  2. When the URL changed with #
                //
                // In the both cases, we don't need to proceed and change the route.
                // (as it's already changed)
                // But we can simply replace the state with the new changes.
                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
                // So, doing the following for (1) does no harm.
                var _$pathname = _this.pathname, _$query = _this.query;
                _this.changeState('replaceState', (0, _formaturl.formatWithValidation)({
                    pathname: (0, _addbasepath.addBasePath)(_$pathname),
                    query: _$query
                }), (0, _utils.getURL)());
                return;
            }
            // __NA is used to identify if the history entry can be handled by the app-router.
            if (state.__NA) {
                window.location.reload();
                return;
            }
            if (!state.__N) {
                return;
            }
            // Safari fires popstateevent when reopening the browser.
            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {
                return;
            }
            var forcedScroll;
            var url = state.url, _$as = state.as, options = state.options, key = state.key;
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            {
                var v;
            }
            _this._key = key;
            var _$pathname1 = (0, _parserelativeurl.parseRelativeUrl)(url).pathname;
            // Make sure we don't re-render on initial load,
            // can be caused by navigating back from an external site
            if (_this.isSsr && _$as === (0, _addbasepath.addBasePath)(_this.asPath) && _$pathname1 === (0, _addbasepath.addBasePath)(_this.pathname)) {
                return;
            }
            // If the downstream application returns falsy, return.
            // They will then be responsible for handling the event.
            if (_this._bps && !_this._bps(state)) {
                return;
            }
            _this.change('replaceState', url, _$as, Object.assign({}, options, {
                shallow: options.shallow && _this._shallow,
                locale: options.locale || _this.defaultLocale,
                // @ts-ignore internal value not exposed on types
                _h: 0
            }), forcedScroll);
        };
        // represents the current component key
        var route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        // set up the component cache (by route keys)
        this.components = {};
        // We should not keep the cache, if there's an error
        // Otherwise, this cause issues when when going back and
        // come again to the errored page.
        if (pathname !== '/_error') {
            this.components[route] = {
                Component: Component,
                initial: true,
                props: initialProps,
                err: err,
                __N_SSG: initialProps && initialProps.__N_SSG,
                __N_SSP: initialProps && initialProps.__N_SSP
            };
        }
        this.components['/_app'] = {
            Component: App,
            styleSheets: []
        };
        // Backwards compat for Router.router.events
        // TODO: Should be remove the following major version as it was never documented
        this.events = Router.events;
        this.pageLoader = pageLoader;
        // if auto prerendered and dynamic route wait to update asPath
        // until after mount to prevent hydration mismatch
        var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;
        this.basePath = ("TURBOPACK compile-time value", "") || '';
        this.sub = subscription;
        this.clc = null;
        this._wrapApp = wrapApp;
        // make sure to ignore extra popState in safari on navigating
        // back from external site
        this.isSsr = true;
        this.isLocaleDomain = false;
        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !("TURBOPACK compile-time value", false));
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        this.state = {
            route: route,
            pathname: pathname,
            query: query,
            asPath: autoExportDynamic ? pathname : as,
            isPreview: !!isPreview,
            locale: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : undefined,
            isFallback: isFallback
        };
        this._initialMatchesMiddlewarePromise = Promise.resolve(false);
        if (typeof window !== 'undefined') {
            // make sure "as" doesn't start with double slashes or else it can
            // throw an error as it's considered invalid
            if (!as.startsWith('//')) {
                // in order for `e.state` to work on the `onpopstate` event
                // we have to register the initial route upon initialization
                var options = {
                    locale: locale
                };
                var asPath = (0, _utils.getURL)();
                this._initialMatchesMiddlewarePromise = matchesMiddleware({
                    router: this,
                    locale: locale,
                    asPath: asPath
                }).then(function(matches) {
                    // if middleware matches we leave resolving to the change function
                    // as the server needs to resolve for correct priority
                    ;
                    options._shouldResolveHref = as !== pathname;
                    _this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({
                        pathname: (0, _addbasepath.addBasePath)(pathname),
                        query: query
                    }), asPath, options);
                    return matches;
                });
            }
            window.addEventListener('popstate', this.onPopState);
            // enable custom scroll restoration handling when available
            // otherwise fallback to browser's default handling
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
        }
    }
    _create_class._(Router, [
        {
            key: "reload",
            value: function reload() {
                window.location.reload();
            }
        },
        {
            /**
   * Go back in history
   */ key: "back",
            value: function back() {
                window.history.back();
            }
        },
        {
            /**
   * Go forward in history
   */ key: "forward",
            value: function forward() {
                window.history.forward();
            }
        },
        {
            /**
   * Performs a `pushState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */ key: "push",
            value: function push(url, as) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                ;
                var ref;
                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;
                return this.change('pushState', url, as, options);
            }
        },
        {
            /**
   * Performs a `replaceState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */ key: "replace",
            value: function replace(url, as) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                ;
                var ref;
                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;
                return this.change('replaceState', url, as, options);
            }
        },
        {
            key: "_bfl",
            value: function _bfl(as, resolvedAs, locale, skipNavigate) {
                return _async_to_generator._(function() {
                    var BloomFilter, staticFilterData, dynamicFilterData, ref, err, routerFilterSValue, routerFilterDValue, matchesBflStatic, matchesBflDynamic, pathsToCheck, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step_value, curAs, allowMatchCurrent, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i, _iter, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                                ;
                                if (!(!this._bfl_s && !this._bfl_d)) return [
                                    3,
                                    5
                                ];
                                BloomFilter = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/bloom-filter.js [client] (ecmascript)").BloomFilter;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    (0, _routeloader.getClientBuildManifest)()
                                ];
                            case 2:
                                ref = _state.sent(), staticFilterData = ref.__routerFilterStatic, dynamicFilterData = ref.__routerFilterDynamic, ref;
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                err = _state.sent();
                                // failed to load build manifest hard navigate
                                // to be safe
                                console.error(err);
                                if (skipNavigate) {
                                    return [
                                        2,
                                        true
                                    ];
                                }
                                handleHardNavigation({
                                    url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                                    router: this
                                });
                                return [
                                    2,
                                    new Promise(function() {})
                                ];
                            case 4:
                                routerFilterSValue = ("TURBOPACK compile-time value", {
                                    "numItems": ("TURBOPACK compile-time value", 5),
                                    "errorRate": ("TURBOPACK compile-time value", 0.0001),
                                    "numBits": ("TURBOPACK compile-time value", 96),
                                    "numHashes": ("TURBOPACK compile-time value", 14),
                                    "bitArray": ("TURBOPACK compile-time value", [
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 1),
                                        ("TURBOPACK compile-time value", 0),
                                        ("TURBOPACK compile-time value", 0)
                                    ])
                                });
                                if (!staticFilterData && routerFilterSValue) {
                                    staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;
                                }
                                routerFilterDValue = ("TURBOPACK compile-time value", {
                                    "numItems": ("TURBOPACK compile-time value", 0),
                                    "errorRate": ("TURBOPACK compile-time value", 0.0001),
                                    "numBits": ("TURBOPACK compile-time value", 0),
                                    "numHashes": ("TURBOPACK compile-time value", null),
                                    "bitArray": ("TURBOPACK compile-time value", [])
                                });
                                if (!dynamicFilterData && routerFilterDValue) {
                                    dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;
                                }
                                if (staticFilterData === null || staticFilterData === void 0 ? void 0 : staticFilterData.numHashes) {
                                    this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);
                                    this._bfl_s.import(staticFilterData);
                                }
                                if (dynamicFilterData === null || dynamicFilterData === void 0 ? void 0 : dynamicFilterData.numHashes) {
                                    this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);
                                    this._bfl_d.import(dynamicFilterData);
                                }
                                _state.label = 5;
                            case 5:
                                matchesBflStatic = false;
                                matchesBflDynamic = false;
                                pathsToCheck = [
                                    {
                                        as: as
                                    },
                                    {
                                        as: resolvedAs
                                    }
                                ];
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(_iterator = pathsToCheck[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        _step_value = _step.value, curAs = _step_value.as, allowMatchCurrent = _step_value.allowMatchCurrent;
                                        if (curAs) {
                                            asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);
                                            asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));
                                            if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {
                                                ;
                                                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) === null || _this__bfl_s === void 0 ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) === null || _this__bfl_s1 === void 0 ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));
                                                for(_i = 0, _iter = [
                                                    asNoSlash,
                                                    asNoSlashLocale
                                                ]; _i < _iter.length; _i++){
                                                    normalizedAS = _iter[_i];
                                                    // if any sub-path of as matches a dynamic filter path
                                                    // it should be hard navigated
                                                    curAsParts = normalizedAS.split('/');
                                                    for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){
                                                        ;
                                                        currentPart = curAsParts.slice(0, i).join('/');
                                                        if (currentPart && ((_this__bfl_d = this._bfl_d) === null || _this__bfl_d === void 0 ? void 0 : _this__bfl_d.contains(currentPart))) {
                                                            matchesBflDynamic = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                // if the client router filter is matched then we trigger
                                                // a hard navigation
                                                if (matchesBflStatic || matchesBflDynamic) {
                                                    if (skipNavigate) {
                                                        return [
                                                            2,
                                                            true
                                                        ];
                                                    }
                                                    handleHardNavigation({
                                                        url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                                                        router: this
                                                    });
                                                    return [
                                                        2,
                                                        new Promise(function() {})
                                                    ];
                                                }
                                            }
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                _state.label = 6;
                            case 6:
                                return [
                                    2,
                                    false
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "change",
            value: function change(method, url, as, options, forcedScroll) {
                return _async_to_generator._(function() {
                    var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref, ref1, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _routeInfo_route, isValidShallowRoute, _options_scroll1, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1, err2, canSkipUpdating, e, hashRegex, err3;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!(0, _islocalurl.isLocalURL)(url)) {
                                    handleHardNavigation({
                                        url: url,
                                        router: this
                                    });
                                    return [
                                        2,
                                        false
                                    ];
                                }
                                // WARNING: `_h` is an internal option for handing Next.js client-side
                                // hydration. Your app should _never_ use this property. It may change at
                                // any time without notice.
                                isQueryUpdating = options._h === 1;
                                if (!(!isQueryUpdating && !options.shallow)) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    this._bfl(as, undefined, options.locale)
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;
                                nextState = _object_spread._({}, this.state);
                                // for static pages with query params in the URL we delay
                                // marking the router ready until after the query is updated
                                // or a navigation has occurred
                                readyStateChange = this.isReady !== true;
                                this.isReady = true;
                                isSsr = this.isSsr;
                                if (!isQueryUpdating) {
                                    this.isSsr = false;
                                }
                                // if a route transition is already in progress before
                                // the query updating is triggered ignore query updating
                                if (isQueryUpdating && this.clc) {
                                    return [
                                        2,
                                        false
                                    ];
                                }
                                prevLocale = nextState.locale;
                                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                                ;
                                // marking route changes as a navigation start entry
                                if (_utils.ST) {
                                    performance.mark('routeChange');
                                }
                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;
                                routeProps = {
                                    shallow: shallow
                                };
                                if (this._inFlightRoute && this.clc) {
                                    if (!isSsr) {
                                        Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);
                                    }
                                    this.clc();
                                    this.clc = null;
                                }
                                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));
                                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);
                                this._inFlightRoute = as;
                                localeChange = prevLocale !== nextState.locale;
                                if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) return [
                                    3,
                                    7
                                ];
                                nextState.asPath = cleanedAs;
                                Router.events.emit('hashChangeStart', as, routeProps);
                                // TODO: do we need the resolved href when only a hash change?
                                this.changeState(method, url, as, _object_spread_props._(_object_spread._({}, options), {
                                    scroll: false
                                }));
                                if (scroll) {
                                    this.scrollToHash(cleanedAs);
                                }
                                _state.label = 3;
                            case 3:
                                _state.trys.push([
                                    3,
                                    5,
                                    ,
                                    6
                                ]);
                                return [
                                    4,
                                    this.set(nextState, this.components[nextState.route], null)
                                ];
                            case 4:
                                _state.sent();
                                return [
                                    3,
                                    6
                                ];
                            case 5:
                                err = _state.sent();
                                if ((0, _iserror.default)(err) && err.cancelled) {
                                    Router.events.emit('routeChangeError', err, cleanedAs, routeProps);
                                }
                                throw err;
                            case 6:
                                Router.events.emit('hashChangeComplete', as, routeProps);
                                return [
                                    2,
                                    true
                                ];
                            case 7:
                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);
                                pathname = parsed.pathname, query = parsed.query;
                                _state.label = 8;
                            case 8:
                                _state.trys.push([
                                    8,
                                    10,
                                    ,
                                    11
                                ]);
                                return [
                                    4,
                                    Promise.all([
                                        this.pageLoader.getPageList(),
                                        (0, _routeloader.getClientBuildManifest)(),
                                        this.pageLoader.getMiddleware()
                                    ])
                                ];
                            case 9:
                                ref = _sliced_to_array._.apply(void 0, [
                                    _state.sent(),
                                    2
                                ]), pages = ref[0], ref1 = ref[1], rewrites = ref1.__rewrites, ref1, ref;
                                return [
                                    3,
                                    11
                                ];
                            case 10:
                                err1 = _state.sent();
                                // If we fail to resolve the page list or client-build manifest, we must
                                // do a server-side transition:
                                handleHardNavigation({
                                    url: as,
                                    router: this
                                });
                                return [
                                    2,
                                    false
                                ];
                            case 11:
                                // If asked to change the current URL we should reload the current page
                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                                // We also need to set the method = replaceState always
                                // as this should not go into the history (That's how browsers work)
                                // We should compare the new asPath to the current asPath, not the url
                                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                                    method = 'replaceState';
                                }
                                // we need to resolve the as value using rewrites for dynamic SSG
                                // pages to allow building the data URL correctly
                                resolvedAs = as;
                                // url and as should always be prefixed with basePath by this
                                // point by either next/link or router.push/replace so strip the
                                // basePath from the pathname to match the pages dir 1-to-1
                                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;
                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
                                parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;
                                // if we detected the path as app route during prefetching
                                // trigger hard navigation
                                if ((_this_components_pathname = this.components[pathname]) === null || _this_components_pathname === void 0 ? void 0 : _this_components_pathname.__appRouter) {
                                    handleHardNavigation({
                                        url: as,
                                        router: this
                                    });
                                    return [
                                        2,
                                        new Promise(function() {})
                                    ];
                                }
                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));
                                _tmp = !options.shallow;
                                if (!_tmp) return [
                                    3,
                                    13
                                ];
                                return [
                                    4,
                                    matchesMiddleware({
                                        asPath: as,
                                        locale: nextState.locale,
                                        router: this
                                    })
                                ];
                            case 12:
                                _tmp = _state.sent();
                                _state.label = 13;
                            case 13:
                                isMiddlewareMatch = _tmp;
                                if (isQueryUpdating && isMiddlewareMatch) {
                                    shouldResolveHref = false;
                                }
                                if (shouldResolveHref && pathname !== '/_error') {
                                    ;
                                    options._shouldResolveHref = true;
                                    if (("TURBOPACK compile-time value", false) && as.startsWith('/')) //TURBOPACK unreachable
                                    ;
                                    else {
                                        parsed.pathname = resolveDynamicRoute(pathname, pages);
                                        if (parsed.pathname !== pathname) {
                                            pathname = parsed.pathname;
                                            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);
                                            if (!isMiddlewareMatch) {
                                                url = (0, _formaturl.formatWithValidation)(parsed);
                                            }
                                        }
                                    }
                                }
                                if (!(0, _islocalurl.isLocalURL)(as)) {
                                    if ("TURBOPACK compile-time truthy", 1) {
                                        throw Object.defineProperty(new Error('Invalid href: "'.concat(url, '" and as: "').concat(as, '", received relative href and external as') + "\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as"), "__NEXT_ERROR_CODE", {
                                            value: "E380",
                                            enumerable: false,
                                            configurable: true
                                        });
                                    }
                                    handleHardNavigation({
                                        url: as,
                                        router: this
                                    });
                                    return [
                                        2,
                                        false
                                    ];
                                }
                                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);
                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
                                routeMatch = false;
                                if ((0, _isdynamic.isDynamicRoute)(route)) {
                                    parsedAs1 = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);
                                    asPathname = parsedAs1.pathname;
                                    routeRegex = (0, _routeregex.getRouteRegex)(route);
                                    routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);
                                    shouldInterpolate = route === asPathname;
                                    interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};
                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {
                                            return !query[param] && !routeRegex.groups[param].optional;
                                        });
                                        if (missingParams.length > 0 && !isMiddlewareMatch) {
                                            if ("TURBOPACK compile-time truthy", 1) {
                                                console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                                            }
                                            throw Object.defineProperty(new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://nextjs.org/docs/messages/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as')), "__NEXT_ERROR_CODE", {
                                                value: "E344",
                                                enumerable: false,
                                                configurable: true
                                            });
                                        }
                                    } else if (shouldInterpolate) {
                                        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs1, {
                                            pathname: interpolatedAs.result,
                                            query: (0, _omit.omit)(query, interpolatedAs.params)
                                        }));
                                    } else {
                                        // Merge params into `query`, overwriting any specified in search
                                        Object.assign(query, routeMatch);
                                    }
                                }
                                if (!isQueryUpdating) {
                                    Router.events.emit('routeChangeStart', as, routeProps);
                                }
                                isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';
                                _state.label = 14;
                            case 14:
                                _state.trys.push([
                                    14,
                                    35,
                                    ,
                                    36
                                ]);
                                return [
                                    4,
                                    this.getRouteInfo({
                                        route: route,
                                        pathname: pathname,
                                        query: query,
                                        as: as,
                                        resolvedAs: resolvedAs,
                                        routeProps: routeProps,
                                        locale: nextState.locale,
                                        isPreview: nextState.isPreview,
                                        hasMiddleware: isMiddlewareMatch,
                                        unstable_skipClientCache: options.unstable_skipClientCache,
                                        isQueryUpdating: isQueryUpdating && !this.isFallback,
                                        isMiddlewareRewrite: isMiddlewareRewrite
                                    })
                                ];
                            case 15:
                                routeInfo = _state.sent();
                                if (!(!isQueryUpdating && !options.shallow)) return [
                                    3,
                                    17
                                ];
                                return [
                                    4,
                                    this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)
                                ];
                            case 16:
                                _state.sent();
                                _state.label = 17;
                            case 17:
                                if ('route' in routeInfo && isMiddlewareMatch) {
                                    pathname = routeInfo.route || route;
                                    route = pathname;
                                    if (!routeProps.shallow) {
                                        query = Object.assign({}, routeInfo.query || {}, query);
                                    }
                                    cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;
                                    if (routeMatch && pathname !== cleanedParsedPathname) {
                                        Object.keys(routeMatch).forEach(function(key) {
                                            if (routeMatch && query[key] === routeMatch[key]) {
                                                delete query[key];
                                            }
                                        });
                                    }
                                    if ((0, _isdynamic.isDynamicRoute)(pathname)) {
                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);
                                        rewriteAs = prefixedAs;
                                        if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {
                                            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);
                                        }
                                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                                        ;
                                        routeRegex1 = (0, _routeregex.getRouteRegex)(pathname);
                                        curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex1)(new URL(rewriteAs, location.href).pathname);
                                        if (curRouteMatch) {
                                            Object.assign(query, curRouteMatch);
                                        }
                                    }
                                }
                                // If the routeInfo brings a redirect we simply apply it.
                                if ('type' in routeInfo) {
                                    if (routeInfo.type === 'redirect-internal') {
                                        return [
                                            2,
                                            this.change(method, routeInfo.newUrl, routeInfo.newAs, options)
                                        ];
                                    } else {
                                        handleHardNavigation({
                                            url: routeInfo.destination,
                                            router: this
                                        });
                                        return [
                                            2,
                                            new Promise(function() {})
                                        ];
                                    }
                                }
                                component = routeInfo.Component;
                                if (component && component.unstable_scriptLoader) {
                                    scripts = [].concat(component.unstable_scriptLoader());
                                    scripts.forEach(function(script) {
                                        (0, _script.handleClientScriptLoad)(script.props);
                                    });
                                }
                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [
                                    3,
                                    23
                                ];
                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {
                                    // Use the destination from redirect without adding locale
                                    options.locale = false;
                                    destination = routeInfo.props.pageProps.__N_REDIRECT;
                                    // check if destination is internal (resolves to a page) and attempt
                                    // client-navigation if it is falling back to hard navigation if
                                    // it's not
                                    if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {
                                        parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);
                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
                                        _prepareUrlAs = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;
                                        return [
                                            2,
                                            this.change(method, newUrl, newAs, options)
                                        ];
                                    }
                                    handleHardNavigation({
                                        url: destination,
                                        router: this
                                    });
                                    return [
                                        2,
                                        new Promise(function() {})
                                    ];
                                }
                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;
                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [
                                    3,
                                    23
                                ];
                                _state.label = 18;
                            case 18:
                                _state.trys.push([
                                    18,
                                    20,
                                    ,
                                    21
                                ]);
                                return [
                                    4,
                                    this.fetchComponent('/404')
                                ];
                            case 19:
                                _state.sent();
                                notFoundRoute = '/404';
                                return [
                                    3,
                                    21
                                ];
                            case 20:
                                _ = _state.sent();
                                notFoundRoute = '/_error';
                                return [
                                    3,
                                    21
                                ];
                            case 21:
                                return [
                                    4,
                                    this.getRouteInfo({
                                        route: notFoundRoute,
                                        pathname: notFoundRoute,
                                        query: query,
                                        as: as,
                                        resolvedAs: resolvedAs,
                                        routeProps: {
                                            shallow: false
                                        },
                                        locale: nextState.locale,
                                        isPreview: nextState.isPreview,
                                        isNotFound: true
                                    })
                                ];
                            case 22:
                                routeInfo = _state.sent();
                                if ('type' in routeInfo) {
                                    throw Object.defineProperty(new Error("Unexpected middleware effect on /404"), "__NEXT_ERROR_CODE", {
                                        value: "E158",
                                        enumerable: false,
                                        configurable: true
                                    });
                                }
                                _state.label = 23;
                            case 23:
                                if (isQueryUpdating && this.pathname === '/_error' && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) === null || _self___NEXT_DATA___props === void 0 ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) === null || _self___NEXT_DATA___props_pageProps === void 0 ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) === null || _routeInfo_props === void 0 ? void 0 : _routeInfo_props.pageProps)) {
                                    // ensure statusCode is still correct for static 500 page
                                    // when updating query information
                                    routeInfo.props.pageProps.statusCode = 500;
                                }
                                // shallow routing is only allowed for same page URL changes.
                                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) !== null && _routeInfo_route !== void 0 ? _routeInfo_route : route);
                                shouldScroll = (_options_scroll1 = options.scroll) !== null && _options_scroll1 !== void 0 ? _options_scroll1 : !isQueryUpdating && !isValidShallowRoute;
                                resetScroll = shouldScroll ? {
                                    x: 0,
                                    y: 0
                                } : null;
                                upcomingScrollState = forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll;
                                // the new state that the router gonna set
                                upcomingRouterState = _object_spread_props._(_object_spread._({}, nextState), {
                                    route: route,
                                    pathname: pathname,
                                    query: query,
                                    asPath: cleanedAs,
                                    isFallback: false
                                });
                                if (!(isQueryUpdating && isErrorRoute)) return [
                                    3,
                                    29
                                ];
                                return [
                                    4,
                                    this.getRouteInfo({
                                        route: this.pathname,
                                        pathname: this.pathname,
                                        query: query,
                                        as: as,
                                        resolvedAs: resolvedAs,
                                        routeProps: {
                                            shallow: false
                                        },
                                        locale: nextState.locale,
                                        isPreview: nextState.isPreview,
                                        isQueryUpdating: isQueryUpdating && !this.isFallback
                                    })
                                ];
                            case 24:
                                routeInfo = _state.sent();
                                if ('type' in routeInfo) {
                                    throw Object.defineProperty(new Error("Unexpected middleware effect on ".concat(this.pathname)), "__NEXT_ERROR_CODE", {
                                        value: "E225",
                                        enumerable: false,
                                        configurable: true
                                    });
                                }
                                if (this.pathname === '/_error' && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) === null || _self___NEXT_DATA___props1 === void 0 ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) === null || _self___NEXT_DATA___props_pageProps1 === void 0 ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) === null || _routeInfo_props1 === void 0 ? void 0 : _routeInfo_props1.pageProps)) {
                                    // ensure statusCode is still correct for static 500 page
                                    // when updating query information
                                    routeInfo.props.pageProps.statusCode = 500;
                                }
                                _state.label = 25;
                            case 25:
                                _state.trys.push([
                                    25,
                                    27,
                                    ,
                                    28
                                ]);
                                return [
                                    4,
                                    this.set(upcomingRouterState, routeInfo, upcomingScrollState)
                                ];
                            case 26:
                                _state.sent();
                                return [
                                    3,
                                    28
                                ];
                            case 27:
                                err2 = _state.sent();
                                if ((0, _iserror.default)(err2) && err2.cancelled) {
                                    Router.events.emit('routeChangeError', err2, cleanedAs, routeProps);
                                }
                                throw err2;
                            case 28:
                                return [
                                    2,
                                    true
                                ];
                            case 29:
                                Router.events.emit('beforeHistoryChange', as, routeProps);
                                this.changeState(method, url, as, options);
                                // for query updates we can skip it if the state is unchanged and we don't
                                // need to scroll
                                // https://github.com/vercel/next.js/issues/37139
                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);
                                if (!!canSkipUpdating) return [
                                    3,
                                    34
                                ];
                                _state.label = 30;
                            case 30:
                                _state.trys.push([
                                    30,
                                    32,
                                    ,
                                    33
                                ]);
                                return [
                                    4,
                                    this.set(upcomingRouterState, routeInfo, upcomingScrollState)
                                ];
                            case 31:
                                _state.sent();
                                return [
                                    3,
                                    33
                                ];
                            case 32:
                                e = _state.sent();
                                if (e.cancelled) routeInfo.error = routeInfo.error || e;
                                else throw e;
                                return [
                                    3,
                                    33
                                ];
                            case 33:
                                if (routeInfo.error) {
                                    if (!isQueryUpdating) {
                                        Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);
                                    }
                                    throw routeInfo.error;
                                }
                                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                                ;
                                if (!isQueryUpdating) {
                                    Router.events.emit('routeChangeComplete', as, routeProps);
                                }
                                // A hash mark # is the optional last part of a URL
                                hashRegex = /#.+$/;
                                if (shouldScroll && hashRegex.test(as)) {
                                    this.scrollToHash(as);
                                }
                                _state.label = 34;
                            case 34:
                                return [
                                    2,
                                    true
                                ];
                            case 35:
                                err3 = _state.sent();
                                if ((0, _iserror.default)(err3) && err3.cancelled) {
                                    return [
                                        2,
                                        false
                                    ];
                                }
                                throw err3;
                            case 36:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "changeState",
            value: function changeState(method, url, as) {
                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                if ("TURBOPACK compile-time truthy", 1) {
                    if (typeof window.history === 'undefined') {
                        console.error("Warning: window.history is not available.");
                        return;
                    }
                    if (typeof window.history[method] === 'undefined') {
                        console.error("Warning: window.history.".concat(method, " is not available"));
                        return;
                    }
                }
                if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
                    this._shallow = options.shallow;
                    window.history[method]({
                        url: url,
                        as: as,
                        options: options,
                        __N: true,
                        key: this._key = method !== 'pushState' ? this._key : createKey()
                    }, // Passing the empty string here should be safe against future changes to the method.
                    // https://developer.mozilla.org/docs/Web/API/History/replaceState
                    '', as);
                }
            }
        },
        {
            key: "handleRouteInfoError",
            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
                return _async_to_generator._(function() {
                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (err.cancelled) {
                                    // bubble up cancellation errors
                                    throw err;
                                }
                                if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {
                                    Router.events.emit('routeChangeError', err, as, routeProps);
                                    // If we can't load the page it could be one of following reasons
                                    //  1. Page doesn't exists
                                    //  2. Page does exist in a different zone
                                    //  3. Internal error while loading the page
                                    // So, doing a hard reload is the proper way to deal with this.
                                    handleHardNavigation({
                                        url: as,
                                        router: this
                                    });
                                    // Changing the URL doesn't block executing the current code path.
                                    // So let's throw a cancellation error stop the routing logic.
                                    throw buildCancellationError();
                                }
                                console.error(err);
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    7,
                                    ,
                                    8
                                ]);
                                return [
                                    4,
                                    this.fetchComponent('/_error')
                                ];
                            case 2:
                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;
                                routeInfo = {
                                    props: props,
                                    Component: Component,
                                    styleSheets: styleSheets,
                                    err: err,
                                    error: err
                                };
                                if (!!routeInfo.props) return [
                                    3,
                                    6
                                ];
                                _state.label = 3;
                            case 3:
                                _state.trys.push([
                                    3,
                                    5,
                                    ,
                                    6
                                ]);
                                return [
                                    4,
                                    this.getInitialProps(Component, {
                                        err: err,
                                        pathname: pathname,
                                        query: query
                                    })
                                ];
                            case 4:
                                routeInfo.props = _state.sent();
                                return [
                                    3,
                                    6
                                ];
                            case 5:
                                gipErr = _state.sent();
                                console.error('Error in error page `getInitialProps`: ', gipErr);
                                routeInfo.props = {};
                                return [
                                    3,
                                    6
                                ];
                            case 6:
                                return [
                                    2,
                                    routeInfo
                                ];
                            case 7:
                                routeInfoErr = _state.sent();
                                return [
                                    2,
                                    this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), "__NEXT_ERROR_CODE", {
                                        value: "E394",
                                        enumerable: false,
                                        configurable: true
                                    }), pathname, query, as, routeProps, true)
                                ];
                            case 8:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "getRouteInfo",
            value: function getRouteInfo(_0) {
                return _async_to_generator._(function(param) {
                    var _this, requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, existingInfo, handleCancelled, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;
                                /**
     * This `route` binding can change if there's a rewrite
     * so we keep a reference to the original requested route
     * so we can store the cache for it and avoid re-requesting every time
     * for shallow routing purposes.
     */ route = requestedRoute;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    10,
                                    ,
                                    11
                                ]);
                                existingInfo = this.components[route];
                                if (routeProps.shallow && existingInfo && this.route === route) {
                                    return [
                                        2,
                                        existingInfo
                                    ];
                                }
                                handleCancelled = getCancelledHandler({
                                    route: route,
                                    router: this
                                });
                                if (hasMiddleware) {
                                    existingInfo = undefined;
                                }
                                cachedRouteInfo = existingInfo && !('initial' in existingInfo) && ("TURBOPACK compile-time value", "development") !== 'development' ? "TURBOPACK unreachable" : undefined;
                                isBackground = isQueryUpdating;
                                fetchNextDataParams = {
                                    dataHref: this.pageLoader.getDataHref({
                                        href: (0, _formaturl.formatWithValidation)({
                                            pathname: pathname,
                                            query: query
                                        }),
                                        skipInterpolation: true,
                                        asPath: isNotFound ? '/404' : resolvedAs,
                                        locale: locale
                                    }),
                                    hasMiddleware: true,
                                    isServerRender: this.isSsr,
                                    parseJSON: true,
                                    inflightCache: isBackground ? this.sbc : this.sdc,
                                    persistCache: !isPreview,
                                    isPrefetch: false,
                                    unstable_skipClientCache: unstable_skipClientCache,
                                    isBackground: isBackground
                                };
                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [
                                    3,
                                    2
                                ];
                                _tmp = null;
                                return [
                                    3,
                                    4
                                ];
                            case 2:
                                return [
                                    4,
                                    withMiddlewareEffects({
                                        fetchData: function() {
                                            return fetchNextData(fetchNextDataParams);
                                        },
                                        asPath: isNotFound ? '/404' : resolvedAs,
                                        locale: locale,
                                        router: this
                                    }).catch(function(err) {
                                        // we don't hard error during query updating
                                        // as it's un-necessary and doesn't need to be fatal
                                        // unless it is a fallback route and the props can't
                                        // be loaded
                                        if (isQueryUpdating) {
                                            return null;
                                        }
                                        throw err;
                                    })
                                ];
                            case 3:
                                _tmp = _state.sent();
                                _state.label = 4;
                            case 4:
                                data = _tmp;
                                // when rendering error routes we don't apply middleware
                                // effects
                                if (data && (pathname === '/_error' || pathname === '/404')) {
                                    data.effect = undefined;
                                }
                                if (isQueryUpdating) {
                                    if (!data) {
                                        data = {
                                            json: self.__NEXT_DATA__.props
                                        };
                                    } else {
                                        data.json = self.__NEXT_DATA__.props;
                                    }
                                }
                                handleCancelled();
                                if ((data === null || data === void 0 ? void 0 : (_data_effect = data.effect) === null || _data_effect === void 0 ? void 0 : _data_effect.type) === 'redirect-internal' || (data === null || data === void 0 ? void 0 : (_data_effect1 = data.effect) === null || _data_effect1 === void 0 ? void 0 : _data_effect1.type) === 'redirect-external') {
                                    return [
                                        2,
                                        data.effect
                                    ];
                                }
                                if (!((data === null || data === void 0 ? void 0 : (_data_effect2 = data.effect) === null || _data_effect2 === void 0 ? void 0 : _data_effect2.type) === 'rewrite')) return [
                                    3,
                                    6
                                ];
                                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);
                                return [
                                    4,
                                    this.pageLoader.getPageList()
                                ];
                            case 5:
                                pages = _state.sent();
                                // during query updating the page must match although during
                                // client-transition a redirect that doesn't match a page
                                // can be returned and this should trigger a hard navigation
                                // which is valid for incremental migration
                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {
                                    route = resolvedRoute;
                                    pathname = data.effect.resolvedHref;
                                    query = _object_spread._({}, query, data.effect.parsedAs.query);
                                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);
                                    // Check again the cache with the new destination.
                                    existingInfo = this.components[route];
                                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {
                                        // If we have a match with the current route due to rewrite,
                                        // we can copy the existing information to the rewritten one.
                                        // Then, we return the information along with the matched route.
                                        return [
                                            2,
                                            _object_spread_props._(_object_spread._({}, existingInfo), {
                                                route: route
                                            })
                                        ];
                                    }
                                }
                                _state.label = 6;
                            case 6:
                                if ((0, _isapiroute.isAPIRoute)(route)) {
                                    handleHardNavigation({
                                        url: as,
                                        router: this
                                    });
                                    return [
                                        2,
                                        new Promise(function() {})
                                    ];
                                }
                                _tmp1 = cachedRouteInfo;
                                if (_tmp1) return [
                                    3,
                                    8
                                ];
                                return [
                                    4,
                                    this.fetchComponent(route).then(function(res) {
                                        return {
                                            Component: res.page,
                                            styleSheets: res.styleSheets,
                                            __N_SSG: res.mod.__N_SSG,
                                            __N_SSP: res.mod.__N_SSP
                                        };
                                    })
                                ];
                            case 7:
                                _tmp1 = _state.sent();
                                _state.label = 8;
                            case 8:
                                routeInfo = _tmp1;
                                if ("TURBOPACK compile-time truthy", 1) {
                                    isValidElementType = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-is/index.js [client] (ecmascript)").isValidElementType;
                                    if (!isValidElementType(routeInfo.Component)) {
                                        throw Object.defineProperty(new Error('The default export is not a React Component in page: "'.concat(pathname, '"')), "__NEXT_ERROR_CODE", {
                                            value: "E286",
                                            enumerable: false,
                                            configurable: true
                                        });
                                    }
                                }
                                wasBailedPrefetch = data === null || data === void 0 ? void 0 : (_data_response = data.response) === null || _data_response === void 0 ? void 0 : _data_response.headers.get('x-middleware-skip');
                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
                                // For non-SSG prefetches that bailed before sending data
                                // we clear the cache to fetch full response
                                if (wasBailedPrefetch && (data === null || data === void 0 ? void 0 : data.dataHref)) {
                                    delete this.sdc[data.dataHref];
                                }
                                return [
                                    4,
                                    this._getData(function() {
                                        return _async_to_generator._(function() {
                                            var dataHref, fetched, _tmp;
                                            return _ts_generator._(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        if (!shouldFetchData) return [
                                                            3,
                                                            2
                                                        ];
                                                        if ((data === null || data === void 0 ? void 0 : data.json) && !wasBailedPrefetch) {
                                                            return [
                                                                2,
                                                                {
                                                                    cacheKey: data.cacheKey,
                                                                    props: data.json
                                                                }
                                                            ];
                                                        }
                                                        dataHref = (data === null || data === void 0 ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({
                                                            href: (0, _formaturl.formatWithValidation)({
                                                                pathname: pathname,
                                                                query: query
                                                            }),
                                                            asPath: resolvedAs,
                                                            locale: locale
                                                        });
                                                        return [
                                                            4,
                                                            fetchNextData({
                                                                dataHref: dataHref,
                                                                isServerRender: this.isSsr,
                                                                parseJSON: true,
                                                                inflightCache: wasBailedPrefetch ? {} : this.sdc,
                                                                persistCache: !isPreview,
                                                                isPrefetch: false,
                                                                unstable_skipClientCache: unstable_skipClientCache
                                                            })
                                                        ];
                                                    case 1:
                                                        fetched = _state.sent();
                                                        return [
                                                            2,
                                                            {
                                                                cacheKey: fetched.cacheKey,
                                                                props: fetched.json || {}
                                                            }
                                                        ];
                                                    case 2:
                                                        _tmp = {
                                                            headers: {}
                                                        };
                                                        return [
                                                            4,
                                                            this.getInitialProps(routeInfo.Component, {
                                                                pathname: pathname,
                                                                query: query,
                                                                asPath: as,
                                                                locale: locale,
                                                                locales: this.locales,
                                                                defaultLocale: this.defaultLocale
                                                            })
                                                        ];
                                                    case 3:
                                                        return [
                                                            2,
                                                            (_tmp.props = _state.sent(), _tmp)
                                                        ];
                                                }
                                            });
                                        }).call(_this);
                                    })
                                ];
                            case 9:
                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;
                                // Only bust the data cache for SSP routes although
                                // middleware can skip cache per request with
                                // x-middleware-cache: no-cache as well
                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {
                                    delete this.sdc[cacheKey];
                                }
                                // we kick off a HEAD request in the background
                                // when a non-prefetch request is made to signal revalidation
                                if (!this.isPreview && routeInfo.__N_SSG && ("TURBOPACK compile-time value", "development") !== 'development' && !isQueryUpdating) //TURBOPACK unreachable
                                ;
                                props.pageProps = Object.assign({}, props.pageProps);
                                routeInfo.props = props;
                                routeInfo.route = route;
                                routeInfo.query = query;
                                routeInfo.resolvedAs = resolvedAs;
                                this.components[route] = routeInfo;
                                return [
                                    2,
                                    routeInfo
                                ];
                            case 10:
                                err = _state.sent();
                                return [
                                    2,
                                    this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps)
                                ];
                            case 11:
                                return [
                                    2
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            key: "set",
            value: function set(state, data, resetScroll) {
                this.state = state;
                return this.sub(data, this.components['/_app'].Component, resetScroll);
            }
        },
        {
            /**
   * Callback to execute before replacing router state
   * @param cb callback to be executed
   */ key: "beforePopState",
            value: function beforePopState(cb) {
                this._bps = cb;
            }
        },
        {
            key: "onlyAHashChange",
            value: function onlyAHashChange(as) {
                if (!this.asPath) return false;
                var _this_asPath_split = _sliced_to_array._(this.asPath.split('#', 2), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];
                var _as_split = _sliced_to_array._(as.split('#', 2), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];
                // Makes sure we scroll to the provided hash if the url/hash are the same
                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
                    return true;
                }
                // If the urls are change, there's more than a hash change
                if (oldUrlNoHash !== newUrlNoHash) {
                    return false;
                }
                // If the hash has changed, then it's a hash only change.
                // This check is necessary to handle both the enter and
                // leave hash === '' cases. The identity case falls through
                // and is treated as a next reload.
                return oldHash !== newHash;
            }
        },
        {
            key: "scrollToHash",
            value: function scrollToHash(as) {
                var _as_split = _sliced_to_array._(as.split('#', 2), 2), tmp = _as_split[1], hash = tmp === void 0 ? '' : tmp;
                (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(function() {
                    // Scroll to top if the hash is just `#` with no value or `#top`
                    // To mirror browsers
                    if (hash === '' || hash === 'top') {
                        window.scrollTo(0, 0);
                        return;
                    }
                    // Decode hash to make non-latin anchor works.
                    var rawHash = decodeURIComponent(hash);
                    // First we check if the element by id is found
                    var idEl = document.getElementById(rawHash);
                    if (idEl) {
                        idEl.scrollIntoView();
                        return;
                    }
                    // If there's no element with the id, we check the `name` property
                    // To mirror browsers
                    var nameEl = document.getElementsByName(rawHash)[0];
                    if (nameEl) {
                        nameEl.scrollIntoView();
                    }
                }, {
                    onlyHashChange: this.onlyAHashChange(as)
                });
            }
        },
        {
            key: "urlIsNew",
            value: function urlIsNew(asPath) {
                return this.asPath !== asPath;
            }
        },
        {
            key: "prefetch",
            value: /**
   * Prefetch page code, you may wait for the data during page rendering.
   * This feature only works in production!
   * @param url the href of prefetched page
   * @param asPath the as path of the prefetched page
   */ function prefetch(_0) {
                return _async_to_generator._(function(url) {
                    var _this, asPath, options, parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;
                    var _arguments = arguments;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                asPath = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : url, options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
                                // Prefetch is not supported in development mode because it would trigger on-demand-entries
                                if ("TURBOPACK compile-time truthy", 1) {
                                    return [
                                        2
                                    ];
                                }
                                //TURBOPACK unreachable
                                ;
                            case 1:
                                pages = _state.sent();
                                resolvedAs = asPath;
                                locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;
                                return [
                                    4,
                                    matchesMiddleware({
                                        asPath: asPath,
                                        locale: locale,
                                        router: this
                                    })
                                ];
                            case 2:
                                isMiddlewareMatch = _state.sent();
                                if (!(("TURBOPACK compile-time value", false) && asPath.startsWith('/'))) return [
                                    3,
                                    4
                                ];
                                //TURBOPACK unreachable
                                ;
                            case 3:
                                ref = _state.sent(), rewrites = ref.__rewrites, ref;
                                rewritesResult = resolveRewrites((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function(p) {
                                    return resolveDynamicRoute(p, pages);
                                }, this.locales);
                                if (rewritesResult.externalDest) {
                                    return [
                                        2
                                    ];
                                }
                                if (!isMiddlewareMatch) {
                                    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);
                                }
                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                                    // if this directly matches a page we need to update the href to
                                    // allow the correct page chunk to be loaded
                                    pathname = rewritesResult.resolvedHref;
                                    parsed.pathname = pathname;
                                    if (!isMiddlewareMatch) {
                                        url = (0, _formaturl.formatWithValidation)(parsed);
                                    }
                                }
                                _state.label = 4;
                            case 4:
                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);
                                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {
                                    pathname = parsed.pathname;
                                    parsed.pathname = pathname;
                                    Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});
                                    if (!isMiddlewareMatch) {
                                        url = (0, _formaturl.formatWithValidation)(parsed);
                                    }
                                }
                                if ("TURBOPACK compile-time truthy", 1) return [
                                    3,
                                    5
                                ];
                                //TURBOPACK unreachable
                                ;
                            case 5:
                                return [
                                    4,
                                    withMiddlewareEffects({
                                        fetchData: function() {
                                            return fetchNextData({
                                                dataHref: _this.pageLoader.getDataHref({
                                                    href: (0, _formaturl.formatWithValidation)({
                                                        pathname: originalPathname,
                                                        query: query
                                                    }),
                                                    skipInterpolation: true,
                                                    asPath: resolvedAs,
                                                    locale: locale
                                                }),
                                                hasMiddleware: true,
                                                isServerRender: false,
                                                parseJSON: true,
                                                inflightCache: _this.sdc,
                                                persistCache: !_this.isPreview,
                                                isPrefetch: true
                                            });
                                        },
                                        asPath: asPath,
                                        locale: locale,
                                        router: this
                                    })
                                ];
                            case 6:
                                _tmp = _state.sent();
                                _state.label = 7;
                            case 7:
                                data = _tmp;
                                /**
     * If there was a rewrite we apply the effects of the rewrite on the
     * current parameters for the prefetch.
     */ if ((data === null || data === void 0 ? void 0 : data.effect.type) === 'rewrite') {
                                    parsed.pathname = data.effect.resolvedHref;
                                    pathname = data.effect.resolvedHref;
                                    query = _object_spread._({}, query, data.effect.parsedAs.query);
                                    resolvedAs = data.effect.parsedAs.pathname;
                                    url = (0, _formaturl.formatWithValidation)(parsed);
                                }
                                /**
     * If there is a redirect to an external destination then we don't have
     * to prefetch content as it will be unused.
     */ if ((data === null || data === void 0 ? void 0 : data.effect.type) === 'redirect-external') {
                                    return [
                                        2
                                    ];
                                }
                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
                                return [
                                    4,
                                    this._bfl(asPath, resolvedAs, options.locale, true)
                                ];
                            case 8:
                                if (_state.sent()) {
                                    this.components[urlPathname] = {
                                        __appRouter: true
                                    };
                                }
                                return [
                                    4,
                                    Promise.all([
                                        this.pageLoader._isSsg(route).then(function(isSsg) {
                                            return isSsg ? fetchNextData({
                                                dataHref: (data === null || data === void 0 ? void 0 : data.json) ? data === null || data === void 0 ? void 0 : data.dataHref : _this.pageLoader.getDataHref({
                                                    href: url,
                                                    asPath: resolvedAs,
                                                    locale: locale
                                                }),
                                                isServerRender: false,
                                                parseJSON: true,
                                                inflightCache: _this.sdc,
                                                persistCache: !_this.isPreview,
                                                isPrefetch: true,
                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!("TURBOPACK compile-time value", true)
                                            }).then(function() {
                                                return false;
                                            }).catch(function() {
                                                return false;
                                            }) : false;
                                        }),
                                        this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)
                                    ])
                                ];
                            case 9:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            key: "fetchComponent",
            value: function fetchComponent(route) {
                return _async_to_generator._(function() {
                    var handleCancelled, componentResult, err;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                handleCancelled = getCancelledHandler({
                                    route: route,
                                    router: this
                                });
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    this.pageLoader.loadPage(route)
                                ];
                            case 2:
                                componentResult = _state.sent();
                                handleCancelled();
                                return [
                                    2,
                                    componentResult
                                ];
                            case 3:
                                err = _state.sent();
                                handleCancelled();
                                throw err;
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "_getData",
            value: function _getData(fn) {
                var _this = this;
                var cancelled = false;
                var cancel = function() {
                    cancelled = true;
                };
                this.clc = cancel;
                return fn().then(function(data) {
                    if (cancel === _this.clc) {
                        _this.clc = null;
                    }
                    if (cancelled) {
                        var err = Object.defineProperty(new Error('Loading initial props cancelled'), "__NEXT_ERROR_CODE", {
                            value: "E405",
                            enumerable: false,
                            configurable: true
                        });
                        err.cancelled = true;
                        throw err;
                    }
                    return data;
                });
            }
        },
        {
            key: "getInitialProps",
            value: function getInitialProps(Component, ctx) {
                var _this_components__app = this.components['/_app'], App = _this_components__app.Component;
                var AppTree = this._wrapApp(App);
                ctx.AppTree = AppTree;
                return (0, _utils.loadGetInitialProps)(App, {
                    AppTree: AppTree,
                    Component: Component,
                    router: this,
                    ctx: ctx
                });
            }
        },
        {
            key: "route",
            get: function get() {
                return this.state.route;
            }
        },
        {
            key: "pathname",
            get: function get() {
                return this.state.pathname;
            }
        },
        {
            key: "query",
            get: function get() {
                return this.state.query;
            }
        },
        {
            key: "asPath",
            get: function get() {
                return this.state.asPath;
            }
        },
        {
            key: "locale",
            get: function get() {
                return this.state.locale;
            }
        },
        {
            key: "isFallback",
            get: function get() {
                return this.state.isFallback;
            }
        },
        {
            key: "isPreview",
            get: function get() {
                return this.state.isPreview;
            }
        }
    ]);
    return Router;
} //# sourceMappingURL=router.js.map
();
Router.events = (0, _mitt.default)();
}),
"[project]/node_modules/next/dist/shared/lib/image-config.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function VALID_LOADERS1() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function imageConfigDefault1() {
        return imageConfigDefault;
    }
});
var VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
var imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    /**
   * @deprecated Use `remotePatterns` instead to protect your application from malicious users.
   */ domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 14400,
    formats: [
        'image/webp'
    ],
    maximumRedirects: 3,
    dangerouslyAllowLocalIP: false,
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: "script-src 'none'; frame-src 'none'; sandbox;",
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: [
        75
    ],
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImageConfigContext", {
    enumerable: true,
    get: function get() {
        return ImageConfigContext;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [client] (ecmascript)");
var ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if ("TURBOPACK compile-time truthy", 1) {
    ImageConfigContext.displayName = 'ImageConfigContext';
} //# sourceMappingURL=image-config-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppRouterContext: null,
    GlobalLayoutRouterContext: null,
    LayoutRouterContext: null,
    MissingSlotContext: null,
    TemplateContext: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRouterContext: function AppRouterContext1() {
        return AppRouterContext;
    },
    GlobalLayoutRouterContext: function GlobalLayoutRouterContext1() {
        return GlobalLayoutRouterContext;
    },
    LayoutRouterContext: function LayoutRouterContext1() {
        return LayoutRouterContext;
    },
    MissingSlotContext: function MissingSlotContext1() {
        return MissingSlotContext;
    },
    TemplateContext: function TemplateContext1() {
        return TemplateContext;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var AppRouterContext = _react.default.createContext(null);
var LayoutRouterContext = _react.default.createContext(null);
var GlobalLayoutRouterContext = _react.default.createContext(null);
var TemplateContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    AppRouterContext.displayName = 'AppRouterContext';
    LayoutRouterContext.displayName = 'LayoutRouterContext';
    GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext';
    TemplateContext.displayName = 'TemplateContext';
}
var MissingSlotContext = _react.default.createContext(new Set()); //# sourceMappingURL=app-router-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NavigationPromisesContext: null,
    PathParamsContext: null,
    PathnameContext: null,
    ReadonlyURLSearchParams: null,
    SearchParamsContext: null,
    createDevToolsInstrumentedPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NavigationPromisesContext: function NavigationPromisesContext1() {
        return NavigationPromisesContext;
    },
    PathParamsContext: function PathParamsContext1() {
        return PathParamsContext;
    },
    PathnameContext: function PathnameContext1() {
        return PathnameContext;
    },
    ReadonlyURLSearchParams: function ReadonlyURLSearchParams() {
        return _readonlyurlsearchparams.ReadonlyURLSearchParams;
    },
    SearchParamsContext: function SearchParamsContext1() {
        return SearchParamsContext;
    },
    createDevToolsInstrumentedPromise: function createDevToolsInstrumentedPromise1() {
        return createDevToolsInstrumentedPromise;
    }
});
var _react = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)");
var _readonlyurlsearchparams = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/readonly-url-search-params.js [client] (ecmascript)");
var SearchParamsContext = (0, _react.createContext)(null);
var PathnameContext = (0, _react.createContext)(null);
var PathParamsContext = (0, _react.createContext)(null);
var NavigationPromisesContext = (0, _react.createContext)(null);
function createDevToolsInstrumentedPromise(displayName, value) {
    var promise = Promise.resolve(value);
    promise.status = 'fulfilled';
    promise.value = value;
    promise.displayName = "".concat(displayName, " (SSR)");
    return promise;
}
if ("TURBOPACK compile-time truthy", 1) {
    SearchParamsContext.displayName = 'SearchParamsContext';
    PathnameContext.displayName = 'PathnameContext';
    PathParamsContext.displayName = 'PathParamsContext';
    NavigationPromisesContext.displayName = 'NavigationPromisesContext';
} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/as-path-to-search-params.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Convert router.asPath to a URLSearchParams object
// example: /dynamic/[slug]?foo=bar -> { foo: 'bar' }
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "asPathToSearchParams", {
    enumerable: true,
    get: function get() {
        return asPathToSearchParams;
    }
});
function asPathToSearchParams(asPath) {
    return new URL(asPath, 'http://n').searchParams;
} //# sourceMappingURL=as-path-to-search-params.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/adapters.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _object_without_properties = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_without_properties.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PathnameContextProviderAdapter: null,
    adaptForAppRouterInstance: null,
    adaptForPathParams: null,
    adaptForSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PathnameContextProviderAdapter: function PathnameContextProviderAdapter1() {
        return PathnameContextProviderAdapter;
    },
    adaptForAppRouterInstance: function adaptForAppRouterInstance1() {
        return adaptForAppRouterInstance;
    },
    adaptForPathParams: function adaptForPathParams1() {
        return adaptForPathParams;
    },
    adaptForSearchParams: function adaptForSearchParams1() {
        return adaptForSearchParams;
    }
});
var _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [client] (ecmascript)");
var _jsxruntime = __turbopack_context__.r("[project]/node_modules/react/jsx-runtime.js [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [client] (ecmascript)");
var _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [client] (ecmascript)");
var _aspathtosearchparams = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/as-path-to-search-params.js [client] (ecmascript)");
var _routeregex = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-regex.js [client] (ecmascript)");
function adaptForAppRouterInstance(pagesRouter) {
    return {
        back: function back() {
            pagesRouter.back();
        },
        forward: function forward() {
            pagesRouter.forward();
        },
        refresh: function refresh() {
            pagesRouter.reload();
        },
        hmrRefresh: function hmrRefresh() {},
        push: function push(href) {
            var scroll = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).scroll;
            void pagesRouter.push(href, undefined, {
                scroll: scroll
            });
        },
        replace: function replace(href) {
            var scroll = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).scroll;
            void pagesRouter.replace(href, undefined, {
                scroll: scroll
            });
        },
        prefetch: function prefetch(href) {
            void pagesRouter.prefetch(href);
        }
    };
}
function adaptForSearchParams(router) {
    if (!router.isReady || !router.query) {
        return new URLSearchParams();
    }
    return (0, _aspathtosearchparams.asPathToSearchParams)(router.asPath);
}
function adaptForPathParams(router) {
    if (!router.isReady || !router.query) {
        return null;
    }
    var pathParams = {};
    var routeRegex = (0, _routeregex.getRouteRegex)(router.pathname);
    var keys = Object.keys(routeRegex.groups);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var key = _step.value;
            pathParams[key] = router.query[key];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return pathParams;
}
function PathnameContextProviderAdapter(_param) {
    var children = _param.children, router = _param.router, props = _object_without_properties._(_param, [
        "children",
        "router"
    ]);
    var ref = (0, _react.useRef)(props.isAutoExport);
    var value = (0, _react.useMemo)(function() {
        // isAutoExport is only ever `true` on the first render from the server,
        // so reset it to `false` after we read it for the first time as `true`. If
        // we don't use the value, then we don't need it.
        var isAutoExport = ref.current;
        if (isAutoExport) {
            ref.current = false;
        }
        // When the route is a dynamic route, we need to do more processing to
        // determine if we need to stop showing the pathname.
        if ((0, _utils.isDynamicRoute)(router.pathname)) {
            // When the router is rendering the fallback page, it can't possibly know
            // the path, so return `null` here. Read more about fallback pages over
            // at:
            // https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-pages
            if (router.isFallback) {
                return null;
            }
            // When `isAutoExport` is true, meaning this is a page page has been
            // automatically statically optimized, and the router is not ready, then
            // we can't know the pathname yet. Read more about automatic static
            // optimization at:
            // https://nextjs.org/docs/advanced-features/automatic-static-optimization
            if (isAutoExport && !router.isReady) {
                return null;
            }
        }
        // The `router.asPath` contains the pathname seen by the browser (including
        // any query strings), so it should have that stripped. Read more about the
        // `asPath` option over at:
        // https://nextjs.org/docs/api-reference/next/router#router-object
        var url;
        try {
            url = new URL(router.asPath, 'http://f');
        } catch (_) {
            // fallback to / for invalid asPath values e.g. //
            return '/';
        }
        return url.pathname;
    }, [
        router.asPath,
        router.isFallback,
        router.isReady,
        router.pathname
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=adapters.js.map
}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This has to be a shared module which is shared between client component error boundary and dynamic component
var _call_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_call_super.cjs [client] (ecmascript)");
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [client] (ecmascript)");
var _inherits = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_inherits.cjs [client] (ecmascript)");
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [client] (ecmascript)");
var _wrap_native_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_wrap_native_super.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function BailoutToCSRError1() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function isBailoutToCSRError1() {
        return isBailoutToCSRError;
    }
});
var BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
var BailoutToCSRError = /*#__PURE__*/ function(Error1) {
    _inherits._(BailoutToCSRError, Error1);
    function BailoutToCSRError(reason) {
        _class_call_check._(this, BailoutToCSRError);
        var _this;
        _this = _call_super._(this, BailoutToCSRError, [
            "Bail out to client-side rendering: ".concat(reason)
        ]), _this.reason = reason, _this.digest = BAILOUT_TO_CSR;
        return _this;
    }
    return BailoutToCSRError;
}(_wrap_native_super._(Error));
function isBailoutToCSRError(err) {
    if ((typeof err === "undefined" ? "undefined" : _type_of._(err)) !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}),
"[project]/node_modules/next/dist/shared/lib/error-source.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decorateServerError: null,
    getErrorSource: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decorateServerError: function decorateServerError1() {
        return decorateServerError;
    },
    getErrorSource: function getErrorSource1() {
        return getErrorSource;
    }
});
var symbolError = Symbol.for('NextjsError');
function getErrorSource(error) {
    return error[symbolError] || null;
}
function decorateServerError(error, type) {
    Object.defineProperty(error, symbolError, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: type
    });
} //# sourceMappingURL=error-source.js.map
}),
"[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizedAssetPrefix", {
    enumerable: true,
    get: function get() {
        return normalizedAssetPrefix;
    }
});
function normalizedAssetPrefix(assetPrefix) {
    // remove all leading slashes and trailing slashes
    var escapedAssetPrefix = (assetPrefix === null || assetPrefix === void 0 ? void 0 : assetPrefix.replace(/^\/+|\/+$/g, '')) || false;
    // if an assetPrefix was '/', we return empty string
    // because it could be an unnecessary trailing slash
    if (!escapedAssetPrefix) {
        return '';
    }
    if (URL.canParse(escapedAssetPrefix)) {
        var url = new URL(escapedAssetPrefix).toString();
        return url.endsWith('/') ? url.slice(0, -1) : url;
    }
    // assuming assetPrefix here is a pathname-style,
    // restore the leading slash
    return "/".concat(escapedAssetPrefix);
} //# sourceMappingURL=normalized-asset-prefix.js.map
}),
"[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
/**
MIT License

Copyright (c) 2015-present, Facebook, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ "use strict";
var _object_spread = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread.cjs [client] (ecmascript)");
var _object_spread_props = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_object_spread_props.cjs [client] (ecmascript)");
var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [client] (ecmascript)");
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [client] (ecmascript)");
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get() {
        return formatWebpackMessages;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [client] (ecmascript)"));
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic
var friendlySyntaxErrorLabel = 'Syntax error:';
var WEBPACK_BREAKING_CHANGE_POLYFILLS = '\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.';
function isLikelyASyntaxError(message) {
    return (0, _stripansi.default)(message).includes(friendlySyntaxErrorLabel);
}
var hadMissingSassError = false;
// Cleans up webpack error messages.
function formatMessage(message, verbose, importTraceNote) {
    // TODO: Replace this once webpack 5 is stable
    if ((typeof message === "undefined" ? "undefined" : _type_of._(message)) === 'object' && message.message) {
        var filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter(function(trace) {
            return !/next-(middleware|client-pages|route|edge-function)-loader\.js/.test(trace.originName);
        });
        var body = message.message;
        var breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);
        if (breakingChangeIndex >= 0) {
            body = body.slice(0, breakingChangeIndex);
        }
        // TODO: Rspack currently doesn't populate moduleName correctly in some cases,
        // fall back to moduleIdentifier as a workaround
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env.NEXT_RSPACK && !message.moduleName && !message.file && message.moduleIdentifier) {
            var parts = message.moduleIdentifier.split('!');
            message.moduleName = parts[parts.length - 1];
        }
        message = (message.moduleName ? (0, _stripansi.default)(message.moduleName) + '\n' : '') + (message.file ? (0, _stripansi.default)(message.file) + '\n' : '') + body + (message.details && verbose ? '\n' + message.details : '') + (filteredModuleTrace && filteredModuleTrace.length ? (importTraceNote || '\n\nImport trace for requested module:') + filteredModuleTrace.map(function(trace) {
            return "\n".concat(trace.moduleName);
        }).join('') : '') + (message.stack && verbose ? '\n' + message.stack : '');
    }
    var lines = message.split('\n');
    // Strip Webpack-added headers off errors/warnings
    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
    lines = lines.filter(function(line) {
        return !/Module [A-z ]+\(from/.test(line);
    });
    // Transform parsing error into syntax error
    // TODO: move this to our ESLint formatter?
    lines = lines.map(function(line) {
        var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
        if (!parsingError) {
            return line;
        }
        var _parsingError = _sliced_to_array._(parsingError, 4), errorLine = _parsingError[1], errorColumn = _parsingError[2], errorMessage = _parsingError[3];
        return "".concat(friendlySyntaxErrorLabel, " ").concat(errorMessage, " (").concat(errorLine, ":").concat(errorColumn, ")");
    });
    message = lines.join('\n');
    // Smoosh syntax errors (commonly found in CSS)
    message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "".concat(friendlySyntaxErrorLabel, " $3 ($1:$2)\n"));
    // Clean up export errors
    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
    message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
    message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
    lines = message.split('\n');
    // Remove leading newline
    if (lines.length > 2 && lines[1].trim() === '') {
        lines.splice(1, 1);
    }
    // Cleans up verbose "module not found" messages for files and packages.
    if (lines[1] && lines[1].startsWith('Module not found: ')) {
        lines = [
            lines[0],
            lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')
        ].concat(_to_consumable_array._(lines.slice(2)));
    }
    // Add helpful message for users trying to use Sass for the first time
    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
        // ./file.module.scss (<<loader info>>) => ./file.module.scss
        var firstLine = lines[0].split('!');
        lines[0] = firstLine[firstLine.length - 1];
        lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
        lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
        lines[1] += '\nLearn more: https://nextjs.org/docs/messages/install-sass';
        // dispose of unhelpful stack trace
        lines = lines.slice(0, 2);
        hadMissingSassError = true;
    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {
        // dispose of unhelpful stack trace following missing sass module
        lines = [];
    }
    if (!verbose) {
        message = lines.join('\n');
        // Internal stacks are generally useless so we strip them... with the
        // exception of stacks containing `webpack:` because they're normally
        // from user code generated by Webpack. For more information see
        // https://github.com/facebook/create-react-app/pull/1050
        message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, '') // at ... ...:x:y
        ;
        message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, '') // at <anonymous>
        ;
        message = message.replace(/File was processed with these loaders:\n(.+[\\/](next[\\/]dist[\\/].+|@next[\\/]react-refresh-utils[\\/]loader)\.js\n)*You may need an additional loader to handle the result of these loaders.\n/g, '');
        lines = message.split('\n');
    }
    // Remove duplicated newlines
    lines = lines.filter(function(line, index, arr) {
        return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
    });
    // Reassemble the message
    message = lines.join('\n');
    return message.trim();
}
function formatWebpackMessages(json, verbose) {
    var formattedErrors = json.errors.map(function(message) {
        var isUnknownNextFontError = message.message.includes('An error occurred in `next/font`.');
        return formatMessage(message, isUnknownNextFontError || verbose);
    });
    var formattedWarnings = json.warnings.map(function(message) {
        return formatMessage(message, verbose);
    });
    // Reorder errors to put the most relevant ones first.
    var reactServerComponentsError = -1;
    for(var i = 0; i < formattedErrors.length; i++){
        var error = formattedErrors[i];
        if (error.includes('ReactServerComponentsError')) {
            reactServerComponentsError = i;
            break;
        }
    }
    // Move the reactServerComponentsError to the top if it exists
    if (reactServerComponentsError !== -1) {
        var error1 = formattedErrors.splice(reactServerComponentsError, 1);
        formattedErrors.unshift(error1[0]);
    }
    var result = _object_spread_props._(_object_spread._({}, json), {
        errors: formattedErrors,
        warnings: formattedWarnings
    });
    if (!verbose && result.errors.some(isLikelyASyntaxError)) {
        // If there are any syntax errors, show just them.
        result.errors = result.errors.filter(isLikelyASyntaxError);
        result.warnings = [];
    }
    return result;
} //# sourceMappingURL=format-webpack-messages.js.map
}),
"[project]/node_modules/next/dist/shared/lib/side-effect.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get() {
        return SideEffect;
    }
});
var _react = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)");
var isServer = typeof window === 'undefined';
var useClientOnlyLayoutEffect = isServer ? function() {} : _react.useLayoutEffect;
var useClientOnlyEffect = isServer ? function() {} : _react.useEffect;
function SideEffect(props) {
    var headManager = props.headManager, reduceComponentsToState = props.reduceComponentsToState;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements));
        }
    }
    if (isServer) {
        var _headManager_mountedInstances;
        headManager === null || headManager === void 0 ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) === null || _headManager_mountedInstances === void 0 ? void 0 : _headManager_mountedInstances.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": function() {
            var _headManager_mountedInstances;
            headManager === null || headManager === void 0 ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) === null || _headManager_mountedInstances === void 0 ? void 0 : _headManager_mountedInstances.add(props.children);
            return ({
                "SideEffect.useClientOnlyLayoutEffect": function() {
                    var _headManager_mountedInstances;
                    headManager === null || headManager === void 0 ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) === null || _headManager_mountedInstances === void 0 ? void 0 : _headManager_mountedInstances.delete(props.children);
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": function() {
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
            return ({
                "SideEffect.useClientOnlyLayoutEffect": function() {
                    if (headManager) {
                        headManager._pendingUpdate = emitChange;
                    }
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    useClientOnlyEffect({
        "SideEffect.useClientOnlyEffect": function() {
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
            return ({
                "SideEffect.useClientOnlyEffect": function() {
                    if (headManager && headManager._pendingUpdate) {
                        headManager._pendingUpdate();
                        headManager._pendingUpdate = null;
                    }
                }
            })["SideEffect.useClientOnlyEffect"];
        }
    }["SideEffect.useClientOnlyEffect"]);
    return null;
} //# sourceMappingURL=side-effect.js.map
}),
"[project]/node_modules/next/dist/shared/lib/head.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use client';
"use strict";
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [client] (ecmascript)");
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function _default1() {
        return _default;
    },
    defaultHead: function defaultHead1() {
        return defaultHead;
    }
});
var _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
var _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [client] (ecmascript)");
var _jsxruntime = __turbopack_context__.r("[project]/node_modules/react/jsx-runtime.js [client] (ecmascript)");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
var _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [client] (ecmascript)"));
var _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [client] (ecmascript)");
var _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [client] (ecmascript)");
function defaultHead() {
    var head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset"),
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport")
    ];
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce(function(fragmentList, fragmentChild) {
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
var METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    var keys = new Set();
    var tags = new Set();
    var metaTypes = new Set();
    var metaCategories = {};
    return function(h) {
        var isUnique = true;
        var hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            var key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(var i = 0, len = METATYPES.length; i < len; i++){
                    var metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        var category = h.props[metatype];
                        var categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements) {
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead().reverse()).filter(unique()).reverse().map(function(c, i) {
        var key = c.key || i;
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                var srcMessage = c.props['src'] ? '<script> tag with src="'.concat(c.props['src'], '"') : "inline <script>";
                (0, _warnonce.warnOnce)("Do not add <script> tags using next/head (see ".concat(srcMessage, "). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component"));
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="'.concat(c.props['href'], '"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component'));
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key: key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head(param) {
    var children = param.children;
    var headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        children: children
    });
}
var _default = Head;
if ((typeof exports.default === 'function' || _type_of._(exports.default) === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}),
]);

//# sourceMappingURL=node_modules_next_dist_shared_lib_9a2a7093._.js.map