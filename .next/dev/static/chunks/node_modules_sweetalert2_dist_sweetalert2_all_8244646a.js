(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/sweetalert2/dist/sweetalert2.all.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var _call_super = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_call_super.cjs [app-client] (ecmascript)");
var _class_call_check = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_call_check.cjs [app-client] (ecmascript)");
var _construct = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_construct.cjs [app-client] (ecmascript)");
var _create_class = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_create_class.cjs [app-client] (ecmascript)");
var _get = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_get.cjs [app-client] (ecmascript)");
var _get_prototype_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_get_prototype_of.cjs [app-client] (ecmascript)");
var _inherits = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_inherits.cjs [app-client] (ecmascript)");
var _instanceof = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_instanceof.cjs [app-client] (ecmascript)");
var _sliced_to_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_sliced_to_array.cjs [app-client] (ecmascript)");
var _to_consumable_array = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_to_consumable_array.cjs [app-client] (ecmascript)");
var _type_of = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_type_of.cjs [app-client] (ecmascript)");
/*!
* sweetalert2 v11.26.17
* Released under the MIT License.
*/ (function(global, factory) {
    (("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : _type_of._(exports)) === 'object' && ("TURBOPACK compile-time value", "object") !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? ((r)=>r !== undefined && __turbopack_context__.v(r))(factory(__turbopack_context__.r, exports, module)) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Sweetalert2 = factory());
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    function _assertClassBrand(e, t, n) {
        if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
        throw new TypeError("Private element is not present on this object");
    }
    function _checkPrivateRedeclaration(e, t) {
        if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
    function _classPrivateFieldGet2(s, a) {
        return s.get(_assertClassBrand(s, a));
    }
    function _classPrivateFieldInitSpec(e, t, a) {
        _checkPrivateRedeclaration(e, t), t.set(e, a);
    }
    function _classPrivateFieldSet2(s, a, r) {
        return s.set(_assertClassBrand(s, a), r), r;
    }
    var RESTORE_FOCUS_TIMEOUT = 100;
    /** @type {GlobalState} */ var globalState = {};
    var focusPreviousActiveElement = function() {
        if (_instanceof._(globalState.previousActiveElement, HTMLElement)) {
            globalState.previousActiveElement.focus();
            globalState.previousActiveElement = null;
        } else if (document.body) {
            document.body.focus();
        }
    };
    /**
   * Restore previous active (focused) element
   *
   * @param {boolean} returnFocus
   * @returns {Promise<void>}
   */ var restoreActiveElement = function(returnFocus) {
        return new Promise(function(resolve) {
            if (!returnFocus) {
                return resolve();
            }
            var x = window.scrollX;
            var y = window.scrollY;
            globalState.restoreFocusTimeout = setTimeout(function() {
                focusPreviousActiveElement();
                resolve();
            }, RESTORE_FOCUS_TIMEOUT); // issues/900
            window.scrollTo(x, y);
        });
    };
    var swalPrefix = 'swal2-';
    /**
   * @typedef {Record<SwalClass, string>} SwalClasses
   */ /**
   * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon
   * @typedef {Record<SwalIcon, string>} SwalIcons
   */ /** @type {SwalClass[]} */ var classNames = [
        'container',
        'shown',
        'height-auto',
        'iosfix',
        'popup',
        'modal',
        'no-backdrop',
        'no-transition',
        'toast',
        'toast-shown',
        'show',
        'hide',
        'close',
        'title',
        'html-container',
        'actions',
        'confirm',
        'deny',
        'cancel',
        'footer',
        'icon',
        'icon-content',
        'image',
        'input',
        'file',
        'range',
        'select',
        'radio',
        'checkbox',
        'label',
        'textarea',
        'inputerror',
        'input-label',
        'validation-message',
        'progress-steps',
        'active-progress-step',
        'progress-step',
        'progress-step-line',
        'loader',
        'loading',
        'styled',
        'top',
        'top-start',
        'top-end',
        'top-left',
        'top-right',
        'center',
        'center-start',
        'center-end',
        'center-left',
        'center-right',
        'bottom',
        'bottom-start',
        'bottom-end',
        'bottom-left',
        'bottom-right',
        'grow-row',
        'grow-column',
        'grow-fullscreen',
        'rtl',
        'timer-progress-bar',
        'timer-progress-bar-container',
        'scrollbar-measure',
        'icon-success',
        'icon-warning',
        'icon-info',
        'icon-question',
        'icon-error',
        'draggable',
        'dragging'
    ];
    var swalClasses = classNames.reduce(function(acc, className) {
        acc[className] = swalPrefix + className;
        return acc;
    }, /** @type {SwalClasses} */ {});
    /** @type {SwalIcon[]} */ var icons = [
        'success',
        'warning',
        'info',
        'question',
        'error'
    ];
    var iconTypes = icons.reduce(function(acc, icon) {
        acc[icon] = swalPrefix + icon;
        return acc;
    }, /** @type {SwalIcons} */ {});
    var consolePrefix = 'SweetAlert2:';
    /**
   * Capitalize the first letter of a string
   *
   * @param {string} str
   * @returns {string}
   */ var capitalizeFirstLetter = function(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };
    /**
   * Standardize console warnings
   *
   * @param {string | string[]} message
   */ var warn = function(message) {
        console.warn("".concat(consolePrefix, " ").concat((typeof message === "undefined" ? "undefined" : _type_of._(message)) === 'object' ? message.join(' ') : message));
    };
    /**
   * Standardize console errors
   *
   * @param {string} message
   */ var error = function(message) {
        console.error("".concat(consolePrefix, " ").concat(message));
    };
    /**
   * Private global state for `warnOnce`
   *
   * @type {string[]}
   * @private
   */ var previousWarnOnceMessages = [];
    /**
   * Show a console warning, but only if it hasn't already been shown
   *
   * @param {string} message
   */ var warnOnce = function(message) {
        if (!previousWarnOnceMessages.includes(message)) {
            previousWarnOnceMessages.push(message);
            warn(message);
        }
    };
    /**
   * Show a one-time console warning about deprecated params/methods
   *
   * @param {string} deprecatedParam
   * @param {string?} useInstead
   */ var warnAboutDeprecation = function(deprecatedParam) {
        var useInstead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        warnOnce('"'.concat(deprecatedParam, '" is deprecated and will be removed in the next major release.').concat(useInstead ? ' Use "'.concat(useInstead, '" instead.') : ''));
    };
    /**
   * If `arg` is a function, call it (with no arguments or context) and return the result.
   * Otherwise, just pass the value through
   *
   * @param {(() => *) | *} arg
   * @returns {*}
   */ var callIfFunction = function(arg) {
        return typeof arg === 'function' ? arg() : arg;
    };
    /**
   * @param {*} arg
   * @returns {boolean}
   */ var hasToPromiseFn = function(arg) {
        return arg && typeof arg.toPromise === 'function';
    };
    /**
   * @param {*} arg
   * @returns {Promise<*>}
   */ var asPromise = function(arg) {
        return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
    };
    /**
   * @param {*} arg
   * @returns {boolean}
   */ var isPromise = function(arg) {
        return arg && Promise.resolve(arg) === arg;
    };
    /**
   * Gets the popup container which contains the backdrop and the popup itself.
   *
   * @returns {HTMLElement | null}
   */ var getContainer = function() {
        return document.body.querySelector(".".concat(swalClasses.container));
    };
    /**
   * @param {string} selectorString
   * @returns {HTMLElement | null}
   */ var elementBySelector = function(selectorString) {
        var container = getContainer();
        return container ? container.querySelector(selectorString) : null;
    };
    /**
   * @param {string} className
   * @returns {HTMLElement | null}
   */ var elementByClass = function(className) {
        return elementBySelector(".".concat(className));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getPopup = function() {
        return elementByClass(swalClasses.popup);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getIcon = function() {
        return elementByClass(swalClasses.icon);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getIconContent = function() {
        return elementByClass(swalClasses['icon-content']);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getTitle = function() {
        return elementByClass(swalClasses.title);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getHtmlContainer = function() {
        return elementByClass(swalClasses['html-container']);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getImage = function() {
        return elementByClass(swalClasses.image);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getProgressSteps = function() {
        return elementByClass(swalClasses['progress-steps']);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getValidationMessage = function() {
        return elementByClass(swalClasses['validation-message']);
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getConfirmButton = function() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getCancelButton = function() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getDenyButton = function() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getInputLabel = function() {
        return elementByClass(swalClasses['input-label']);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getLoader = function() {
        return elementBySelector(".".concat(swalClasses.loader));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getActions = function() {
        return elementByClass(swalClasses.actions);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getFooter = function() {
        return elementByClass(swalClasses.footer);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getTimerProgressBar = function() {
        return elementByClass(swalClasses['timer-progress-bar']);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getCloseButton = function() {
        return elementByClass(swalClasses.close);
    };
    // https://github.com/jkup/focusable/blob/master/index.js
    var focusable = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n';
    /**
   * @returns {HTMLElement[]}
   */ var getFocusableElements = function() {
        var popup = getPopup();
        if (!popup) {
            return [];
        }
        /** @type {NodeListOf<HTMLElement>} */ var focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
        var focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex
        .sort(function(a, b) {
            var tabindexA = parseInt(a.getAttribute('tabindex') || '0');
            var tabindexB = parseInt(b.getAttribute('tabindex') || '0');
            if (tabindexA > tabindexB) {
                return 1;
            } else if (tabindexA < tabindexB) {
                return -1;
            }
            return 0;
        });
        /** @type {NodeListOf<HTMLElement>} */ var otherFocusableElements = popup.querySelectorAll(focusable);
        var otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter(function(el) {
            return el.getAttribute('tabindex') !== '-1';
        });
        return _to_consumable_array._(new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))).filter(function(el) {
            return isVisible$1(el);
        });
    };
    /**
   * @returns {boolean}
   */ var isModal = function() {
        return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);
    };
    /**
   * @returns {boolean}
   */ var isToast = function() {
        var popup = getPopup();
        if (!popup) {
            return false;
        }
        return hasClass(popup, swalClasses.toast);
    };
    /**
   * @returns {boolean}
   */ var isLoading = function() {
        var popup = getPopup();
        if (!popup) {
            return false;
        }
        return popup.hasAttribute('data-loading');
    };
    /**
   * Securely set innerHTML of an element
   * https://github.com/sweetalert2/sweetalert2/issues/1926
   *
   * @param {HTMLElement} elem
   * @param {string} html
   */ var setInnerHtml = function(elem, html) {
        elem.textContent = '';
        if (html) {
            var parser = new DOMParser();
            var parsed = parser.parseFromString(html, "text/html");
            var head = parsed.querySelector('head');
            if (head) {
                Array.from(head.childNodes).forEach(function(child) {
                    elem.appendChild(child);
                });
            }
            var body = parsed.querySelector('body');
            if (body) {
                Array.from(body.childNodes).forEach(function(child) {
                    if (_instanceof._(child, HTMLVideoElement) || _instanceof._(child, HTMLAudioElement)) {
                        elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507
                    } else {
                        elem.appendChild(child);
                    }
                });
            }
        }
    };
    /**
   * @param {HTMLElement} elem
   * @param {string} className
   * @returns {boolean}
   */ var hasClass = function(elem, className) {
        if (!className) {
            return false;
        }
        var classList = className.split(/\s+/);
        for(var i = 0; i < classList.length; i++){
            if (!elem.classList.contains(classList[i])) {
                return false;
            }
        }
        return true;
    };
    /**
   * @param {HTMLElement} elem
   * @param {SweetAlertOptions} params
   */ var removeCustomClasses = function(elem, params) {
        Array.from(elem.classList).forEach(function(className) {
            if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
                elem.classList.remove(className);
            }
        });
    };
    /**
   * @param {HTMLElement} elem
   * @param {SweetAlertOptions} params
   * @param {string} className
   */ var applyCustomClass = function(elem, params, className) {
        removeCustomClasses(elem, params);
        if (!params.customClass) {
            return;
        }
        var customClass = params.customClass[/** @type {keyof SweetAlertCustomClass} */ className];
        if (!customClass) {
            return;
        }
        if (typeof customClass !== 'string' && !customClass.forEach) {
            warn("Invalid type of customClass.".concat(className, '! Expected string or iterable object, got "').concat(typeof customClass === "undefined" ? "undefined" : _type_of._(customClass), '"'));
            return;
        }
        addClass(elem, customClass);
    };
    /**
   * @param {HTMLElement} popup
   * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass
   * @returns {HTMLInputElement | null}
   */ var getInput$1 = function(popup, inputClass) {
        if (!inputClass) {
            return null;
        }
        switch(inputClass){
            case 'select':
            case 'textarea':
            case 'file':
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses[inputClass]));
            case 'checkbox':
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.checkbox, " input"));
            case 'radio':
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:checked")) || popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:first-child"));
            case 'range':
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.range, " input"));
            default:
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.input));
        }
    };
    /**
   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input
   */ var focusInput = function(input) {
        input.focus();
        // place cursor at end of text in text input
        if (input.type !== 'file') {
            // http://stackoverflow.com/a/2345915
            var val = input.value;
            input.value = '';
            input.value = val;
        }
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   * @param {boolean} condition
   */ var toggleClass = function(target, classList, condition) {
        if (!target || !classList) {
            return;
        }
        if (typeof classList === 'string') {
            classList = classList.split(/\s+/).filter(Boolean);
        }
        classList.forEach(function(className) {
            if (Array.isArray(target)) {
                target.forEach(function(elem) {
                    if (condition) {
                        elem.classList.add(className);
                    } else {
                        elem.classList.remove(className);
                    }
                });
            } else {
                if (condition) {
                    target.classList.add(className);
                } else {
                    target.classList.remove(className);
                }
            }
        });
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   */ var addClass = function(target, classList) {
        toggleClass(target, classList, true);
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   */ var removeClass = function(target, classList) {
        toggleClass(target, classList, false);
    };
    /**
   * Get direct child of an element by class name
   *
   * @param {HTMLElement} elem
   * @param {string} className
   * @returns {HTMLElement | undefined}
   */ var getDirectChildByClass = function(elem, className) {
        var children = Array.from(elem.children);
        for(var i = 0; i < children.length; i++){
            var child = children[i];
            if (_instanceof._(child, HTMLElement) && hasClass(child, className)) {
                return child;
            }
        }
    };
    /**
   * @param {HTMLElement} elem
   * @param {string} property
   * @param {string | number | null | undefined} value
   */ var applyNumericalStyle = function(elem, property, value) {
        if (value === "".concat(parseInt("".concat(value)))) {
            value = parseInt(value);
        }
        if (value || parseInt("".concat(value)) === 0) {
            elem.style.setProperty(property, typeof value === 'number' ? "".concat(value, "px") : /** @type {string} */ value);
        } else {
            elem.style.removeProperty(property);
        }
    };
    /**
   * @param {HTMLElement | null} elem
   * @param {string} display
   */ var show = function(elem) {
        var display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'flex';
        if (!elem) {
            return;
        }
        elem.style.display = display;
    };
    /**
   * @param {HTMLElement | null} elem
   */ var hide = function(elem) {
        if (!elem) {
            return;
        }
        elem.style.display = 'none';
    };
    /**
   * @param {HTMLElement | null} elem
   * @param {string} display
   */ var showWhenInnerHtmlPresent = function(elem) {
        var display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'block';
        if (!elem) {
            return;
        }
        new MutationObserver(function() {
            toggle(elem, elem.innerHTML, display);
        }).observe(elem, {
            childList: true,
            subtree: true
        });
    };
    /**
   * @param {HTMLElement} parent
   * @param {string} selector
   * @param {string} property
   * @param {string} value
   */ var setStyle = function(parent, selector, property, value) {
        /** @type {HTMLElement | null} */ var el = parent.querySelector(selector);
        if (el) {
            el.style.setProperty(property, value);
        }
    };
    /**
   * @param {HTMLElement} elem
   * @param {boolean | string | null | undefined} condition
   * @param {string} display
   */ var toggle = function(elem, condition) {
        var display = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'flex';
        if (condition) {
            show(elem, display);
        } else {
            hide(elem);
        }
    };
    /**
   * borrowed from jquery $(elem).is(':visible') implementation
   *
   * @param {HTMLElement | null} elem
   * @returns {boolean}
   */ var isVisible$1 = function(elem) {
        return Boolean(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
    };
    /**
   * @returns {boolean}
   */ var allButtonsAreHidden = function() {
        return !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
    };
    /**
   * @param {HTMLElement} elem
   * @returns {boolean}
   */ var isScrollable = function(elem) {
        return Boolean(elem.scrollHeight > elem.clientHeight);
    };
    /**
   * @param {HTMLElement} element
   * @param {HTMLElement} stopElement
   * @returns {boolean}
   */ var selfOrParentIsScrollable = function(element, stopElement) {
        var parent = /** @type {HTMLElement | null} */ element;
        while(parent && parent !== stopElement){
            if (isScrollable(parent)) {
                return true;
            }
            parent = parent.parentElement;
        }
        return false;
    };
    /**
   * borrowed from https://stackoverflow.com/a/46352119
   *
   * @param {HTMLElement} elem
   * @returns {boolean}
   */ var hasCssAnimation = function(elem) {
        var style = window.getComputedStyle(elem);
        var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
        var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
        return animDuration > 0 || transDuration > 0;
    };
    /**
   * @param {number} timer
   * @param {boolean} reset
   */ var animateTimerProgressBar = function(timer) {
        var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) {
            return;
        }
        if (isVisible$1(timerProgressBar)) {
            if (reset) {
                timerProgressBar.style.transition = 'none';
                timerProgressBar.style.width = '100%';
            }
            setTimeout(function() {
                timerProgressBar.style.transition = "width ".concat(timer / 1000, "s linear");
                timerProgressBar.style.width = '0%';
            }, 10);
        }
    };
    var stopTimerProgressBar = function() {
        var timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) {
            return;
        }
        var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        timerProgressBar.style.removeProperty('transition');
        timerProgressBar.style.width = '100%';
        var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        var timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
        timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
    };
    /**
   * Detect Node env
   *
   * @returns {boolean}
   */ var isNodeEnv = function() {
        return typeof window === 'undefined' || typeof document === 'undefined';
    };
    var sweetHTML = '\n <div aria-labelledby="'.concat(swalClasses.title, '" aria-describedby="').concat(swalClasses['html-container'], '" class="').concat(swalClasses.popup, '" tabindex="-1">\n   <button type="button" class="').concat(swalClasses.close, '"></button>\n   <ul class="').concat(swalClasses['progress-steps'], '"></ul>\n   <div class="').concat(swalClasses.icon, '"></div>\n   <img class="').concat(swalClasses.image, '" />\n   <h2 class="').concat(swalClasses.title, '" id="').concat(swalClasses.title, '"></h2>\n   <div class="').concat(swalClasses['html-container'], '" id="').concat(swalClasses['html-container'], '"></div>\n   <input class="').concat(swalClasses.input, '" id="').concat(swalClasses.input, '" />\n   <input type="file" class="').concat(swalClasses.file, '" />\n   <div class="').concat(swalClasses.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(swalClasses.select, '" id="').concat(swalClasses.select, '"></select>\n   <div class="').concat(swalClasses.radio, '"></div>\n   <label class="').concat(swalClasses.checkbox, '">\n     <input type="checkbox" id="').concat(swalClasses.checkbox, '" />\n     <span class="').concat(swalClasses.label, '"></span>\n   </label>\n   <textarea class="').concat(swalClasses.textarea, '" id="').concat(swalClasses.textarea, '"></textarea>\n   <div class="').concat(swalClasses['validation-message'], '" id="').concat(swalClasses['validation-message'], '"></div>\n   <div class="').concat(swalClasses.actions, '">\n     <div class="').concat(swalClasses.loader, '"></div>\n     <button type="button" class="').concat(swalClasses.confirm, '"></button>\n     <button type="button" class="').concat(swalClasses.deny, '"></button>\n     <button type="button" class="').concat(swalClasses.cancel, '"></button>\n   </div>\n   <div class="').concat(swalClasses.footer, '"></div>\n   <div class="').concat(swalClasses['timer-progress-bar-container'], '">\n     <div class="').concat(swalClasses['timer-progress-bar'], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, '');
    /**
   * @returns {boolean}
   */ var resetOldContainer = function() {
        var oldContainer = getContainer();
        if (!oldContainer) {
            return false;
        }
        oldContainer.remove();
        removeClass([
            document.documentElement,
            document.body
        ], [
            swalClasses['no-backdrop'],
            swalClasses['toast-shown'],
            // @ts-ignore: 'has-column' is not defined in swalClasses but may be set dynamically
            swalClasses['has-column']
        ]);
        return true;
    };
    var resetValidationMessage$1 = function() {
        if (globalState.currentInstance) {
            globalState.currentInstance.resetValidationMessage();
        }
    };
    var addInputChangeListeners = function() {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        var input = getDirectChildByClass(popup, swalClasses.input);
        var file = getDirectChildByClass(popup, swalClasses.file);
        /** @type {HTMLInputElement | null} */ var range = popup.querySelector(".".concat(swalClasses.range, " input"));
        /** @type {HTMLOutputElement | null} */ var rangeOutput = popup.querySelector(".".concat(swalClasses.range, " output"));
        var select = getDirectChildByClass(popup, swalClasses.select);
        /** @type {HTMLInputElement | null} */ var checkbox = popup.querySelector(".".concat(swalClasses.checkbox, " input"));
        var textarea = getDirectChildByClass(popup, swalClasses.textarea);
        if (input) {
            input.oninput = resetValidationMessage$1;
        }
        if (file) {
            file.onchange = resetValidationMessage$1;
        }
        if (select) {
            select.onchange = resetValidationMessage$1;
        }
        if (checkbox) {
            checkbox.onchange = resetValidationMessage$1;
        }
        if (textarea) {
            textarea.oninput = resetValidationMessage$1;
        }
        if (range && rangeOutput) {
            range.oninput = function() {
                resetValidationMessage$1();
                rangeOutput.value = range.value;
            };
            range.onchange = function() {
                resetValidationMessage$1();
                rangeOutput.value = range.value;
            };
        }
    };
    /**
   * @param {string | HTMLElement} target
   * @returns {HTMLElement}
   */ var getTarget = function(target) {
        if (typeof target === 'string') {
            var element = document.querySelector(target);
            if (!element) {
                throw new Error('Target element "'.concat(target, '" not found'));
            }
            return /** @type {HTMLElement} */ element;
        }
        return target;
    };
    /**
   * @param {SweetAlertOptions} params
   */ var setupAccessibility = function(params) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
        popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');
        if (!params.toast) {
            popup.setAttribute('aria-modal', 'true');
        }
    };
    /**
   * @param {HTMLElement} targetElement
   */ var setupRTL = function(targetElement) {
        if (window.getComputedStyle(targetElement).direction === 'rtl') {
            addClass(getContainer(), swalClasses.rtl);
            globalState.isRTL = true;
        }
    };
    /**
   * Add modal + backdrop to DOM
   *
   * @param {SweetAlertOptions} params
   */ var init = function(params) {
        // Clean up the old popup container if it exists
        var oldContainerExisted = resetOldContainer();
        if (isNodeEnv()) {
            error('SweetAlert2 requires document to initialize');
            return;
        }
        var container = document.createElement('div');
        container.className = swalClasses.container;
        if (oldContainerExisted) {
            addClass(container, swalClasses['no-transition']);
        }
        setInnerHtml(container, sweetHTML);
        container.dataset['swal2Theme'] = params.theme;
        var targetElement = getTarget(params.target || 'body');
        targetElement.appendChild(container);
        if (params.topLayer) {
            container.setAttribute('popover', '');
            container.showPopover();
        }
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
    };
    /**
   * @param {HTMLElement | object | string} param
   * @param {HTMLElement} target
   */ var parseHtmlToContainer = function(param, target) {
        // DOM element
        if (_instanceof._(param, HTMLElement)) {
            target.appendChild(param);
        } else if ((typeof param === "undefined" ? "undefined" : _type_of._(param)) === 'object') {
            handleObject(param, target);
        } else if (param) {
            setInnerHtml(target, param);
        }
    };
    /**
   * @param {object} param
   * @param {HTMLElement} target
   */ var handleObject = function(param, target) {
        // JQuery element(s)
        if ('jquery' in param) {
            handleJqueryElem(target, param);
        } else {
            setInnerHtml(target, param.toString());
        }
    };
    /**
   * @param {HTMLElement} target
   * @param {any} elem
   */ var handleJqueryElem = function(target, elem) {
        target.textContent = '';
        if (0 in elem) {
            for(var i = 0; i in elem; i++){
                target.appendChild(elem[i].cloneNode(true));
            }
        } else {
            target.appendChild(elem.cloneNode(true));
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderActions = function(instance, params) {
        var actions = getActions();
        var loader = getLoader();
        if (!actions || !loader) {
            return;
        }
        // Actions (buttons) wrapper
        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
            hide(actions);
        } else {
            show(actions);
        }
        // Custom class
        applyCustomClass(actions, params, 'actions');
        // Render all the buttons
        renderButtons(actions, loader, params);
        // Loader
        setInnerHtml(loader, params.loaderHtml || '');
        applyCustomClass(loader, params, 'loader');
    };
    /**
   * @param {HTMLElement} actions
   * @param {HTMLElement} loader
   * @param {SweetAlertOptions} params
   */ function renderButtons(actions, loader, params) {
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!confirmButton || !denyButton || !cancelButton) {
            return;
        }
        // Render buttons
        renderButton(confirmButton, 'confirm', params);
        renderButton(denyButton, 'deny', params);
        renderButton(cancelButton, 'cancel', params);
        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
        if (params.reverseButtons) {
            if (params.toast) {
                actions.insertBefore(cancelButton, confirmButton);
                actions.insertBefore(denyButton, confirmButton);
            } else {
                actions.insertBefore(cancelButton, loader);
                actions.insertBefore(denyButton, loader);
                actions.insertBefore(confirmButton, loader);
            }
        }
    }
    /**
   * @param {HTMLElement} confirmButton
   * @param {HTMLElement} denyButton
   * @param {HTMLElement} cancelButton
   * @param {SweetAlertOptions} params
   */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
        if (!params.buttonsStyling) {
            removeClass([
                confirmButton,
                denyButton,
                cancelButton
            ], swalClasses.styled);
            return;
        }
        addClass([
            confirmButton,
            denyButton,
            cancelButton
        ], swalClasses.styled);
        // Apply custom background colors to action buttons
        if (params.confirmButtonColor) {
            confirmButton.style.setProperty('--swal2-confirm-button-background-color', params.confirmButtonColor);
        }
        if (params.denyButtonColor) {
            denyButton.style.setProperty('--swal2-deny-button-background-color', params.denyButtonColor);
        }
        if (params.cancelButtonColor) {
            cancelButton.style.setProperty('--swal2-cancel-button-background-color', params.cancelButtonColor);
        }
        // Apply the outline color to action buttons
        applyOutlineColor(confirmButton);
        applyOutlineColor(denyButton);
        applyOutlineColor(cancelButton);
    }
    /**
   * @param {HTMLElement} button
   */ function applyOutlineColor(button) {
        var buttonStyle = window.getComputedStyle(button);
        if (buttonStyle.getPropertyValue('--swal2-action-button-focus-box-shadow')) {
            // If the button already has a custom outline color, no need to change it
            return;
        }
        var outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, 'rgba($1, $2, $3, 0.5)');
        button.style.setProperty('--swal2-action-button-focus-box-shadow', buttonStyle.getPropertyValue('--swal2-outline').replace(/ rgba\(.*/, " ".concat(outlineColor)));
    }
    /**
   * @param {HTMLElement} button
   * @param {'confirm' | 'deny' | 'cancel'} buttonType
   * @param {SweetAlertOptions} params
   */ function renderButton(button, buttonType, params) {
        var buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);
        toggle(button, params["show".concat(buttonName, "Button")], 'inline-block');
        setInnerHtml(button, params["".concat(buttonType, "ButtonText")] || ''); // Set caption text
        button.setAttribute('aria-label', params["".concat(buttonType, "ButtonAriaLabel")] || ''); // ARIA label
        // Add buttons custom classes
        button.className = swalClasses[buttonType];
        applyCustomClass(button, params, "".concat(buttonType, "Button"));
    }
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderCloseButton = function(instance, params) {
        var closeButton = getCloseButton();
        if (!closeButton) {
            return;
        }
        setInnerHtml(closeButton, params.closeButtonHtml || '');
        // Custom class
        applyCustomClass(closeButton, params, 'closeButton');
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute('aria-label', params.closeButtonAriaLabel || '');
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderContainer = function(instance, params) {
        var container = getContainer();
        if (!container) {
            return;
        }
        handleBackdropParam(container, params.backdrop);
        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow);
        // Custom class
        applyCustomClass(container, params, 'container');
    };
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['backdrop']} backdrop
   */ function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === 'string') {
            container.style.background = backdrop;
        } else if (!backdrop) {
            addClass([
                document.documentElement,
                document.body
            ], swalClasses['no-backdrop']);
        }
    }
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['position']} position
   */ function handlePositionParam(container, position) {
        if (!position) {
            return;
        }
        if (position in swalClasses) {
            addClass(container, swalClasses[position]);
        } else {
            warn('The "position" parameter is not valid, defaulting to "center"');
            addClass(container, swalClasses.center);
        }
    }
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['grow']} grow
   */ function handleGrowParam(container, grow) {
        if (!grow) {
            return;
        }
        addClass(container, swalClasses["grow-".concat(grow)]);
    }
    /**
   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */ var privateProps = {
        innerParams: new WeakMap(),
        domCache: new WeakMap()
    };
    /// <reference path="../../../../sweetalert2.d.ts"/>
    /** @type {InputClass[]} */ var inputClasses = [
        'input',
        'file',
        'range',
        'select',
        'radio',
        'checkbox',
        'textarea'
    ];
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderInput = function(instance, params) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        var innerParams = privateProps.innerParams.get(instance);
        var rerender = !innerParams || params.input !== innerParams.input;
        inputClasses.forEach(function(inputClass) {
            var inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
            if (!inputContainer) {
                return;
            }
            // set attributes
            setAttributes(inputClass, params.inputAttributes);
            // set class
            inputContainer.className = swalClasses[inputClass];
            if (rerender) {
                hide(inputContainer);
            }
        });
        if (params.input) {
            if (rerender) {
                showInput(params);
            }
            // set custom class
            setCustomClass(params);
        }
    };
    /**
   * @param {SweetAlertOptions} params
   */ var showInput = function(params) {
        if (!params.input) {
            return;
        }
        if (!renderInputType[params.input]) {
            error("Unexpected type of input! Expected ".concat(Object.keys(renderInputType).join(' | '), ', got "').concat(params.input, '"'));
            return;
        }
        var inputContainer = getInputContainer(params.input);
        if (!inputContainer) {
            return;
        }
        var input = renderInputType[params.input](inputContainer, params);
        show(inputContainer);
        // input autofocus
        if (params.inputAutoFocus) {
            setTimeout(function() {
                focusInput(input);
            });
        }
    };
    /**
   * @param {HTMLInputElement} input
   */ var removeAttributes = function(input) {
        for(var i = 0; i < input.attributes.length; i++){
            var attrName = input.attributes[i].name;
            if (![
                'id',
                'type',
                'value',
                'style'
            ].includes(attrName)) {
                input.removeAttribute(attrName);
            }
        }
    };
    /**
   * @param {InputClass} inputClass
   * @param {SweetAlertOptions['inputAttributes']} inputAttributes
   */ var setAttributes = function(inputClass, inputAttributes) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        var input = getInput$1(popup, inputClass);
        if (!input) {
            return;
        }
        removeAttributes(input);
        for(var attr in inputAttributes){
            input.setAttribute(attr, inputAttributes[attr]);
        }
    };
    /**
   * @param {SweetAlertOptions} params
   */ var setCustomClass = function(params) {
        if (!params.input) {
            return;
        }
        var inputContainer = getInputContainer(params.input);
        if (inputContainer) {
            applyCustomClass(inputContainer, params, 'input');
        }
    };
    /**
   * @param {HTMLInputElement | HTMLTextAreaElement} input
   * @param {SweetAlertOptions} params
   */ var setInputPlaceholder = function(input, params) {
        if (!input.placeholder && params.inputPlaceholder) {
            input.placeholder = params.inputPlaceholder;
        }
    };
    /**
   * @param {Input} input
   * @param {Input} prependTo
   * @param {SweetAlertOptions} params
   */ var setInputLabel = function(input, prependTo, params) {
        if (params.inputLabel) {
            var label = document.createElement('label');
            var labelClass = swalClasses['input-label'];
            label.setAttribute('for', input.id);
            label.className = labelClass;
            if (_type_of._(params.customClass) === 'object') {
                addClass(label, params.customClass.inputLabel);
            }
            label.innerText = params.inputLabel;
            prependTo.insertAdjacentElement('beforebegin', label);
        }
    };
    /**
   * @param {SweetAlertInput} inputType
   * @returns {HTMLElement | undefined}
   */ var getInputContainer = function(inputType) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        return getDirectChildByClass(popup, swalClasses[/** @type {SwalClass} */ inputType] || swalClasses.input);
    };
    /**
   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input
   * @param {SweetAlertOptions['inputValue']} inputValue
   */ var checkAndSetInputValue = function(input, inputValue) {
        if ([
            'string',
            'number'
        ].includes(typeof inputValue === "undefined" ? "undefined" : _type_of._(inputValue))) {
            input.value = "".concat(inputValue);
        } else if (!isPromise(inputValue)) {
            warn('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof inputValue === "undefined" ? "undefined" : _type_of._(inputValue), '"'));
        }
    };
    /** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ var renderInputType = {};
    /**
   * @param {Input | HTMLElement} input
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType['datetime-local'] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */ function(input, params) {
        var inputElement = /** @type {HTMLInputElement} */ input;
        checkAndSetInputValue(inputElement, params.inputValue);
        setInputLabel(inputElement, inputElement, params);
        setInputPlaceholder(inputElement, params);
        inputElement.type = /** @type {string} */ params.input;
        return inputElement;
    };
    /**
   * @param {Input | HTMLElement} input
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.file = function(input, params) {
        var inputElement = /** @type {HTMLInputElement} */ input;
        setInputLabel(inputElement, inputElement, params);
        setInputPlaceholder(inputElement, params);
        return inputElement;
    };
    /**
   * @param {Input | HTMLElement} range
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.range = function(range, params) {
        var rangeContainer = /** @type {HTMLElement} */ range;
        var rangeInput = rangeContainer.querySelector('input');
        var rangeOutput = rangeContainer.querySelector('output');
        if (rangeInput) {
            checkAndSetInputValue(rangeInput, params.inputValue);
            rangeInput.type = /** @type {string} */ params.input;
            setInputLabel(rangeInput, /** @type {Input} */ range, params);
        }
        if (rangeOutput) {
            checkAndSetInputValue(rangeOutput, params.inputValue);
        }
        return /** @type {Input} */ range;
    };
    /**
   * @param {Input | HTMLElement} select
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.select = function(select, params) {
        var selectElement = /** @type {HTMLSelectElement} */ select;
        selectElement.textContent = '';
        if (params.inputPlaceholder) {
            var placeholder = document.createElement('option');
            setInnerHtml(placeholder, params.inputPlaceholder);
            placeholder.value = '';
            placeholder.disabled = true;
            placeholder.selected = true;
            selectElement.appendChild(placeholder);
        }
        setInputLabel(selectElement, selectElement, params);
        return selectElement;
    };
    /**
   * @param {Input | HTMLElement} radio
   * @returns {Input}
   */ renderInputType.radio = function(radio) {
        var radioElement = /** @type {HTMLElement} */ radio;
        radioElement.textContent = '';
        return /** @type {Input} */ radio;
    };
    /**
   * @param {Input | HTMLElement} checkboxContainer
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.checkbox = function(checkboxContainer, params) {
        var popup = getPopup();
        if (!popup) {
            throw new Error('Popup not found');
        }
        var checkbox = getInput$1(popup, 'checkbox');
        if (!checkbox) {
            throw new Error('Checkbox input not found');
        }
        checkbox.value = '1';
        checkbox.checked = Boolean(params.inputValue);
        var containerElement = /** @type {HTMLElement} */ checkboxContainer;
        var label = containerElement.querySelector('span');
        if (label) {
            var placeholderOrLabel = params.inputPlaceholder || params.inputLabel;
            if (placeholderOrLabel) {
                setInnerHtml(label, placeholderOrLabel);
            }
        }
        return checkbox;
    };
    /**
   * @param {Input | HTMLElement} textarea
   * @param {SweetAlertOptions} params
   * @returns {Input}
   */ renderInputType.textarea = function(textarea, params) {
        var textareaElement = /** @type {HTMLTextAreaElement} */ textarea;
        checkAndSetInputValue(textareaElement, params.inputValue);
        setInputPlaceholder(textareaElement, params);
        setInputLabel(textareaElement, textareaElement, params);
        /**
     * @param {HTMLElement} el
     * @returns {number}
     */ var getMargin = function(el) {
            return parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
        };
        // https://github.com/sweetalert2/sweetalert2/issues/2291
        setTimeout(function() {
            // https://github.com/sweetalert2/sweetalert2/issues/1699
            if ('MutationObserver' in window) {
                var popup = getPopup();
                if (!popup) {
                    return;
                }
                var initialPopupWidth = parseInt(window.getComputedStyle(popup).width);
                var textareaResizeHandler = function() {
                    // check if texarea is still in document (i.e. popup wasn't closed in the meantime)
                    if (!document.body.contains(textareaElement)) {
                        return;
                    }
                    var textareaWidth = textareaElement.offsetWidth + getMargin(textareaElement);
                    var popupElement = getPopup();
                    if (popupElement) {
                        if (textareaWidth > initialPopupWidth) {
                            popupElement.style.width = "".concat(textareaWidth, "px");
                        } else {
                            applyNumericalStyle(popupElement, 'width', params.width);
                        }
                    }
                };
                new MutationObserver(textareaResizeHandler).observe(textareaElement, {
                    attributes: true,
                    attributeFilter: [
                        'style'
                    ]
                });
            }
        });
        return textareaElement;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderContent = function(instance, params) {
        var htmlContainer = getHtmlContainer();
        if (!htmlContainer) {
            return;
        }
        showWhenInnerHtmlPresent(htmlContainer);
        applyCustomClass(htmlContainer, params, 'htmlContainer');
        // Content as HTML
        if (params.html) {
            parseHtmlToContainer(params.html, htmlContainer);
            show(htmlContainer, 'block');
        } else if (params.text) {
            htmlContainer.textContent = params.text;
            show(htmlContainer, 'block');
        } else {
            hide(htmlContainer);
        }
        renderInput(instance, params);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderFooter = function(instance, params) {
        var footer = getFooter();
        if (!footer) {
            return;
        }
        showWhenInnerHtmlPresent(footer);
        toggle(footer, Boolean(params.footer), 'block');
        if (params.footer) {
            parseHtmlToContainer(params.footer, footer);
        }
        // Custom class
        applyCustomClass(footer, params, 'footer');
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderIcon = function(instance, params) {
        var innerParams = privateProps.innerParams.get(instance);
        var icon = getIcon();
        if (!icon) {
            return;
        }
        // if the given icon already rendered, apply the styling without re-rendering the icon
        if (innerParams && params.icon === innerParams.icon) {
            // Custom or default content
            setContent(icon, params);
            applyStyles(icon, params);
            return;
        }
        if (!params.icon && !params.iconHtml) {
            hide(icon);
            return;
        }
        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
            error('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(params.icon, '"'));
            hide(icon);
            return;
        }
        show(icon);
        // Custom or default content
        setContent(icon, params);
        applyStyles(icon, params);
        // Animate icon
        addClass(icon, params.showClass && params.showClass.icon);
        // Re-adjust the success icon on system theme change
        var colorSchemeQueryList = window.matchMedia('(prefers-color-scheme: dark)');
        colorSchemeQueryList.addEventListener('change', adjustSuccessIconBackgroundColor);
    };
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var applyStyles = function(icon, params) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(iconTypes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array._(_step.value, 2), iconType = _step_value[0], iconClassName = _step_value[1];
                if (params.icon !== iconType) {
                    removeClass(icon, iconClassName);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        addClass(icon, params.icon && iconTypes[params.icon]);
        // Icon color
        setColor(icon, params);
        // Success icon background color
        adjustSuccessIconBackgroundColor();
        // Custom class
        applyCustomClass(icon, params, 'icon');
    };
    // Adjust success icon background color to match the popup background color
    var adjustSuccessIconBackgroundColor = function() {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
        /** @type {NodeListOf<HTMLElement>} */ var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');
        for(var i = 0; i < successIconParts.length; i++){
            successIconParts[i].style.backgroundColor = popupBackgroundColor;
        }
    };
    /**
   *
   * @param {SweetAlertOptions} params
   * @returns {string}
   */ var successIconHtml = function(params) {
        return "\n  ".concat(params.animation ? '<div class="swal2-success-circular-line-left"></div>' : '', '\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div>\n  ').concat(params.animation ? '<div class="swal2-success-fix"></div>' : '', "\n  ").concat(params.animation ? '<div class="swal2-success-circular-line-right"></div>' : '', "\n");
    };
    var errorIconHtml = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n';
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var setContent = function(icon, params) {
        if (!params.icon && !params.iconHtml) {
            return;
        }
        var oldContent = icon.innerHTML;
        var newContent = '';
        if (params.iconHtml) {
            newContent = iconContent(params.iconHtml);
        } else if (params.icon === 'success') {
            newContent = successIconHtml(params);
            oldContent = oldContent.replace(/ style=".*?"/g, ''); // undo adjustSuccessIconBackgroundColor()
        } else if (params.icon === 'error') {
            newContent = errorIconHtml;
        } else if (params.icon) {
            var defaultIconHtml = {
                question: '?',
                warning: '!',
                info: 'i'
            };
            newContent = iconContent(defaultIconHtml[params.icon]);
        }
        if (oldContent.trim() !== newContent.trim()) {
            setInnerHtml(icon, newContent);
        }
    };
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var setColor = function(icon, params) {
        if (!params.iconColor) {
            return;
        }
        icon.style.color = params.iconColor;
        icon.style.borderColor = params.iconColor;
        for(var _i = 0, _iter = [
            '.swal2-success-line-tip',
            '.swal2-success-line-long',
            '.swal2-x-mark-line-left',
            '.swal2-x-mark-line-right'
        ]; _i < _iter.length; _i++){
            var sel = _iter[_i];
            setStyle(icon, sel, 'background-color', params.iconColor);
        }
        setStyle(icon, '.swal2-success-ring', 'border-color', params.iconColor);
    };
    /**
   * @param {string} content
   * @returns {string}
   */ var iconContent = function(content) {
        return '<div class="'.concat(swalClasses['icon-content'], '">').concat(content, "</div>");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderImage = function(instance, params) {
        var image = getImage();
        if (!image) {
            return;
        }
        if (!params.imageUrl) {
            hide(image);
            return;
        }
        show(image, '');
        // Src, alt
        image.setAttribute('src', params.imageUrl);
        image.setAttribute('alt', params.imageAlt || '');
        // Width, height
        applyNumericalStyle(image, 'width', params.imageWidth);
        applyNumericalStyle(image, 'height', params.imageHeight);
        // Class
        image.className = swalClasses.image;
        applyCustomClass(image, params, 'image');
    };
    var dragging = false;
    var mousedownX = 0;
    var mousedownY = 0;
    var initialX = 0;
    var initialY = 0;
    /**
   * @param {HTMLElement} popup
   */ var addDraggableListeners = function(popup) {
        popup.addEventListener('mousedown', down);
        document.body.addEventListener('mousemove', move);
        popup.addEventListener('mouseup', up);
        popup.addEventListener('touchstart', down);
        document.body.addEventListener('touchmove', move);
        popup.addEventListener('touchend', up);
    };
    /**
   * @param {HTMLElement} popup
   */ var removeDraggableListeners = function(popup) {
        popup.removeEventListener('mousedown', down);
        document.body.removeEventListener('mousemove', move);
        popup.removeEventListener('mouseup', up);
        popup.removeEventListener('touchstart', down);
        document.body.removeEventListener('touchmove', move);
        popup.removeEventListener('touchend', up);
    };
    /**
   * @param {MouseEvent | TouchEvent} event
   */ var down = function(event) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        var icon = getIcon();
        if (event.target === popup || icon && icon.contains(/** @type {HTMLElement} */ event.target)) {
            dragging = true;
            var clientXY = getClientXY(event);
            mousedownX = clientXY.clientX;
            mousedownY = clientXY.clientY;
            initialX = parseInt(popup.style.insetInlineStart) || 0;
            initialY = parseInt(popup.style.insetBlockStart) || 0;
            addClass(popup, 'swal2-dragging');
        }
    };
    /**
   * @param {MouseEvent | TouchEvent} event
   */ var move = function(event) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        if (dragging) {
            var _getClientXY = getClientXY(event), clientX = _getClientXY.clientX, clientY = _getClientXY.clientY;
            var deltaX = clientX - mousedownX;
            // In RTL mode, negate the horizontal delta since insetInlineStart refers to the right edge
            popup.style.insetInlineStart = "".concat(initialX + (globalState.isRTL ? -deltaX : deltaX), "px");
            popup.style.insetBlockStart = "".concat(initialY + (clientY - mousedownY), "px");
        }
    };
    var up = function() {
        var popup = getPopup();
        dragging = false;
        removeClass(popup, 'swal2-dragging');
    };
    /**
   * @param {MouseEvent | TouchEvent} event
   * @returns {{ clientX: number, clientY: number }}
   */ var getClientXY = function(event) {
        var clientX = 0, clientY = 0;
        if (event.type.startsWith('mouse')) {
            clientX = /** @type {MouseEvent} */ event.clientX;
            clientY = /** @type {MouseEvent} */ event.clientY;
        } else if (event.type.startsWith('touch')) {
            clientX = /** @type {TouchEvent} */ event.touches[0].clientX;
            clientY = /** @type {TouchEvent} */ event.touches[0].clientY;
        }
        return {
            clientX: clientX,
            clientY: clientY
        };
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderPopup = function(instance, params) {
        var container = getContainer();
        var popup = getPopup();
        if (!container || !popup) {
            return;
        }
        // Width
        // https://github.com/sweetalert2/sweetalert2/issues/2170
        if (params.toast) {
            applyNumericalStyle(container, 'width', params.width);
            popup.style.width = '100%';
            var loader = getLoader();
            if (loader) {
                popup.insertBefore(loader, getIcon());
            }
        } else {
            applyNumericalStyle(popup, 'width', params.width);
        }
        // Padding
        applyNumericalStyle(popup, 'padding', params.padding);
        // Color
        if (params.color) {
            popup.style.color = params.color;
        }
        // Background
        if (params.background) {
            popup.style.background = params.background;
        }
        hide(getValidationMessage());
        // Classes
        addClasses$1(popup, params);
        if (params.draggable && !params.toast) {
            addClass(popup, swalClasses.draggable);
            addDraggableListeners(popup);
        } else {
            removeClass(popup, swalClasses.draggable);
            removeDraggableListeners(popup);
        }
    };
    /**
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} params
   */ var addClasses$1 = function(popup, params) {
        var showClass = params.showClass || {};
        // Default Class + showClass when updating Swal.update({})
        popup.className = "".concat(swalClasses.popup, " ").concat(isVisible$1(popup) ? showClass.popup : '');
        if (params.toast) {
            addClass([
                document.documentElement,
                document.body
            ], swalClasses['toast-shown']);
            addClass(popup, swalClasses.toast);
        } else {
            addClass(popup, swalClasses.modal);
        }
        // Custom class
        applyCustomClass(popup, params, 'popup');
        // TODO: remove in the next major
        if (typeof params.customClass === 'string') {
            addClass(popup, params.customClass);
        }
        // Icon class (#1842)
        if (params.icon) {
            addClass(popup, swalClasses["icon-".concat(params.icon)]);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderProgressSteps = function(instance, params) {
        var progressStepsContainer = getProgressSteps();
        if (!progressStepsContainer) {
            return;
        }
        var progressSteps = params.progressSteps, currentProgressStep = params.currentProgressStep;
        if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
            hide(progressStepsContainer);
            return;
        }
        show(progressStepsContainer);
        progressStepsContainer.textContent = '';
        if (currentProgressStep >= progressSteps.length) {
            warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
        }
        progressSteps.forEach(function(step, index) {
            var stepEl = createStepElement(step);
            progressStepsContainer.appendChild(stepEl);
            if (index === currentProgressStep) {
                addClass(stepEl, swalClasses['active-progress-step']);
            }
            if (index !== progressSteps.length - 1) {
                var lineEl = createLineElement(params);
                progressStepsContainer.appendChild(lineEl);
            }
        });
    };
    /**
   * @param {string} step
   * @returns {HTMLLIElement}
   */ var createStepElement = function(step) {
        var stepEl = document.createElement('li');
        addClass(stepEl, swalClasses['progress-step']);
        setInnerHtml(stepEl, step);
        return stepEl;
    };
    /**
   * @param {SweetAlertOptions} params
   * @returns {HTMLLIElement}
   */ var createLineElement = function(params) {
        var lineEl = document.createElement('li');
        addClass(lineEl, swalClasses['progress-step-line']);
        if (params.progressStepsDistance) {
            applyNumericalStyle(lineEl, 'width', params.progressStepsDistance);
        }
        return lineEl;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderTitle = function(instance, params) {
        var title = getTitle();
        if (!title) {
            return;
        }
        showWhenInnerHtmlPresent(title);
        toggle(title, Boolean(params.title || params.titleText), 'block');
        if (params.title) {
            parseHtmlToContainer(params.title, title);
        }
        if (params.titleText) {
            title.innerText = params.titleText;
        }
        // Custom class
        applyCustomClass(title, params, 'title');
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var render = function(instance, params) {
        var _globalState$eventEmi;
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderProgressSteps(instance, params);
        renderIcon(instance, params);
        renderImage(instance, params);
        renderTitle(instance, params);
        renderCloseButton(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);
        var popup = getPopup();
        if (typeof params.didRender === 'function' && popup) {
            params.didRender(popup);
        }
        (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('didRender', popup);
    };
    /*
   * Global function to determine if SweetAlert2 popup is shown
   */ var isVisible = function() {
        return isVisible$1(getPopup());
    };
    /*
   * Global function to click 'Confirm' button
   */ var clickConfirm = function() {
        var _dom$getConfirmButton;
        return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
    };
    /*
   * Global function to click 'Deny' button
   */ var clickDeny = function() {
        var _dom$getDenyButton;
        return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
    };
    /*
   * Global function to click 'Cancel' button
   */ var clickCancel = function() {
        var _dom$getCancelButton;
        return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
    };
    /** @type {Record<DismissReason, DismissReason>} */ var DismissReason = Object.freeze({
        cancel: 'cancel',
        backdrop: 'backdrop',
        close: 'close',
        esc: 'esc',
        timer: 'timer'
    });
    /**
   * @param {GlobalState} globalState
   */ var removeKeydownHandler = function(globalState) {
        if (globalState.keydownTarget && globalState.keydownHandlerAdded && globalState.keydownHandler) {
            var handler = /** @type {EventListenerOrEventListenerObject} */ /** @type {unknown} */ globalState.keydownHandler;
            globalState.keydownTarget.removeEventListener('keydown', handler, {
                capture: globalState.keydownListenerCapture
            });
            globalState.keydownHandlerAdded = false;
        }
    };
    /**
   * @param {GlobalState} globalState
   * @param {SweetAlertOptions} innerParams
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var addKeydownHandler = function(globalState, innerParams, dismissWith) {
        removeKeydownHandler(globalState);
        if (!innerParams.toast) {
            /** @type {(this: HTMLElement, event: KeyboardEvent) => void} */ var handler = function(e) {
                return keydownHandler(innerParams, e, dismissWith);
            };
            globalState.keydownHandler = handler;
            var target = innerParams.keydownListenerCapture ? window : getPopup();
            if (target) {
                globalState.keydownTarget = target;
                globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
                var eventHandler = /** @type {EventListenerOrEventListenerObject} */ /** @type {unknown} */ handler;
                globalState.keydownTarget.addEventListener('keydown', eventHandler, {
                    capture: globalState.keydownListenerCapture
                });
                globalState.keydownHandlerAdded = true;
            }
        }
    };
    /**
   * @param {number} index
   * @param {number} increment
   */ var setFocus = function(index, increment) {
        var _dom$getPopup;
        var focusableElements = getFocusableElements();
        // search for visible elements and select the next possible match
        if (focusableElements.length) {
            index = index + increment;
            // shift + tab when .swal2-popup is focused
            if (index === -2) {
                index = focusableElements.length - 1;
            }
            // rollover to first item
            if (index === focusableElements.length) {
                index = 0;
            // go to last item
            } else if (index === -1) {
                index = focusableElements.length - 1;
            }
            focusableElements[index].focus();
            return;
        }
        // no visible focusable elements, focus the popup
        (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
    };
    var arrowKeysNextButton = [
        'ArrowRight',
        'ArrowDown'
    ];
    var arrowKeysPreviousButton = [
        'ArrowLeft',
        'ArrowUp'
    ];
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {KeyboardEvent} event
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var keydownHandler = function(innerParams, event, dismissWith) {
        if (!innerParams) {
            return; // This instance has already been destroyed
        }
        // Ignore keydown during IME composition
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition
        // https://github.com/sweetalert2/sweetalert2/issues/720
        // https://github.com/sweetalert2/sweetalert2/issues/2406
        if (event.isComposing || event.keyCode === 229) {
            return;
        }
        if (innerParams.stopKeydownPropagation) {
            event.stopPropagation();
        }
        // ENTER
        if (event.key === 'Enter') {
            handleEnter(event, innerParams);
        } else if (event.key === 'Tab') {
            handleTab(event);
        } else if (_to_consumable_array._(arrowKeysNextButton).concat(_to_consumable_array._(arrowKeysPreviousButton)).includes(event.key)) {
            handleArrows(event.key);
        } else if (event.key === 'Escape') {
            handleEsc(event, innerParams, dismissWith);
        }
    };
    /**
   * @param {KeyboardEvent} event
   * @param {SweetAlertOptions} innerParams
   */ var handleEnter = function(event, innerParams) {
        // https://github.com/sweetalert2/sweetalert2/issues/2386
        if (!callIfFunction(innerParams.allowEnterKey)) {
            return;
        }
        var popup = getPopup();
        if (!popup || !innerParams.input) {
            return;
        }
        var input = getInput$1(popup, innerParams.input);
        if (event.target && input && _instanceof._(event.target, HTMLElement) && event.target.outerHTML === input.outerHTML) {
            if ([
                'textarea',
                'file'
            ].includes(innerParams.input)) {
                return; // do not submit
            }
            clickConfirm();
            event.preventDefault();
        }
    };
    /**
   * @param {KeyboardEvent} event
   */ var handleTab = function(event) {
        var targetElement = event.target;
        var focusableElements = getFocusableElements();
        var btnIndex = -1;
        for(var i = 0; i < focusableElements.length; i++){
            if (targetElement === focusableElements[i]) {
                btnIndex = i;
                break;
            }
        }
        // Cycle to the next button
        if (!event.shiftKey) {
            setFocus(btnIndex, 1);
        } else {
            setFocus(btnIndex, -1);
        }
        event.stopPropagation();
        event.preventDefault();
    };
    /**
   * @param {string} key
   */ var handleArrows = function(key) {
        var actions = getActions();
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!actions || !confirmButton || !denyButton || !cancelButton) {
            return;
        }
        /** @type HTMLElement[] */ var buttons = [
            confirmButton,
            denyButton,
            cancelButton
        ];
        if (_instanceof._(document.activeElement, HTMLElement) && !buttons.includes(document.activeElement)) {
            return;
        }
        var sibling = arrowKeysNextButton.includes(key) ? 'nextElementSibling' : 'previousElementSibling';
        var buttonToFocus = document.activeElement;
        if (!buttonToFocus) {
            return;
        }
        for(var i = 0; i < actions.children.length; i++){
            buttonToFocus = buttonToFocus[sibling];
            if (!buttonToFocus) {
                return;
            }
            if (_instanceof._(buttonToFocus, HTMLButtonElement) && isVisible$1(buttonToFocus)) {
                break;
            }
        }
        if (_instanceof._(buttonToFocus, HTMLButtonElement)) {
            buttonToFocus.focus();
        }
    };
    /**
   * @param {KeyboardEvent} event
   * @param {SweetAlertOptions} innerParams
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var handleEsc = function(event, innerParams, dismissWith) {
        event.preventDefault();
        if (callIfFunction(innerParams.allowEscapeKey)) {
            dismissWith(DismissReason.esc);
        }
    };
    /**
   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */ var privateMethods = {
        swalPromiseResolve: new WeakMap(),
        swalPromiseReject: new WeakMap()
    };
    // From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
    // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
    // elements not within the active modal dialog will not be surfaced if a user opens a screen
    // readers list of elements (headings, form controls, landmarks, etc.) in the document.
    var setAriaHidden = function() {
        var container = getContainer();
        var bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach(function(el) {
            if (el.contains(container)) {
                return;
            }
            if (el.hasAttribute('aria-hidden')) {
                el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden') || '');
            }
            el.setAttribute('aria-hidden', 'true');
        });
    };
    var unsetAriaHidden = function() {
        var bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach(function(el) {
            if (el.hasAttribute('data-previous-aria-hidden')) {
                el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden') || '');
                el.removeAttribute('data-previous-aria-hidden');
            } else {
                el.removeAttribute('aria-hidden');
            }
        });
    };
    // @ts-ignore
    var isSafariOrIOS = typeof window !== 'undefined' && Boolean(window.GestureEvent); // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394
    /**
   * Fix iOS scrolling
   * http://stackoverflow.com/q/39626302
   */ var iOSfix = function() {
        if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
            var offset = document.body.scrollTop;
            document.body.style.top = "".concat(offset * -1, "px");
            addClass(document.body, swalClasses.iosfix);
            lockBodyScroll();
        }
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1246
   */ var lockBodyScroll = function() {
        var container = getContainer();
        if (!container) {
            return;
        }
        /** @type {boolean} */ var preventTouchMove;
        /**
     * @param {TouchEvent} event
     */ container.ontouchstart = function(event) {
            preventTouchMove = shouldPreventTouchMove(event);
        };
        /**
     * @param {TouchEvent} event
     */ container.ontouchmove = function(event) {
            if (preventTouchMove) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
    };
    /**
   * @param {TouchEvent} event
   * @returns {boolean}
   */ var shouldPreventTouchMove = function(event) {
        var target = event.target;
        var container = getContainer();
        var htmlContainer = getHtmlContainer();
        if (!container || !htmlContainer) {
            return false;
        }
        if (isStylus(event) || isZoom(event)) {
            return false;
        }
        if (target === container) {
            return true;
        }
        if (!isScrollable(container) && _instanceof._(target, HTMLElement) && !selfOrParentIsScrollable(target, htmlContainer) && // #2823
        target.tagName !== 'INPUT' && // #1603
        target.tagName !== 'TEXTAREA' && // #2266
        !(isScrollable(htmlContainer) && // #1944
        htmlContainer.contains(target))) {
            return true;
        }
        return false;
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1786
   *
   * @param {TouchEvent} event
   * @returns {boolean}
   */ var isStylus = function(event) {
        return Boolean(event.touches && event.touches.length && // @ts-ignore - touchType is not a standard property
        event.touches[0].touchType === 'stylus');
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1891
   *
   * @param {TouchEvent} event
   * @returns {boolean}
   */ var isZoom = function(event) {
        return event.touches && event.touches.length > 1;
    };
    var undoIOSfix = function() {
        if (hasClass(document.body, swalClasses.iosfix)) {
            var offset = parseInt(document.body.style.top, 10);
            removeClass(document.body, swalClasses.iosfix);
            document.body.style.top = '';
            document.body.scrollTop = offset * -1;
        }
    };
    /**
   * Measure scrollbar width for padding body during modal show/hide
   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js
   *
   * @returns {number}
   */ var measureScrollbar = function() {
        var scrollDiv = document.createElement('div');
        scrollDiv.className = swalClasses['scrollbar-measure'];
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    };
    /**
   * Remember state in cases where opening and handling a modal will fiddle with it.
   * @type {number | null}
   */ var previousBodyPadding = null;
    /**
   * @param {string} initialBodyOverflow
   */ var replaceScrollbarWithPadding = function(initialBodyOverflow) {
        // for queues, do not do this more than once
        if (previousBodyPadding !== null) {
            return;
        }
        // if the body has overflow
        if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === 'scroll' // https://github.com/sweetalert2/sweetalert2/issues/2663
        ) {
            // add padding so the content doesn't shift after removal of scrollbar
            previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
            document.body.style.paddingRight = "".concat(previousBodyPadding + measureScrollbar(), "px");
        }
    };
    var undoReplaceScrollbarWithPadding = function() {
        if (previousBodyPadding !== null) {
            document.body.style.paddingRight = "".concat(previousBodyPadding, "px");
            previousBodyPadding = null;
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} container
   * @param {boolean} returnFocus
   * @param {(() => void) | undefined} didClose
   */ function removePopupAndResetState(instance, container, returnFocus, didClose) {
        if (isToast()) {
            triggerDidCloseAndDispose(instance, didClose);
        } else {
            restoreActiveElement(returnFocus).then(function() {
                return triggerDidCloseAndDispose(instance, didClose);
            });
            removeKeydownHandler(globalState);
        }
        // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
        // for some reason removing the container in Safari will scroll the document to bottom
        if (isSafariOrIOS) {
            container.setAttribute('style', 'display:none !important');
            container.removeAttribute('class');
            container.innerHTML = '';
        } else {
            container.remove();
        }
        if (isModal()) {
            undoReplaceScrollbarWithPadding();
            undoIOSfix();
            unsetAriaHidden();
        }
        removeBodyClasses();
    }
    /**
   * Remove SweetAlert2 classes from body
   */ function removeBodyClasses() {
        removeClass([
            document.documentElement,
            document.body
        ], [
            swalClasses.shown,
            swalClasses['height-auto'],
            swalClasses['no-backdrop'],
            swalClasses['toast-shown']
        ]);
    }
    /**
   * Instance method to close sweetAlert
   *
   * @param {SweetAlertResult | undefined} resolveValue
   * @this {SweetAlert}
   */ function close(resolveValue) {
        resolveValue = prepareResolveValue(resolveValue);
        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        var didClose = triggerClosePopup(this);
        if (this.isAwaitingPromise) {
            // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
            if (!resolveValue.isDismissed) {
                handleAwaitingPromise(this);
                swalPromiseResolve(resolveValue);
            }
        } else if (didClose) {
            // Resolve Swal promise
            swalPromiseResolve(resolveValue);
        }
    }
    /**
   * @param {SweetAlert} instance
   * @returns {boolean}
   */ var triggerClosePopup = function(instance) {
        var popup = getPopup();
        if (!popup) {
            return false;
        }
        var innerParams = privateProps.innerParams.get(instance);
        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
            return false;
        }
        removeClass(popup, innerParams.showClass.popup);
        addClass(popup, innerParams.hideClass.popup);
        var backdrop = getContainer();
        removeClass(backdrop, innerParams.showClass.backdrop);
        addClass(backdrop, innerParams.hideClass.backdrop);
        handlePopupAnimation(instance, popup, innerParams);
        return true;
    };
    /**
   * @param {Error | string} error
   * @this {SweetAlert}
   */ function rejectPromise(error) {
        var _$rejectPromise = privateMethods.swalPromiseReject.get(this);
        handleAwaitingPromise(this);
        if (_$rejectPromise) {
            // Reject Swal promise
            _$rejectPromise(error);
        }
    }
    /**
   * @param {SweetAlert} instance
   */ var handleAwaitingPromise = function(instance) {
        if (instance.isAwaitingPromise) {
            // @ts-ignore
            delete instance.isAwaitingPromise;
            // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
            if (!privateProps.innerParams.get(instance)) {
                instance._destroy();
            }
        }
    };
    /**
   * @param {SweetAlertResult | undefined} resolveValue
   * @returns {SweetAlertResult}
   */ var prepareResolveValue = function(resolveValue) {
        // When user calls Swal.close()
        if (typeof resolveValue === 'undefined') {
            return {
                isConfirmed: false,
                isDenied: false,
                isDismissed: true
            };
        }
        return Object.assign({
            isConfirmed: false,
            isDenied: false,
            isDismissed: false
        }, resolveValue);
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} innerParams
   */ var handlePopupAnimation = function(instance, popup, innerParams) {
        var _globalState$eventEmi;
        var container = getContainer();
        // If animation is supported, animate
        var animationIsSupported = hasCssAnimation(popup);
        if (typeof innerParams.willClose === 'function') {
            innerParams.willClose(popup);
        }
        (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('willClose', popup);
        if (animationIsSupported && container) {
            animatePopup(instance, popup, container, Boolean(innerParams.returnFocus), innerParams.didClose);
        } else if (container) {
            // Otherwise, remove immediately
            removePopupAndResetState(instance, container, Boolean(innerParams.returnFocus), innerParams.didClose);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} popup
   * @param {HTMLElement} container
   * @param {boolean} returnFocus
   * @param {(() => void) | undefined} didClose
   */ var animatePopup = function(instance, popup, container, returnFocus, didClose) {
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
        /**
     * @param {AnimationEvent | TransitionEvent} e
     */ var swalCloseAnimationFinished = function swalCloseAnimationFinished1(e) {
            if (e.target === popup) {
                var _globalState$swalClos;
                (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
                delete globalState.swalCloseEventFinishedCallback;
                popup.removeEventListener('animationend', swalCloseAnimationFinished);
                popup.removeEventListener('transitionend', swalCloseAnimationFinished);
            }
        };
        popup.addEventListener('animationend', swalCloseAnimationFinished);
        popup.addEventListener('transitionend', swalCloseAnimationFinished);
    };
    /**
   * @param {SweetAlert} instance
   * @param {(() => void) | undefined} didClose
   */ var triggerDidCloseAndDispose = function(instance, didClose) {
        setTimeout(function() {
            var _globalState$eventEmi2;
            if (typeof didClose === 'function') {
                didClose.bind(instance.params)();
            }
            (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit('didClose');
            // instance might have been destroyed already
            if (instance._destroy) {
                instance._destroy();
            }
        });
    };
    /**
   * Shows loader (spinner), this is useful with AJAX requests.
   * By default the loader be shown instead of the "Confirm" button.
   *
   * @param {HTMLButtonElement | null} [buttonToReplace]
   */ var showLoading = function(buttonToReplace) {
        var popup = getPopup();
        if (!popup) {
            new Swal();
        }
        popup = getPopup();
        if (!popup) {
            return;
        }
        var loader = getLoader();
        if (isToast()) {
            hide(getIcon());
        } else {
            replaceButton(popup, buttonToReplace);
        }
        show(loader);
        popup.setAttribute('data-loading', 'true');
        popup.setAttribute('aria-busy', 'true');
        popup.focus();
    };
    /**
   * @param {HTMLElement} popup
   * @param {HTMLButtonElement | null} [buttonToReplace]
   */ var replaceButton = function(popup, buttonToReplace) {
        var actions = getActions();
        var loader = getLoader();
        if (!actions || !loader) {
            return;
        }
        if (!buttonToReplace && isVisible$1(getConfirmButton())) {
            buttonToReplace = getConfirmButton();
        }
        show(actions);
        if (buttonToReplace) {
            hide(buttonToReplace);
            loader.setAttribute('data-button-to-replace', buttonToReplace.className);
            actions.insertBefore(loader, buttonToReplace);
        }
        addClass([
            popup,
            actions
        ], swalClasses.loading);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputOptionsAndValue = function(instance, params) {
        if (params.input === 'select' || params.input === 'radio') {
            handleInputOptions(instance, params);
        } else if ([
            'text',
            'email',
            'number',
            'tel',
            'textarea'
        ].some(function(i) {
            return i === params.input;
        }) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
            showLoading(getConfirmButton());
            handleInputValue(instance, params);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} innerParams
   * @returns {SweetAlertInputValue}
   */ var getInputValue = function(instance, innerParams) {
        var input = instance.getInput();
        if (!input) {
            return null;
        }
        switch(innerParams.input){
            case 'checkbox':
                return getCheckboxValue(input);
            case 'radio':
                return getRadioValue(input);
            case 'file':
                return getFileValue(input);
            default:
                return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {number}
   */ var getCheckboxValue = function(input) {
        return input.checked ? 1 : 0;
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {string | null}
   */ var getRadioValue = function(input) {
        return input.checked ? input.value : null;
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {FileList | File | null}
   */ var getFileValue = function(input) {
        return input.files && input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputOptions = function(instance, params) {
        var popup = getPopup();
        if (!popup) {
            return;
        }
        /**
     * @param {*} inputOptions
     */ var processInputOptions = function(inputOptions) {
            if (params.input === 'select') {
                populateSelectOptions(popup, formatInputOptions(inputOptions), params);
            } else if (params.input === 'radio') {
                populateRadioOptions(popup, formatInputOptions(inputOptions), params);
            }
        };
        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
            showLoading(getConfirmButton());
            asPromise(params.inputOptions).then(function(inputOptions) {
                instance.hideLoading();
                processInputOptions(inputOptions);
            });
        } else if (_type_of._(params.inputOptions) === 'object') {
            processInputOptions(params.inputOptions);
        } else {
            error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_type_of._(params.inputOptions)));
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputValue = function(instance, params) {
        var input = instance.getInput();
        if (!input) {
            return;
        }
        hide(input);
        asPromise(params.inputValue).then(function(inputValue) {
            input.value = params.input === 'number' ? "".concat(parseFloat(inputValue) || 0) : "".concat(inputValue);
            show(input);
            input.focus();
            instance.hideLoading();
        }).catch(function(err) {
            error("Error in inputValue promise: ".concat(err));
            input.value = '';
            show(input);
            input.focus();
            instance.hideLoading();
        });
    };
    /**
   * @param {HTMLElement} popup
   * @param {InputOptionFlattened[]} inputOptions
   * @param {SweetAlertOptions} params
   */ function populateSelectOptions(popup, inputOptions, params) {
        var select = getDirectChildByClass(popup, swalClasses.select);
        if (!select) {
            return;
        }
        /**
     * @param {HTMLElement} parent
     * @param {string} optionLabel
     * @param {string} optionValue
     */ var renderOption = function(parent, optionLabel, optionValue) {
            var option = document.createElement('option');
            option.value = optionValue;
            setInnerHtml(option, optionLabel);
            option.selected = isSelected(optionValue, params.inputValue);
            parent.appendChild(option);
        };
        inputOptions.forEach(function(inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1];
            // <optgroup> spec:
            // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
            // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
            // check whether this is a <optgroup>
            if (Array.isArray(optionLabel)) {
                // if it is an array, then it is an <optgroup>
                var optgroup = document.createElement('optgroup');
                optgroup.label = optionValue;
                optgroup.disabled = false; // not configurable for now
                select.appendChild(optgroup);
                optionLabel.forEach(function(o) {
                    return renderOption(optgroup, o[1], o[0]);
                });
            } else {
                // case of <option>
                renderOption(select, optionLabel, optionValue);
            }
        });
        select.focus();
    }
    /**
   * @param {HTMLElement} popup
   * @param {InputOptionFlattened[]} inputOptions
   * @param {SweetAlertOptions} params
   */ function populateRadioOptions(popup, inputOptions, params) {
        var radio = getDirectChildByClass(popup, swalClasses.radio);
        if (!radio) {
            return;
        }
        inputOptions.forEach(function(inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement('input');
            var radioLabelElement = document.createElement('label');
            radioInput.type = 'radio';
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;
            if (isSelected(radioValue, params.inputValue)) {
                radioInput.checked = true;
            }
            var label = document.createElement('span');
            setInnerHtml(label, radioLabel);
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio.appendChild(radioLabelElement);
        });
        var radios = radio.querySelectorAll('input');
        if (radios.length) {
            radios[0].focus();
        }
    }
    /**
   * Converts `inputOptions` into an array of `[value, label]`s
   *
   * @param {*} inputOptions
   * @typedef {string[]} InputOptionFlattened
   * @returns {InputOptionFlattened[]}
   */ var formatInputOptions = function(inputOptions) {
        /** @type {InputOptionFlattened[]} */ var result = [];
        if (_instanceof._(inputOptions, Map)) {
            inputOptions.forEach(function(value, key) {
                var valueFormatted = value;
                if ((typeof valueFormatted === "undefined" ? "undefined" : _type_of._(valueFormatted)) === 'object') {
                    // case of <optgroup>
                    valueFormatted = formatInputOptions(valueFormatted);
                }
                result.push([
                    key,
                    valueFormatted
                ]);
            });
        } else {
            Object.keys(inputOptions).forEach(function(key) {
                var valueFormatted = inputOptions[key];
                if ((typeof valueFormatted === "undefined" ? "undefined" : _type_of._(valueFormatted)) === 'object') {
                    // case of <optgroup>
                    valueFormatted = formatInputOptions(valueFormatted);
                }
                result.push([
                    key,
                    valueFormatted
                ]);
            });
        }
        return result;
    };
    /**
   * @param {string} optionValue
   * @param {SweetAlertInputValue} inputValue
   * @returns {boolean}
   */ var isSelected = function(optionValue, inputValue) {
        return Boolean(inputValue) && inputValue !== null && inputValue !== undefined && inputValue.toString() === optionValue.toString();
    };
    /**
   * @param {SweetAlert} instance
   */ var handleConfirmButtonClick = function(instance) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.input) {
            handleConfirmOrDenyWithInput(instance, 'confirm');
        } else {
            confirm(instance, true);
        }
    };
    /**
   * @param {SweetAlert} instance
   */ var handleDenyButtonClick = function(instance) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.returnInputValueOnDeny) {
            handleConfirmOrDenyWithInput(instance, 'deny');
        } else {
            deny(instance, false);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var handleCancelButtonClick = function(instance, dismissWith) {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
    };
    /**
   * @param {SweetAlert} instance
   * @param {'confirm' | 'deny'} type
   */ var handleConfirmOrDenyWithInput = function(instance, type) {
        var innerParams = privateProps.innerParams.get(instance);
        if (!innerParams.input) {
            error('The "input" parameter is needed to be set when using returnInputValueOn'.concat(capitalizeFirstLetter(type)));
            return;
        }
        var input = instance.getInput();
        var inputValue = getInputValue(instance, innerParams);
        if (innerParams.inputValidator) {
            handleInputValidator(instance, inputValue, type);
        } else if (input && !input.checkValidity()) {
            instance.enableButtons();
            instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
        } else if (type === 'deny') {
            deny(instance, inputValue);
        } else {
            confirm(instance, inputValue);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertInputValue} inputValue
   * @param {'confirm' | 'deny'} type
   */ var handleInputValidator = function(instance, inputValue, type) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableInput();
        var validationPromise = Promise.resolve().then(function() {
            return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
        });
        validationPromise.then(function(validationMessage) {
            instance.enableButtons();
            instance.enableInput();
            if (validationMessage) {
                instance.showValidationMessage(validationMessage);
            } else if (type === 'deny') {
                deny(instance, inputValue);
            } else {
                confirm(instance, inputValue);
            }
        });
    };
    /**
   * @param {SweetAlert} instance
   * @param {*} value
   */ var deny = function(instance, value) {
        var innerParams = privateProps.innerParams.get(instance);
        if (innerParams.showLoaderOnDeny) {
            showLoading(getDenyButton());
        }
        if (innerParams.preDeny) {
            instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
            var preDenyPromise = Promise.resolve().then(function() {
                return asPromise(innerParams.preDeny(value, innerParams.validationMessage));
            });
            preDenyPromise.then(function(preDenyValue) {
                if (preDenyValue === false) {
                    instance.hideLoading();
                    handleAwaitingPromise(instance);
                } else {
                    instance.close(/** @type SweetAlertResult */ {
                        isDenied: true,
                        value: typeof preDenyValue === 'undefined' ? value : preDenyValue
                    });
                }
            }).catch(function(error) {
                return rejectWith(instance, error);
            });
        } else {
            instance.close(/** @type SweetAlertResult */ {
                isDenied: true,
                value: value
            });
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {*} value
   */ var succeedWith = function(instance, value) {
        instance.close(/** @type SweetAlertResult */ {
            isConfirmed: true,
            value: value
        });
    };
    /**
   *
   * @param {SweetAlert} instance
   * @param {string} error
   */ var rejectWith = function(instance, error) {
        instance.rejectPromise(error);
    };
    /**
   *
   * @param {SweetAlert} instance
   * @param {*} value
   */ var confirm = function(instance, value) {
        var innerParams = privateProps.innerParams.get(instance);
        if (innerParams.showLoaderOnConfirm) {
            showLoading();
        }
        if (innerParams.preConfirm) {
            instance.resetValidationMessage();
            instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
            var preConfirmPromise = Promise.resolve().then(function() {
                return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
            });
            preConfirmPromise.then(function(preConfirmValue) {
                if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
                    instance.hideLoading();
                    handleAwaitingPromise(instance);
                } else {
                    succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
                }
            }).catch(function(error) {
                return rejectWith(instance, error);
            });
        } else {
            succeedWith(instance, value);
        }
    };
    /**
   * Hides loader and shows back the button which was hidden by .showLoading()
   * @this {SweetAlert}
   */ function hideLoading() {
        // do nothing if popup is closed
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
            return;
        }
        var domCache = privateProps.domCache.get(this);
        hide(domCache.loader);
        if (isToast()) {
            if (innerParams.icon) {
                show(getIcon());
            }
        } else {
            showRelatedButton(domCache);
        }
        removeClass([
            domCache.popup,
            domCache.actions
        ], swalClasses.loading);
        domCache.popup.removeAttribute('aria-busy');
        domCache.popup.removeAttribute('data-loading');
        domCache.confirmButton.disabled = false;
        domCache.denyButton.disabled = false;
        domCache.cancelButton.disabled = false;
    }
    /**
   * @param {DomCache} domCache
   */ var showRelatedButton = function(domCache) {
        var dataButtonToReplace = domCache.loader.getAttribute('data-button-to-replace');
        var buttonToReplace = dataButtonToReplace ? domCache.popup.getElementsByClassName(dataButtonToReplace) : [];
        if (buttonToReplace.length) {
            show(/** @type {HTMLElement} */ buttonToReplace[0], 'inline-block');
        } else if (allButtonsAreHidden()) {
            hide(domCache.actions);
        }
    };
    /**
   * Gets the input DOM node, this method works with input parameter.
   *
   * @returns {HTMLInputElement | null}
   * @this {SweetAlert}
   */ function getInput() {
        var innerParams = privateProps.innerParams.get(this);
        var domCache = privateProps.domCache.get(this);
        if (!domCache) {
            return null;
        }
        return getInput$1(domCache.popup, innerParams.input);
    }
    /**
   * @param {SweetAlert} instance
   * @param {string[]} buttons
   * @param {boolean} disabled
   */ function setButtonsDisabled(instance, buttons, disabled) {
        var domCache = privateProps.domCache.get(instance);
        buttons.forEach(function(button) {
            domCache[button].disabled = disabled;
        });
    }
    /**
   * @param {HTMLInputElement | null} input
   * @param {boolean} disabled
   */ function setInputDisabled(input, disabled) {
        var popup = getPopup();
        if (!popup || !input) {
            return;
        }
        if (input.type === 'radio') {
            /** @type {NodeListOf<HTMLInputElement>} */ var radios = popup.querySelectorAll('[name="'.concat(swalClasses.radio, '"]'));
            for(var i = 0; i < radios.length; i++){
                radios[i].disabled = disabled;
            }
        } else {
            input.disabled = disabled;
        }
    }
    /**
   * Enable all the buttons
   * @this {SweetAlert}
   */ function enableButtons() {
        setButtonsDisabled(this, [
            'confirmButton',
            'denyButton',
            'cancelButton'
        ], false);
    }
    /**
   * Disable all the buttons
   * @this {SweetAlert}
   */ function disableButtons() {
        setButtonsDisabled(this, [
            'confirmButton',
            'denyButton',
            'cancelButton'
        ], true);
    }
    /**
   * Enable the input field
   * @this {SweetAlert}
   */ function enableInput() {
        setInputDisabled(this.getInput(), false);
    }
    /**
   * Disable the input field
   * @this {SweetAlert}
   */ function disableInput() {
        setInputDisabled(this.getInput(), true);
    }
    /**
   * Show block with validation message
   *
   * @param {string} error
   * @this {SweetAlert}
   */ function showValidationMessage(error) {
        var domCache = privateProps.domCache.get(this);
        var params = privateProps.innerParams.get(this);
        setInnerHtml(domCache.validationMessage, error);
        domCache.validationMessage.className = swalClasses['validation-message'];
        if (params.customClass && params.customClass.validationMessage) {
            addClass(domCache.validationMessage, params.customClass.validationMessage);
        }
        show(domCache.validationMessage);
        var input = this.getInput();
        if (input) {
            input.setAttribute('aria-invalid', 'true');
            input.setAttribute('aria-describedby', swalClasses['validation-message']);
            focusInput(input);
            addClass(input, swalClasses.inputerror);
        }
    }
    /**
   * Hide block with validation message
   *
   * @this {SweetAlert}
   */ function resetValidationMessage() {
        var domCache = privateProps.domCache.get(this);
        if (domCache.validationMessage) {
            hide(domCache.validationMessage);
        }
        var input = this.getInput();
        if (input) {
            input.removeAttribute('aria-invalid');
            input.removeAttribute('aria-describedby');
            removeClass(input, swalClasses.inputerror);
        }
    }
    var defaultParams = {
        title: '',
        titleText: '',
        text: '',
        html: '',
        footer: '',
        icon: undefined,
        iconColor: undefined,
        iconHtml: undefined,
        template: undefined,
        toast: false,
        draggable: false,
        animation: true,
        theme: 'light',
        showClass: {
            popup: 'swal2-show',
            backdrop: 'swal2-backdrop-show',
            icon: 'swal2-icon-show'
        },
        hideClass: {
            popup: 'swal2-hide',
            backdrop: 'swal2-backdrop-hide',
            icon: 'swal2-icon-hide'
        },
        customClass: {},
        target: 'body',
        color: undefined,
        backdrop: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showDenyButton: false,
        showCancelButton: false,
        preConfirm: undefined,
        preDeny: undefined,
        confirmButtonText: 'OK',
        confirmButtonAriaLabel: '',
        confirmButtonColor: undefined,
        denyButtonText: 'No',
        denyButtonAriaLabel: '',
        denyButtonColor: undefined,
        cancelButtonText: 'Cancel',
        cancelButtonAriaLabel: '',
        cancelButtonColor: undefined,
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusDeny: false,
        focusCancel: false,
        returnFocus: true,
        showCloseButton: false,
        closeButtonHtml: '&times;',
        closeButtonAriaLabel: 'Close this dialog',
        loaderHtml: '',
        showLoaderOnConfirm: false,
        showLoaderOnDeny: false,
        imageUrl: undefined,
        imageWidth: undefined,
        imageHeight: undefined,
        imageAlt: '',
        timer: undefined,
        timerProgressBar: false,
        width: undefined,
        padding: undefined,
        background: undefined,
        input: undefined,
        inputPlaceholder: '',
        inputLabel: '',
        inputValue: '',
        inputOptions: {},
        inputAutoFocus: true,
        inputAutoTrim: true,
        inputAttributes: {},
        inputValidator: undefined,
        returnInputValueOnDeny: false,
        validationMessage: undefined,
        grow: false,
        position: 'center',
        progressSteps: [],
        currentProgressStep: undefined,
        progressStepsDistance: undefined,
        willOpen: undefined,
        didOpen: undefined,
        didRender: undefined,
        willClose: undefined,
        didClose: undefined,
        didDestroy: undefined,
        scrollbarPadding: true,
        topLayer: false
    };
    var updatableParams = [
        'allowEscapeKey',
        'allowOutsideClick',
        'background',
        'buttonsStyling',
        'cancelButtonAriaLabel',
        'cancelButtonColor',
        'cancelButtonText',
        'closeButtonAriaLabel',
        'closeButtonHtml',
        'color',
        'confirmButtonAriaLabel',
        'confirmButtonColor',
        'confirmButtonText',
        'currentProgressStep',
        'customClass',
        'denyButtonAriaLabel',
        'denyButtonColor',
        'denyButtonText',
        'didClose',
        'didDestroy',
        'draggable',
        'footer',
        'hideClass',
        'html',
        'icon',
        'iconColor',
        'iconHtml',
        'imageAlt',
        'imageHeight',
        'imageUrl',
        'imageWidth',
        'preConfirm',
        'preDeny',
        'progressSteps',
        'returnFocus',
        'reverseButtons',
        'showCancelButton',
        'showCloseButton',
        'showConfirmButton',
        'showDenyButton',
        'text',
        'title',
        'titleText',
        'theme',
        'willClose'
    ];
    /** @type {Record<string, string | undefined>} */ var deprecatedParams = {
        allowEnterKey: undefined
    };
    var toastIncompatibleParams = [
        'allowOutsideClick',
        'allowEnterKey',
        'backdrop',
        'draggable',
        'focusConfirm',
        'focusDeny',
        'focusCancel',
        'returnFocus',
        'heightAuto',
        'keydownListenerCapture'
    ];
    /**
   * Is valid parameter
   *
   * @param {string} paramName
   * @returns {boolean}
   */ var isValidParameter = function(paramName) {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
    };
    /**
   * Is valid parameter for Swal.update() method
   *
   * @param {string} paramName
   * @returns {boolean}
   */ var isUpdatableParameter = function(paramName) {
        return updatableParams.indexOf(paramName) !== -1;
    };
    /**
   * Is deprecated parameter
   *
   * @param {string} paramName
   * @returns {string | undefined}
   */ var isDeprecatedParameter = function(paramName) {
        return deprecatedParams[paramName];
    };
    /**
   * @param {string} param
   */ var checkIfParamIsValid = function(param) {
        if (!isValidParameter(param)) {
            warn('Unknown parameter "'.concat(param, '"'));
        }
    };
    /**
   * @param {string} param
   */ var checkIfToastParamIsValid = function(param) {
        if (toastIncompatibleParams.includes(param)) {
            warn('The parameter "'.concat(param, '" is incompatible with toasts'));
        }
    };
    /**
   * @param {string} param
   */ var checkIfParamIsDeprecated = function(param) {
        var isDeprecated = isDeprecatedParameter(param);
        if (isDeprecated) {
            warnAboutDeprecation(param, isDeprecated);
        }
    };
    /**
   * Show relevant warnings for given params
   *
   * @param {SweetAlertOptions} params
   */ var showWarningsForParams = function(params) {
        if (params.backdrop === false && params.allowOutsideClick) {
            warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        }
        if (params.theme && ![
            'light',
            'dark',
            'auto',
            'minimal',
            'borderless',
            'bootstrap-4',
            'bootstrap-4-light',
            'bootstrap-4-dark',
            'bootstrap-5',
            'bootstrap-5-light',
            'bootstrap-5-dark',
            'material-ui',
            'material-ui-light',
            'material-ui-dark',
            'embed-iframe',
            'bulma',
            'bulma-light',
            'bulma-dark'
        ].includes(params.theme)) {
            warn('Invalid theme "'.concat(params.theme, '"'));
        }
        for(var param in params){
            checkIfParamIsValid(param);
            if (params.toast) {
                checkIfToastParamIsValid(param);
            }
            checkIfParamIsDeprecated(param);
        }
    };
    /**
   * Updates popup parameters.
   *
   * @this {any}
   * @param {SweetAlertOptions} params
   */ function update(params) {
        var container = getContainer();
        var popup = getPopup();
        var innerParams = privateProps.innerParams.get(this);
        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
            warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
            return;
        }
        var validUpdatableParams = filterValidParams(params);
        var updatedParams = Object.assign({}, innerParams, validUpdatableParams);
        showWarningsForParams(updatedParams);
        if (container) {
            container.dataset['swal2Theme'] = updatedParams.theme;
        }
        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
            params: {
                value: Object.assign({}, this.params, params),
                writable: false,
                enumerable: true
            }
        });
    }
    /**
   * @param {SweetAlertOptions} params
   * @returns {SweetAlertOptions}
   */ var filterValidParams = function(params) {
        /** @type {Record<string, any>} */ var validUpdatableParams = {};
        Object.keys(params).forEach(function(param) {
            if (isUpdatableParameter(param)) {
                var typedParams = /** @type {Record<string, any>} */ params;
                validUpdatableParams[param] = typedParams[param];
            } else {
                warn("Invalid parameter to update: ".concat(param));
            }
        });
        return validUpdatableParams;
    };
    /**
   * Dispose the current SweetAlert2 instance
   * @this {SweetAlert}
   */ function _destroy() {
        var _globalState$eventEmi;
        var domCache = privateProps.domCache.get(this);
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
            disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335
            return; // This instance has already been destroyed
        }
        // Check if there is another Swal closing
        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
        }
        if (typeof innerParams.didDestroy === 'function') {
            innerParams.didDestroy();
        }
        (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('didDestroy');
        disposeSwal(this);
    }
    /**
   * @param {SweetAlert} instance
   */ var disposeSwal = function(instance) {
        disposeWeakMaps(instance);
        // Unset this.params so GC will dispose it (#1569)
        // @ts-ignore
        delete instance.params;
        // Unset globalState props so GC will dispose globalState (#1569)
        delete globalState.keydownHandler;
        delete globalState.keydownTarget;
        // Unset currentInstance
        delete globalState.currentInstance;
    };
    /**
   * @param {SweetAlert} instance
   */ var disposeWeakMaps = function(instance) {
        // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335
        if (instance.isAwaitingPromise) {
            unsetWeakMaps(privateProps, instance);
            instance.isAwaitingPromise = true;
        } else {
            unsetWeakMaps(privateMethods, instance);
            unsetWeakMaps(privateProps, instance);
            // @ts-ignore
            delete instance.isAwaitingPromise;
            // Unset instance methods
            // @ts-ignore
            delete instance.disableButtons;
            // @ts-ignore
            delete instance.enableButtons;
            // @ts-ignore
            delete instance.getInput;
            // @ts-ignore
            delete instance.disableInput;
            // @ts-ignore
            delete instance.enableInput;
            // @ts-ignore
            delete instance.hideLoading;
            // @ts-ignore
            delete instance.disableLoading;
            // @ts-ignore
            delete instance.showValidationMessage;
            // @ts-ignore
            delete instance.resetValidationMessage;
            // @ts-ignore
            delete instance.close;
            // @ts-ignore
            delete instance.closePopup;
            // @ts-ignore
            delete instance.closeModal;
            // @ts-ignore
            delete instance.closeToast;
            // @ts-ignore
            delete instance.rejectPromise;
            // @ts-ignore
            delete instance.update;
            // @ts-ignore
            delete instance._destroy;
        }
    };
    /**
   * @param {Record<string, WeakMap<any, any>>} obj
   * @param {SweetAlert} instance
   */ var unsetWeakMaps = function(obj, instance) {
        for(var i in obj){
            obj[i].delete(instance);
        }
    };
    var instanceMethods = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        _destroy: _destroy,
        close: close,
        closeModal: close,
        closePopup: close,
        closeToast: close,
        disableButtons: disableButtons,
        disableInput: disableInput,
        disableLoading: hideLoading,
        enableButtons: enableButtons,
        enableInput: enableInput,
        getInput: getInput,
        handleAwaitingPromise: handleAwaitingPromise,
        hideLoading: hideLoading,
        rejectPromise: rejectPromise,
        resetValidationMessage: resetValidationMessage,
        showValidationMessage: showValidationMessage,
        update: update
    });
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var handlePopupClick = function(innerParams, domCache, dismissWith) {
        if (innerParams.toast) {
            handleToastClick(innerParams, domCache, dismissWith);
        } else {
            // Ignore click events that had mousedown on the popup but mouseup on the container
            // This can happen when the user drags a slider
            handleModalMousedown(domCache);
            // Ignore click events that had mousedown on the container but mouseup on the popup
            handleContainerMousedown(domCache);
            handleModalClick(innerParams, domCache, dismissWith);
        }
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var handleToastClick = function(innerParams, domCache, dismissWith) {
        // Closing toast by internal click
        domCache.popup.onclick = function() {
            if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
                return;
            }
            dismissWith(DismissReason.close);
        };
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @returns {boolean}
   */ var isAnyButtonShown = function(innerParams) {
        return Boolean(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
    };
    var ignoreOutsideClick = false;
    /**
   * @param {DomCache} domCache
   */ var handleModalMousedown = function(domCache) {
        domCache.popup.onmousedown = function() {
            domCache.container.onmouseup = function handleModalMousedown(e) {
                domCache.container.onmouseup = function() {};
                // We only check if the mouseup target is the container because usually it doesn't
                // have any other direct children aside of the popup
                if (e.target === domCache.container) {
                    ignoreOutsideClick = true;
                }
            };
        };
    };
    /**
   * @param {DomCache} domCache
   */ var handleContainerMousedown = function(domCache) {
        domCache.container.onmousedown = function(e) {
            // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)
            if (e.target === domCache.container) {
                e.preventDefault();
            }
            domCache.popup.onmouseup = function handleContainerMousedown(e) {
                domCache.popup.onmouseup = function() {};
                // We also need to check if the mouseup target is a child of the popup
                if (e.target === domCache.popup || _instanceof._(e.target, HTMLElement) && domCache.popup.contains(e.target)) {
                    ignoreOutsideClick = true;
                }
            };
        };
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var handleModalClick = function(innerParams, domCache, dismissWith) {
        domCache.container.onclick = function(e) {
            if (ignoreOutsideClick) {
                ignoreOutsideClick = false;
                return;
            }
            if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
                dismissWith(DismissReason.backdrop);
            }
        };
    };
    /**
   * @param {any} elem
   * @returns {boolean}
   */ var isJqueryElement = function(elem) {
        return (typeof elem === "undefined" ? "undefined" : _type_of._(elem)) === 'object' && elem.jquery;
    };
    /**
   * @param {any} elem
   * @returns {boolean}
   */ var isElement = function(elem) {
        return _instanceof._(elem, Element) || isJqueryElement(elem);
    };
    /**
   * @param {any[]} args
   * @returns {SweetAlertOptions}
   */ var argsToParams = function(args) {
        /** @type {Record<string, any>} */ var params = {};
        if (_type_of._(args[0]) === 'object' && !isElement(args[0])) {
            Object.assign(params, args[0]);
        } else {
            [
                'title',
                'html',
                'icon'
            ].forEach(function(name, index) {
                var arg = args[index];
                if (typeof arg === 'string' || isElement(arg)) {
                    params[name] = arg;
                } else if (arg !== undefined) {
                    error("Unexpected type of ".concat(name, '! Expected "string" or "Element", got ').concat(typeof arg === "undefined" ? "undefined" : _type_of._(arg)));
                }
            });
        }
        return params;
    };
    /**
   * Main method to create a new SweetAlert2 popup
   *
   * @this {new (...args: any[]) => any}
   * @param  {...SweetAlertOptions} args
   * @returns {Promise<SweetAlertResult>}
   */ function fire() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _construct._(this, _to_consumable_array._(args));
    }
    /**
   * Returns an extended version of `Swal` containing `params` as defaults.
   * Useful for reusing Swal configuration.
   *
   * For example:
   *
   * Before:
   * const textPromptOptions = { input: 'text', showCancelButton: true }
   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
   *
   * After:
   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
   * const {value: firstName} = await TextPrompt('What is your first name?')
   * const {value: lastName} = await TextPrompt('What is your last name?')
   *
   * @param {SweetAlertOptions} mixinParams
   * @returns {SweetAlert}
   * @this {typeof import('../SweetAlert.js').SweetAlert}
   */ function mixin(mixinParams) {
        // @ts-ignore: 'this' refers to the SweetAlert constructor
        var MixinSwal = /*#__PURE__*/ function(_this) {
            _inherits._(MixinSwal, _this);
            function MixinSwal() {
                _class_call_check._(this, MixinSwal);
                return _call_super._(this, MixinSwal, arguments);
            }
            _create_class._(MixinSwal, [
                {
                    /**
       * @param {any} params
       * @param {any} priorityMixinParams
       */ key: "_main",
                    value: function _main(params, priorityMixinParams) {
                        return _get._(_get_prototype_of._(MixinSwal.prototype), "_main", this).call(this, params, Object.assign({}, mixinParams, priorityMixinParams));
                    }
                }
            ]);
            return MixinSwal;
        }(this);
        // @ts-ignore
        return MixinSwal;
    }
    /**
   * If `timer` parameter is set, returns number of milliseconds of timer remained.
   * Otherwise, returns undefined.
   *
   * @returns {number | undefined}
   */ var getTimerLeft = function() {
        return globalState.timeout && globalState.timeout.getTimerLeft();
    };
    /**
   * Stop timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var stopTimer = function() {
        if (globalState.timeout) {
            stopTimerProgressBar();
            return globalState.timeout.stop();
        }
    };
    /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var resumeTimer = function() {
        if (globalState.timeout) {
            var remaining = globalState.timeout.start();
            animateTimerProgressBar(remaining);
            return remaining;
        }
    };
    /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var toggleTimer = function() {
        var timer = globalState.timeout;
        return timer && (timer.running ? stopTimer() : resumeTimer());
    };
    /**
   * Increase timer. Returns number of milliseconds of an updated timer.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @param {number} ms
   * @returns {number | undefined}
   */ var increaseTimer = function(ms) {
        if (globalState.timeout) {
            var remaining = globalState.timeout.increase(ms);
            animateTimerProgressBar(remaining, true);
            return remaining;
        }
    };
    /**
   * Check if timer is running. Returns true if timer is running
   * or false if timer is paused or stopped.
   * If `timer` parameter isn't set, returns undefined
   *
   * @returns {boolean}
   */ var isTimerRunning = function() {
        return Boolean(globalState.timeout && globalState.timeout.isRunning());
    };
    var bodyClickListenerAdded = false;
    /** @type {Record<string, any>} */ var clickHandlers = {};
    /**
   * @this {any}
   * @param {string} attr
   */ function bindClickHandler() {
        var attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'data-swal-template';
        clickHandlers[attr] = this;
        if (!bodyClickListenerAdded) {
            document.body.addEventListener('click', bodyClickListener);
            bodyClickListenerAdded = true;
        }
    }
    /**
   * @param {MouseEvent} event
   */ var bodyClickListener = function(event) {
        for(var el = /** @type {any} */ event.target; el && el !== document; el = el.parentNode){
            for(var attr in clickHandlers){
                var template = el.getAttribute && el.getAttribute(attr);
                if (template) {
                    clickHandlers[attr].fire({
                        template: template
                    });
                    return;
                }
            }
        }
    };
    // Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957
    var EventEmitter = /*#__PURE__*/ function() {
        function EventEmitter() {
            _class_call_check._(this, EventEmitter);
            /** @type {Events} */ this.events = {};
        }
        _create_class._(EventEmitter, [
            {
                /**
     * @param {string} eventName
     * @returns {EventHandlers}
     */ key: "_getHandlersByEventName",
                value: function _getHandlersByEventName(eventName) {
                    if (typeof this.events[eventName] === 'undefined') {
                        // not Set because we need to keep the FIFO order
                        // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334
                        this.events[eventName] = [];
                    }
                    return this.events[eventName];
                }
            },
            {
                /**
     * @param {string} eventName
     * @param {EventHandler} eventHandler
     */ key: "on",
                value: function on(eventName, eventHandler) {
                    var currentHandlers = this._getHandlersByEventName(eventName);
                    if (!currentHandlers.includes(eventHandler)) {
                        currentHandlers.push(eventHandler);
                    }
                }
            },
            {
                /**
     * @param {string} eventName
     * @param {EventHandler} eventHandler
     */ key: "once",
                value: function once(eventName, eventHandler) {
                    var _this = this;
                    /**
       * @param {...any} args
       */ var onceFn = function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        _this.removeListener(eventName, onceFn);
                        // @ts-ignore
                        eventHandler.apply(_this, args);
                    };
                    this.on(eventName, onceFn);
                }
            },
            {
                /**
     * @param {string} eventName
     * @param {...any} args
     */ key: "emit",
                value: function emit(eventName) {
                    var _this = this;
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    this._getHandlersByEventName(eventName).forEach(/**
       * @param {EventHandler} eventHandler
       */ function(eventHandler) {
                        try {
                            // @ts-ignore
                            eventHandler.apply(_this, args);
                        } catch (error) {
                            console.error(error);
                        }
                    });
                }
            },
            {
                /**
     * @param {string} eventName
     * @param {EventHandler} eventHandler
     */ key: "removeListener",
                value: function removeListener(eventName, eventHandler) {
                    var currentHandlers = this._getHandlersByEventName(eventName);
                    var index = currentHandlers.indexOf(eventHandler);
                    if (index > -1) {
                        currentHandlers.splice(index, 1);
                    }
                }
            },
            {
                /**
     * @param {string} eventName
     */ key: "removeAllListeners",
                value: function removeAllListeners(eventName) {
                    if (this.events[eventName] !== undefined) {
                        // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222
                        this.events[eventName].length = 0;
                    }
                }
            },
            {
                key: "reset",
                value: function reset() {
                    this.events = {};
                }
            }
        ]);
        return EventEmitter;
    }();
    globalState.eventEmitter = new EventEmitter();
    /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */ var on = function(eventName, eventHandler) {
        if (globalState.eventEmitter) {
            globalState.eventEmitter.on(eventName, eventHandler);
        }
    };
    /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */ var once = function(eventName, eventHandler) {
        if (globalState.eventEmitter) {
            globalState.eventEmitter.once(eventName, eventHandler);
        }
    };
    /**
   * @param {string} [eventName]
   * @param {EventHandler} [eventHandler]
   */ var off = function(eventName, eventHandler) {
        if (!globalState.eventEmitter) {
            return;
        }
        // Remove all handlers for all events
        if (!eventName) {
            globalState.eventEmitter.reset();
            return;
        }
        if (eventHandler) {
            // Remove a specific handler
            globalState.eventEmitter.removeListener(eventName, eventHandler);
        } else {
            // Remove all handlers for a specific event
            globalState.eventEmitter.removeAllListeners(eventName);
        }
    };
    var staticMethods = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        argsToParams: argsToParams,
        bindClickHandler: bindClickHandler,
        clickCancel: clickCancel,
        clickConfirm: clickConfirm,
        clickDeny: clickDeny,
        enableLoading: showLoading,
        fire: fire,
        getActions: getActions,
        getCancelButton: getCancelButton,
        getCloseButton: getCloseButton,
        getConfirmButton: getConfirmButton,
        getContainer: getContainer,
        getDenyButton: getDenyButton,
        getFocusableElements: getFocusableElements,
        getFooter: getFooter,
        getHtmlContainer: getHtmlContainer,
        getIcon: getIcon,
        getIconContent: getIconContent,
        getImage: getImage,
        getInputLabel: getInputLabel,
        getLoader: getLoader,
        getPopup: getPopup,
        getProgressSteps: getProgressSteps,
        getTimerLeft: getTimerLeft,
        getTimerProgressBar: getTimerProgressBar,
        getTitle: getTitle,
        getValidationMessage: getValidationMessage,
        increaseTimer: increaseTimer,
        isDeprecatedParameter: isDeprecatedParameter,
        isLoading: isLoading,
        isTimerRunning: isTimerRunning,
        isUpdatableParameter: isUpdatableParameter,
        isValidParameter: isValidParameter,
        isVisible: isVisible,
        mixin: mixin,
        off: off,
        on: on,
        once: once,
        resumeTimer: resumeTimer,
        showLoading: showLoading,
        stopTimer: stopTimer,
        toggleTimer: toggleTimer
    });
    var Timer = /*#__PURE__*/ function() {
        function Timer(callback, delay) {
            _class_call_check._(this, Timer);
            this.callback = callback;
            this.remaining = delay;
            this.running = false;
            this.start();
        }
        _create_class._(Timer, [
            {
                /**
     * @returns {number}
     */ key: "start",
                value: function start() {
                    if (!this.running) {
                        this.running = true;
                        this.started = new Date();
                        this.id = setTimeout(this.callback, this.remaining);
                    }
                    return this.remaining;
                }
            },
            {
                /**
     * @returns {number}
     */ key: "stop",
                value: function stop() {
                    if (this.started && this.running) {
                        this.running = false;
                        clearTimeout(this.id);
                        this.remaining -= new Date().getTime() - this.started.getTime();
                    }
                    return this.remaining;
                }
            },
            {
                /**
     * @param {number} n
     * @returns {number}
     */ key: "increase",
                value: function increase(n) {
                    var running = this.running;
                    if (running) {
                        this.stop();
                    }
                    this.remaining += n;
                    if (running) {
                        this.start();
                    }
                    return this.remaining;
                }
            },
            {
                /**
     * @returns {number}
     */ key: "getTimerLeft",
                value: function getTimerLeft() {
                    if (this.running) {
                        this.stop();
                        this.start();
                    }
                    return this.remaining;
                }
            },
            {
                /**
     * @returns {boolean}
     */ key: "isRunning",
                value: function isRunning() {
                    return this.running;
                }
            }
        ]);
        return Timer;
    }();
    var swalStringParams = [
        'swal-title',
        'swal-html',
        'swal-footer'
    ];
    /**
   * @param {SweetAlertOptions} params
   * @returns {SweetAlertOptions}
   */ var getTemplateParams = function(params) {
        var template = typeof params.template === 'string' ? /** @type {HTMLTemplateElement} */ document.querySelector(params.template) : params.template;
        if (!template) {
            return {};
        }
        /** @type {DocumentFragment} */ var templateContent = template.content;
        showWarningsForElements(templateContent);
        var result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {Record<string, string | boolean | number>}
   */ var getSwalParams = function(templateContent) {
        /** @type {Record<string, string | boolean | number>} */ var result = {};
        /** @type {HTMLElement[]} */ var swalParams = Array.from(templateContent.querySelectorAll('swal-param'));
        swalParams.forEach(function(param) {
            showWarningsForAttributes(param, [
                'name',
                'value'
            ]);
            var paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute('name');
            var value = param.getAttribute('value');
            if (!paramName || !value) {
                return;
            }
            if (paramName in defaultParams && typeof defaultParams[/** @type {keyof typeof defaultParams} */ paramName] === 'boolean') {
                result[paramName] = value !== 'false';
            } else if (paramName in defaultParams && _type_of._(defaultParams[/** @type {keyof typeof defaultParams} */ paramName]) === 'object') {
                result[paramName] = JSON.parse(value);
            } else {
                result[paramName] = value;
            }
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {Record<string, () => void>}
   */ var getSwalFunctionParams = function(templateContent) {
        /** @type {Record<string, () => void>} */ var result = {};
        /** @type {HTMLElement[]} */ var swalFunctions = Array.from(templateContent.querySelectorAll('swal-function-param'));
        swalFunctions.forEach(function(param) {
            var paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute('name');
            var value = param.getAttribute('value');
            if (!paramName || !value) {
                return;
            }
            result[paramName] = new Function("return ".concat(value))();
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {Record<string, string | boolean>}
   */ var getSwalButtons = function(templateContent) {
        /** @type {Record<string, string | boolean>} */ var result = {};
        /** @type {HTMLElement[]} */ var swalButtons = Array.from(templateContent.querySelectorAll('swal-button'));
        swalButtons.forEach(function(button) {
            showWarningsForAttributes(button, [
                'type',
                'color',
                'aria-label'
            ]);
            var type = button.getAttribute('type');
            if (!type || ![
                'confirm',
                'cancel',
                'deny'
            ].includes(type)) {
                return;
            }
            result["".concat(type, "ButtonText")] = button.innerHTML;
            result["show".concat(capitalizeFirstLetter(type), "Button")] = true;
            if (button.hasAttribute('color')) {
                var color = button.getAttribute('color');
                if (color !== null) {
                    result["".concat(type, "ButtonColor")] = color;
                }
            }
            if (button.hasAttribute('aria-label')) {
                var ariaLabel = button.getAttribute('aria-label');
                if (ariaLabel !== null) {
                    result["".concat(type, "ButtonAriaLabel")] = ariaLabel;
                }
            }
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}
   */ var getSwalImage = function(templateContent) {
        var result = {};
        /** @type {HTMLElement | null} */ var image = templateContent.querySelector('swal-image');
        if (image) {
            showWarningsForAttributes(image, [
                'src',
                'width',
                'height',
                'alt'
            ]);
            if (image.hasAttribute('src')) {
                result.imageUrl = image.getAttribute('src') || undefined;
            }
            if (image.hasAttribute('width')) {
                result.imageWidth = image.getAttribute('width') || undefined;
            }
            if (image.hasAttribute('height')) {
                result.imageHeight = image.getAttribute('height') || undefined;
            }
            if (image.hasAttribute('alt')) {
                result.imageAlt = image.getAttribute('alt') || undefined;
            }
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {object}
   */ var getSwalIcon = function(templateContent) {
        var result = {};
        /** @type {HTMLElement | null} */ var icon = templateContent.querySelector('swal-icon');
        if (icon) {
            showWarningsForAttributes(icon, [
                'type',
                'color'
            ]);
            if (icon.hasAttribute('type')) {
                result.icon = icon.getAttribute('type');
            }
            if (icon.hasAttribute('color')) {
                result.iconColor = icon.getAttribute('color');
            }
            result.iconHtml = icon.innerHTML;
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {object}
   */ var getSwalInput = function(templateContent) {
        /** @type {Record<string, any>} */ var result = {};
        /** @type {HTMLElement | null} */ var input = templateContent.querySelector('swal-input');
        if (input) {
            showWarningsForAttributes(input, [
                'type',
                'label',
                'placeholder',
                'value'
            ]);
            result.input = input.getAttribute('type') || 'text';
            if (input.hasAttribute('label')) {
                result.inputLabel = input.getAttribute('label');
            }
            if (input.hasAttribute('placeholder')) {
                result.inputPlaceholder = input.getAttribute('placeholder');
            }
            if (input.hasAttribute('value')) {
                result.inputValue = input.getAttribute('value');
            }
        }
        /** @type {HTMLElement[]} */ var inputOptions = Array.from(templateContent.querySelectorAll('swal-input-option'));
        if (inputOptions.length) {
            result.inputOptions = {};
            inputOptions.forEach(function(option) {
                showWarningsForAttributes(option, [
                    'value'
                ]);
                var optionValue = option.getAttribute('value');
                if (!optionValue) {
                    return;
                }
                var optionName = option.innerHTML;
                result.inputOptions[optionValue] = optionName;
            });
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @param {string[]} paramNames
   * @returns {Record<string, string>}
   */ var getSwalStringParams = function(templateContent, paramNames) {
        /** @type {Record<string, string>} */ var result = {};
        for(var i in paramNames){
            var paramName = paramNames[i];
            /** @type {HTMLElement | null} */ var tag = templateContent.querySelector(paramName);
            if (tag) {
                showWarningsForAttributes(tag, []);
                result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();
            }
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   */ var showWarningsForElements = function(templateContent) {
        var allowedElements = swalStringParams.concat([
            'swal-param',
            'swal-function-param',
            'swal-button',
            'swal-image',
            'swal-icon',
            'swal-input',
            'swal-input-option'
        ]);
        Array.from(templateContent.children).forEach(function(el) {
            var tagName = el.tagName.toLowerCase();
            if (!allowedElements.includes(tagName)) {
                warn("Unrecognized element <".concat(tagName, ">"));
            }
        });
    };
    /**
   * @param {HTMLElement} el
   * @param {string[]} allowedAttributes
   */ var showWarningsForAttributes = function(el, allowedAttributes) {
        Array.from(el.attributes).forEach(function(attribute) {
            if (allowedAttributes.indexOf(attribute.name) === -1) {
                warn([
                    'Unrecognized attribute "'.concat(attribute.name, '" on <').concat(el.tagName.toLowerCase(), ">."),
                    "".concat(allowedAttributes.length ? "Allowed attributes are: ".concat(allowedAttributes.join(', ')) : 'To set the value, use HTML within the element.')
                ]);
            }
        });
    };
    var SHOW_CLASS_TIMEOUT = 10;
    /**
   * Open popup, add necessary classes and styles, fix scrollbar
   *
   * @param {SweetAlertOptions} params
   */ var openPopup = function(params) {
        var _globalState$eventEmi, _globalState$eventEmi2;
        var container = getContainer();
        var popup = getPopup();
        if (!container || !popup) {
            return;
        }
        if (typeof params.willOpen === 'function') {
            params.willOpen(popup);
        }
        (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('willOpen', popup);
        var bodyStyles = window.getComputedStyle(document.body);
        var initialBodyOverflow = bodyStyles.overflowY;
        addClasses(container, popup, params);
        // scrolling is 'hidden' until animation is done, after that 'auto'
        setTimeout(function() {
            setScrollingVisibility(container, popup);
        }, SHOW_CLASS_TIMEOUT);
        if (isModal()) {
            // Using ternary instead of ?? operator for Webpack 4 compatibility
            fixScrollContainer(container, params.scrollbarPadding !== undefined ? params.scrollbarPadding : false, initialBodyOverflow);
            setAriaHidden();
        }
        if (!isToast() && !globalState.previousActiveElement) {
            globalState.previousActiveElement = document.activeElement;
        }
        if (typeof params.didOpen === 'function') {
            var didOpen = params.didOpen;
            setTimeout(function() {
                return didOpen(popup);
            });
        }
        (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit('didOpen', popup);
    };
    /**
   * @param {Event} event
   */ var swalOpenAnimationFinished = function(event) {
        var popup = getPopup();
        if (!popup || event.target !== popup) {
            return;
        }
        var container = getContainer();
        if (!container) {
            return;
        }
        popup.removeEventListener('animationend', swalOpenAnimationFinished);
        popup.removeEventListener('transitionend', swalOpenAnimationFinished);
        container.style.overflowY = 'auto';
        // no-transition is added in init() in case one swal is opened right after another
        removeClass(container, swalClasses['no-transition']);
    };
    /**
   * @param {HTMLElement} container
   * @param {HTMLElement} popup
   */ var setScrollingVisibility = function(container, popup) {
        if (hasCssAnimation(popup)) {
            container.style.overflowY = 'hidden';
            popup.addEventListener('animationend', swalOpenAnimationFinished);
            popup.addEventListener('transitionend', swalOpenAnimationFinished);
        } else {
            container.style.overflowY = 'auto';
        }
    };
    /**
   * @param {HTMLElement} container
   * @param {boolean} scrollbarPadding
   * @param {string} initialBodyOverflow
   */ var fixScrollContainer = function(container, scrollbarPadding, initialBodyOverflow) {
        iOSfix();
        if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
            replaceScrollbarWithPadding(initialBodyOverflow);
        }
        // sweetalert2/issues/1247
        setTimeout(function() {
            container.scrollTop = 0;
        });
    };
    /**
   * @param {HTMLElement} container
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} params
   */ var addClasses = function(container, popup, params) {
        var _params$showClass;
        if ((_params$showClass = params.showClass) !== null && _params$showClass !== void 0 && _params$showClass.backdrop) {
            addClass(container, params.showClass.backdrop);
        }
        if (params.animation) {
            // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059
            popup.style.setProperty('opacity', '0', 'important');
            show(popup, 'grid');
            setTimeout(function() {
                var _params$showClass2;
                // Animate popup right after showing it
                if ((_params$showClass2 = params.showClass) !== null && _params$showClass2 !== void 0 && _params$showClass2.popup) {
                    addClass(popup, params.showClass.popup);
                }
                // and remove the opacity workaround
                popup.style.removeProperty('opacity');
            }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062
        } else {
            show(popup, 'grid');
        }
        addClass([
            document.documentElement,
            document.body
        ], swalClasses.shown);
        if (params.heightAuto && params.backdrop && !params.toast) {
            addClass([
                document.documentElement,
                document.body
            ], swalClasses['height-auto']);
        }
    };
    var defaultInputValidators = {
        /**
     * @param {string} string
     * @param {string} [validationMessage]
     * @returns {Promise<string | void>}
     */ email: function(string, validationMessage) {
            return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
        },
        /**
     * @param {string} string
     * @param {string} [validationMessage]
     * @returns {Promise<string | void>}
     */ url: function(string, validationMessage) {
            // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
            return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
        }
    };
    /**
   * @param {SweetAlertOptions} params
   */ function setDefaultInputValidators(params) {
        // Use default `inputValidator` for supported input types if not provided
        if (params.inputValidator) {
            return;
        }
        if (params.input === 'email') {
            params.inputValidator = defaultInputValidators['email'];
        }
        if (params.input === 'url') {
            params.inputValidator = defaultInputValidators['url'];
        }
    }
    /**
   * @param {SweetAlertOptions} params
   */ function validateCustomTargetElement(params) {
        // Determine if the custom target element is valid
        if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
            warn('Target parameter is not valid, defaulting to "body"');
            params.target = 'body';
        }
    }
    /**
   * Set type, text and actions on popup
   *
   * @param {SweetAlertOptions} params
   */ function setParameters(params) {
        setDefaultInputValidators(params);
        // showLoaderOnConfirm && preConfirm
        if (params.showLoaderOnConfirm && !params.preConfirm) {
            warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
        }
        validateCustomTargetElement(params);
        // Replace newlines with <br> in title
        if (typeof params.title === 'string') {
            params.title = params.title.split('\n').join('<br />');
        }
        init(params);
    }
    /** @type {SweetAlert} */ var currentInstance;
    var _promise = /*#__PURE__*/ new WeakMap();
    var SweetAlert = /*#__PURE__*/ function() {
        function SweetAlert() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            _class_call_check._(this, SweetAlert);
            /**
       * @type {Promise<SweetAlertResult>}
       */ _classPrivateFieldInitSpec(this, _promise, /** @type {Promise<SweetAlertResult>} */ Promise.resolve({
                isConfirmed: false,
                isDenied: false,
                isDismissed: true
            }));
            // Prevent run in Node env
            if (typeof window === 'undefined') {
                return;
            }
            currentInstance = this;
            // @ts-ignore
            var outerParams = Object.freeze(this.constructor.argsToParams(args));
            /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;
            /** @type {boolean} */ this.isAwaitingPromise = false;
            _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
        }
        _create_class._(SweetAlert, [
            {
                /**
     * @param {any} userParams
     * @param {any} mixinParams
     */ key: "_main",
                value: function _main(userParams) {
                    var mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    showWarningsForParams(Object.assign({}, mixinParams, userParams));
                    if (globalState.currentInstance) {
                        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
                        var isAwaitingPromise = globalState.currentInstance.isAwaitingPromise;
                        globalState.currentInstance._destroy();
                        if (!isAwaitingPromise) {
                            swalPromiseResolve({
                                isDismissed: true
                            });
                        }
                        if (isModal()) {
                            unsetAriaHidden();
                        }
                    }
                    globalState.currentInstance = currentInstance;
                    var innerParams = prepareParams(userParams, mixinParams);
                    setParameters(innerParams);
                    Object.freeze(innerParams);
                    // clear the previous timer
                    if (globalState.timeout) {
                        globalState.timeout.stop();
                        delete globalState.timeout;
                    }
                    // clear the restore focus timeout
                    clearTimeout(globalState.restoreFocusTimeout);
                    var domCache = populateDomCache(currentInstance);
                    render(currentInstance, innerParams);
                    privateProps.innerParams.set(currentInstance, innerParams);
                    return swalPromise(currentInstance, domCache, innerParams);
                }
            },
            {
                // `catch` cannot be the name of a module export, so we define our thenable methods here instead
                /**
     * @param {any} onFulfilled
     */ key: "then",
                value: function then(onFulfilled) {
                    return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
                }
            },
            {
                /**
     * @param {any} onFinally
     */ key: "finally",
                value: function _finally(onFinally) {
                    return _classPrivateFieldGet2(_promise, this).finally(onFinally);
                }
            }
        ]);
        return SweetAlert;
    }();
    /**
   * @param {SweetAlert} instance
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   * @returns {Promise<SweetAlertResult>}
   */ var swalPromise = function(instance, domCache, innerParams) {
        return new Promise(function(resolve, reject) {
            // functions to handle all closings/dismissals
            /**
       * @param {DismissReason} dismiss
       */ var dismissWith = function(dismiss) {
                instance.close({
                    isDismissed: true,
                    dismiss: dismiss,
                    isConfirmed: false,
                    isDenied: false
                });
            };
            privateMethods.swalPromiseResolve.set(instance, resolve);
            privateMethods.swalPromiseReject.set(instance, reject);
            domCache.confirmButton.onclick = function() {
                handleConfirmButtonClick(instance);
            };
            domCache.denyButton.onclick = function() {
                handleDenyButtonClick(instance);
            };
            domCache.cancelButton.onclick = function() {
                handleCancelButtonClick(instance, dismissWith);
            };
            domCache.closeButton.onclick = function() {
                dismissWith(DismissReason.close);
            };
            handlePopupClick(innerParams, domCache, dismissWith);
            addKeydownHandler(globalState, innerParams, dismissWith);
            handleInputOptionsAndValue(instance, innerParams);
            openPopup(innerParams);
            setupTimer(globalState, innerParams, dismissWith);
            initFocus(domCache, innerParams);
            // Scroll container to top on open (#1247, #1946)
            setTimeout(function() {
                domCache.container.scrollTop = 0;
            });
        });
    };
    /**
   * @param {SweetAlertOptions} userParams
   * @param {SweetAlertOptions} mixinParams
   * @returns {SweetAlertOptions}
   */ var prepareParams = function(userParams, mixinParams) {
        var templateParams = getTemplateParams(userParams);
        var params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131
        params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
        params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
        if (params.animation === false) {
            params.showClass = {
                backdrop: 'swal2-noanimation'
            };
            params.hideClass = {};
        }
        return params;
    };
    /**
   * @param {SweetAlert} instance
   * @returns {DomCache}
   */ var populateDomCache = function(instance) {
        var domCache = /** @type {DomCache} */ {
            popup: /** @type {HTMLElement} */ getPopup(),
            container: /** @type {HTMLElement} */ getContainer(),
            actions: /** @type {HTMLElement} */ getActions(),
            confirmButton: /** @type {HTMLElement} */ getConfirmButton(),
            denyButton: /** @type {HTMLElement} */ getDenyButton(),
            cancelButton: /** @type {HTMLElement} */ getCancelButton(),
            loader: /** @type {HTMLElement} */ getLoader(),
            closeButton: /** @type {HTMLElement} */ getCloseButton(),
            validationMessage: /** @type {HTMLElement} */ getValidationMessage(),
            progressSteps: /** @type {HTMLElement} */ getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
    };
    /**
   * @param {GlobalState} globalState
   * @param {SweetAlertOptions} innerParams
   * @param {(dismiss: DismissReason) => void} dismissWith
   */ var setupTimer = function(globalState, innerParams, dismissWith) {
        var timerProgressBar = getTimerProgressBar();
        hide(timerProgressBar);
        if (innerParams.timer) {
            globalState.timeout = new Timer(function() {
                dismissWith('timer');
                delete globalState.timeout;
            }, innerParams.timer);
            if (innerParams.timerProgressBar && timerProgressBar) {
                show(timerProgressBar);
                applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');
                setTimeout(function() {
                    if (globalState.timeout && globalState.timeout.running) {
                        // timer can be already stopped or unset at this point
                        animateTimerProgressBar(/** @type {number} */ innerParams.timer);
                    }
                });
            }
        }
    };
    /**
   * Initialize focus in the popup:
   *
   * 1. If `toast` is `true`, don't steal focus from the document.
   * 2. Else if there is an [autofocus] element, focus it.
   * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.
   * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.
   * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.
   * 6. Else focus the first focusable element in a popup (if any).
   *
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   */ var initFocus = function(domCache, innerParams) {
        if (innerParams.toast) {
            return;
        }
        // TODO: this is dumb, remove `allowEnterKey` param in the next major version
        if (!callIfFunction(innerParams.allowEnterKey)) {
            warnAboutDeprecation('allowEnterKey');
            blurActiveElement();
            return;
        }
        if (focusAutofocus(domCache)) {
            return;
        }
        if (focusButton(domCache, innerParams)) {
            return;
        }
        setFocus(-1, 1);
    };
    /**
   * @param {DomCache} domCache
   * @returns {boolean}
   */ var focusAutofocus = function(domCache) {
        var autofocusElements = Array.from(domCache.popup.querySelectorAll('[autofocus]'));
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = autofocusElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var autofocusElement = _step.value;
                if (_instanceof._(autofocusElement, HTMLElement) && isVisible$1(autofocusElement)) {
                    autofocusElement.focus();
                    return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return false;
    };
    /**
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   * @returns {boolean}
   */ var focusButton = function(domCache, innerParams) {
        if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
            domCache.denyButton.focus();
            return true;
        }
        if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
            domCache.cancelButton.focus();
            return true;
        }
        if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
            domCache.confirmButton.focus();
            return true;
        }
        return false;
    };
    var blurActiveElement = function() {
        if (_instanceof._(document.activeElement, HTMLElement) && typeof document.activeElement.blur === 'function') {
            document.activeElement.blur();
        }
    };
    // Assign instance methods from src/instanceMethods/*.js to prototype
    SweetAlert.prototype.disableButtons = disableButtons;
    SweetAlert.prototype.enableButtons = enableButtons;
    SweetAlert.prototype.getInput = getInput;
    SweetAlert.prototype.disableInput = disableInput;
    SweetAlert.prototype.enableInput = enableInput;
    SweetAlert.prototype.hideLoading = hideLoading;
    SweetAlert.prototype.disableLoading = hideLoading;
    SweetAlert.prototype.showValidationMessage = showValidationMessage;
    SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
    SweetAlert.prototype.close = close;
    SweetAlert.prototype.closePopup = close;
    SweetAlert.prototype.closeModal = close;
    SweetAlert.prototype.closeToast = close;
    SweetAlert.prototype.rejectPromise = rejectPromise;
    SweetAlert.prototype.update = update;
    SweetAlert.prototype._destroy = _destroy;
    // Assign static methods from src/staticMethods/*.js to constructor
    Object.assign(SweetAlert, staticMethods);
    // Proxy to instance methods to constructor, for now, for backwards compatibility
    Object.keys(instanceMethods).forEach(function(key) {
        /**
     * @param {...(SweetAlertOptions | string | undefined)} args
     * @returns {SweetAlertResult | Promise<SweetAlertResult> | undefined}
     */ // @ts-ignore: Dynamic property assignment for backwards compatibility
        SweetAlert[key] = function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            // @ts-ignore
            if (currentInstance && currentInstance[key]) {
                var _currentInstance;
                // @ts-ignore
                return (_currentInstance = currentInstance)[key].apply(_currentInstance, _to_consumable_array._(args));
            }
            return undefined;
        };
    });
    SweetAlert.DismissReason = DismissReason;
    SweetAlert.version = '11.26.17';
    var Swal = SweetAlert;
    // @ts-ignore
    Swal.default = Swal;
    return Swal;
});
if (typeof /*TURBOPACK member replacement*/ __turbopack_context__.e !== 'undefined' && /*TURBOPACK member replacement*/ __turbopack_context__.e.Sweetalert2) {
    /*TURBOPACK member replacement*/ __turbopack_context__.e.swal = /*TURBOPACK member replacement*/ __turbopack_context__.e.sweetAlert = /*TURBOPACK member replacement*/ __turbopack_context__.e.Swal = /*TURBOPACK member replacement*/ __turbopack_context__.e.SweetAlert = /*TURBOPACK member replacement*/ __turbopack_context__.e.Sweetalert2;
}
"undefined" != typeof document && function(e, t) {
    var n = e.createElement("style");
    if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);
    else try {
        n.innerHTML = t;
    } catch (e) {
        n.innerText = t;
    }
}(document, ":root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.15s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-timer-progress-bar-background: rgba(0, 0, 0, 0.3);--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;overflow-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:var(--swal2-timer-progress-bar-background)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;overflow-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}100%{transform:translate3d(0, 0, 0) scale(1);opacity:1}}@keyframes swal2-hide{0%{transform:translate3d(0, 0, 0) scale(1);opacity:1}100%{transform:translate3d(0, -50px, 0) scale(0.9);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}");
}),
]);

//# sourceMappingURL=node_modules_sweetalert2_dist_sweetalert2_all_8244646a.js.map